\doxysection{gmock-\/matchers.h}
\hypertarget{gmock-matchers_8h_source}{}\label{gmock-matchers_8h_source}\index{lib/googletest-\/master/googlemock/include/gmock/gmock-\/matchers.h@{lib/googletest-\/master/googlemock/include/gmock/gmock-\/matchers.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{//\ Copyright\ 2007,\ Google\ Inc.}}
\DoxyCodeLine{00002\ \textcolor{comment}{//\ All\ rights\ reserved.}}
\DoxyCodeLine{00003\ \textcolor{comment}{//}}
\DoxyCodeLine{00004\ \textcolor{comment}{//\ Redistribution\ and\ use\ in\ source\ and\ binary\ forms,\ with\ or\ without}}
\DoxyCodeLine{00005\ \textcolor{comment}{//\ modification,\ are\ permitted\ provided\ that\ the\ following\ conditions\ are}}
\DoxyCodeLine{00006\ \textcolor{comment}{//\ met:}}
\DoxyCodeLine{00007\ \textcolor{comment}{//}}
\DoxyCodeLine{00008\ \textcolor{comment}{//\ \ \ \ \ *\ Redistributions\ of\ source\ code\ must\ retain\ the\ above\ copyright}}
\DoxyCodeLine{00009\ \textcolor{comment}{//\ notice,\ this\ list\ of\ conditions\ and\ the\ following\ disclaimer.}}
\DoxyCodeLine{00010\ \textcolor{comment}{//\ \ \ \ \ *\ Redistributions\ in\ binary\ form\ must\ reproduce\ the\ above}}
\DoxyCodeLine{00011\ \textcolor{comment}{//\ copyright\ notice,\ this\ list\ of\ conditions\ and\ the\ following\ disclaimer}}
\DoxyCodeLine{00012\ \textcolor{comment}{//\ in\ the\ documentation\ and/or\ other\ materials\ provided\ with\ the}}
\DoxyCodeLine{00013\ \textcolor{comment}{//\ distribution.}}
\DoxyCodeLine{00014\ \textcolor{comment}{//\ \ \ \ \ *\ Neither\ the\ name\ of\ Google\ Inc.\ nor\ the\ names\ of\ its}}
\DoxyCodeLine{00015\ \textcolor{comment}{//\ contributors\ may\ be\ used\ to\ endorse\ or\ promote\ products\ derived\ from}}
\DoxyCodeLine{00016\ \textcolor{comment}{//\ this\ software\ without\ specific\ prior\ written\ permission.}}
\DoxyCodeLine{00017\ \textcolor{comment}{//}}
\DoxyCodeLine{00018\ \textcolor{comment}{//\ THIS\ SOFTWARE\ IS\ PROVIDED\ BY\ THE\ COPYRIGHT\ HOLDERS\ AND\ CONTRIBUTORS}}
\DoxyCodeLine{00019\ \textcolor{comment}{//\ "{}AS\ IS"{}\ AND\ ANY\ EXPRESS\ OR\ IMPLIED\ WARRANTIES,\ INCLUDING,\ BUT\ NOT}}
\DoxyCodeLine{00020\ \textcolor{comment}{//\ LIMITED\ TO,\ THE\ IMPLIED\ WARRANTIES\ OF\ MERCHANTABILITY\ AND\ FITNESS\ FOR}}
\DoxyCodeLine{00021\ \textcolor{comment}{//\ A\ PARTICULAR\ PURPOSE\ ARE\ DISCLAIMED.\ IN\ NO\ EVENT\ SHALL\ THE\ COPYRIGHT}}
\DoxyCodeLine{00022\ \textcolor{comment}{//\ OWNER\ OR\ CONTRIBUTORS\ BE\ LIABLE\ FOR\ ANY\ DIRECT,\ INDIRECT,\ INCIDENTAL,}}
\DoxyCodeLine{00023\ \textcolor{comment}{//\ SPECIAL,\ EXEMPLARY,\ OR\ CONSEQUENTIAL\ DAMAGES\ (INCLUDING,\ BUT\ NOT}}
\DoxyCodeLine{00024\ \textcolor{comment}{//\ LIMITED\ TO,\ PROCUREMENT\ OF\ SUBSTITUTE\ GOODS\ OR\ SERVICES;\ LOSS\ OF\ USE,}}
\DoxyCodeLine{00025\ \textcolor{comment}{//\ DATA,\ OR\ PROFITS;\ OR\ BUSINESS\ INTERRUPTION)\ HOWEVER\ CAUSED\ AND\ ON\ ANY}}
\DoxyCodeLine{00026\ \textcolor{comment}{//\ THEORY\ OF\ LIABILITY,\ WHETHER\ IN\ CONTRACT,\ STRICT\ LIABILITY,\ OR\ TORT}}
\DoxyCodeLine{00027\ \textcolor{comment}{//\ (INCLUDING\ NEGLIGENCE\ OR\ OTHERWISE)\ ARISING\ IN\ ANY\ WAY\ OUT\ OF\ THE\ USE}}
\DoxyCodeLine{00028\ \textcolor{comment}{//\ OF\ THIS\ SOFTWARE,\ EVEN\ IF\ ADVISED\ OF\ THE\ POSSIBILITY\ OF\ SUCH\ DAMAGE.}}
\DoxyCodeLine{00029\ }
\DoxyCodeLine{00030\ }
\DoxyCodeLine{00031\ \textcolor{comment}{//\ Google\ Mock\ -\/\ a\ framework\ for\ writing\ C++\ mock\ classes.}}
\DoxyCodeLine{00032\ \textcolor{comment}{//}}
\DoxyCodeLine{00033\ \textcolor{comment}{//\ The\ MATCHER*\ family\ of\ macros\ can\ be\ used\ in\ a\ namespace\ scope\ to}}
\DoxyCodeLine{00034\ \textcolor{comment}{//\ define\ custom\ matchers\ easily.}}
\DoxyCodeLine{00035\ \textcolor{comment}{//}}
\DoxyCodeLine{00036\ \textcolor{comment}{//\ Basic\ Usage}}
\DoxyCodeLine{00037\ \textcolor{comment}{//\ ===========}}
\DoxyCodeLine{00038\ \textcolor{comment}{//}}
\DoxyCodeLine{00039\ \textcolor{comment}{//\ The\ syntax}}
\DoxyCodeLine{00040\ \textcolor{comment}{//}}
\DoxyCodeLine{00041\ \textcolor{comment}{//\ \ \ MATCHER(name,\ description\_string)\ \{\ statements;\ \}}}
\DoxyCodeLine{00042\ \textcolor{comment}{//}}
\DoxyCodeLine{00043\ \textcolor{comment}{//\ defines\ a\ matcher\ with\ the\ given\ name\ that\ executes\ the\ statements,}}
\DoxyCodeLine{00044\ \textcolor{comment}{//\ which\ must\ return\ a\ bool\ to\ indicate\ if\ the\ match\ succeeds.\ \ Inside}}
\DoxyCodeLine{00045\ \textcolor{comment}{//\ the\ statements,\ you\ can\ refer\ to\ the\ value\ being\ matched\ by\ 'arg',}}
\DoxyCodeLine{00046\ \textcolor{comment}{//\ and\ refer\ to\ its\ type\ by\ 'arg\_type'.}}
\DoxyCodeLine{00047\ \textcolor{comment}{//}}
\DoxyCodeLine{00048\ \textcolor{comment}{//\ The\ description\ string\ documents\ what\ the\ matcher\ does,\ and\ is\ used}}
\DoxyCodeLine{00049\ \textcolor{comment}{//\ to\ generate\ the\ failure\ message\ when\ the\ match\ fails.\ \ Since\ a}}
\DoxyCodeLine{00050\ \textcolor{comment}{//\ MATCHER()\ is\ usually\ defined\ in\ a\ header\ file\ shared\ by\ multiple}}
\DoxyCodeLine{00051\ \textcolor{comment}{//\ C++\ source\ files,\ we\ require\ the\ description\ to\ be\ a\ C-\/string}}
\DoxyCodeLine{00052\ \textcolor{comment}{//\ literal\ to\ avoid\ possible\ side\ effects.\ \ It\ can\ be\ empty,\ in\ which}}
\DoxyCodeLine{00053\ \textcolor{comment}{//\ case\ we'll\ use\ the\ sequence\ of\ words\ in\ the\ matcher\ name\ as\ the}}
\DoxyCodeLine{00054\ \textcolor{comment}{//\ description.}}
\DoxyCodeLine{00055\ \textcolor{comment}{//}}
\DoxyCodeLine{00056\ \textcolor{comment}{//\ For\ example:}}
\DoxyCodeLine{00057\ \textcolor{comment}{//}}
\DoxyCodeLine{00058\ \textcolor{comment}{//\ \ \ MATCHER(IsEven,\ "{}"{})\ \{\ return\ (arg\ \%\ 2)\ ==\ 0;\ \}}}
\DoxyCodeLine{00059\ \textcolor{comment}{//}}
\DoxyCodeLine{00060\ \textcolor{comment}{//\ allows\ you\ to\ write}}
\DoxyCodeLine{00061\ \textcolor{comment}{//}}
\DoxyCodeLine{00062\ \textcolor{comment}{//\ \ \ //\ Expects\ mock\_foo.Bar(n)\ to\ be\ called\ where\ n\ is\ even.}}
\DoxyCodeLine{00063\ \textcolor{comment}{//\ \ \ EXPECT\_CALL(mock\_foo,\ Bar(IsEven()));}}
\DoxyCodeLine{00064\ \textcolor{comment}{//}}
\DoxyCodeLine{00065\ \textcolor{comment}{//\ or,}}
\DoxyCodeLine{00066\ \textcolor{comment}{//}}
\DoxyCodeLine{00067\ \textcolor{comment}{//\ \ \ //\ Verifies\ that\ the\ value\ of\ some\_expression\ is\ even.}}
\DoxyCodeLine{00068\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(some\_expression,\ IsEven());}}
\DoxyCodeLine{00069\ \textcolor{comment}{//}}
\DoxyCodeLine{00070\ \textcolor{comment}{//\ If\ the\ above\ assertion\ fails,\ it\ will\ print\ something\ like:}}
\DoxyCodeLine{00071\ \textcolor{comment}{//}}
\DoxyCodeLine{00072\ \textcolor{comment}{//\ \ \ Value\ of:\ some\_expression}}
\DoxyCodeLine{00073\ \textcolor{comment}{//\ \ \ Expected:\ is\ even}}
\DoxyCodeLine{00074\ \textcolor{comment}{//\ \ \ \ \ Actual:\ 7}}
\DoxyCodeLine{00075\ \textcolor{comment}{//}}
\DoxyCodeLine{00076\ \textcolor{comment}{//\ where\ the\ description\ "{}is\ even"{}\ is\ automatically\ calculated\ from\ the}}
\DoxyCodeLine{00077\ \textcolor{comment}{//\ matcher\ name\ IsEven.}}
\DoxyCodeLine{00078\ \textcolor{comment}{//}}
\DoxyCodeLine{00079\ \textcolor{comment}{//\ Argument\ Type}}
\DoxyCodeLine{00080\ \textcolor{comment}{//\ =============}}
\DoxyCodeLine{00081\ \textcolor{comment}{//}}
\DoxyCodeLine{00082\ \textcolor{comment}{//\ Note\ that\ the\ type\ of\ the\ value\ being\ matched\ (arg\_type)\ is}}
\DoxyCodeLine{00083\ \textcolor{comment}{//\ determined\ by\ the\ context\ in\ which\ you\ use\ the\ matcher\ and\ is}}
\DoxyCodeLine{00084\ \textcolor{comment}{//\ supplied\ to\ you\ by\ the\ compiler,\ so\ you\ don't\ need\ to\ worry\ about}}
\DoxyCodeLine{00085\ \textcolor{comment}{//\ declaring\ it\ (nor\ can\ you).\ \ This\ allows\ the\ matcher\ to\ be}}
\DoxyCodeLine{00086\ \textcolor{comment}{//\ polymorphic.\ \ For\ example,\ IsEven()\ can\ be\ used\ to\ match\ any\ type}}
\DoxyCodeLine{00087\ \textcolor{comment}{//\ where\ the\ value\ of\ "{}(arg\ \%\ 2)\ ==\ 0"{}\ can\ be\ implicitly\ converted\ to}}
\DoxyCodeLine{00088\ \textcolor{comment}{//\ a\ bool.\ \ In\ the\ "{}Bar(IsEven())"{}\ example\ above,\ if\ method\ Bar()}}
\DoxyCodeLine{00089\ \textcolor{comment}{//\ takes\ an\ int,\ 'arg\_type'\ will\ be\ int;\ if\ it\ takes\ an\ unsigned\ long,}}
\DoxyCodeLine{00090\ \textcolor{comment}{//\ 'arg\_type'\ will\ be\ unsigned\ long;\ and\ so\ on.}}
\DoxyCodeLine{00091\ \textcolor{comment}{//}}
\DoxyCodeLine{00092\ \textcolor{comment}{//\ Parameterizing\ Matchers}}
\DoxyCodeLine{00093\ \textcolor{comment}{//\ =======================}}
\DoxyCodeLine{00094\ \textcolor{comment}{//}}
\DoxyCodeLine{00095\ \textcolor{comment}{//\ Sometimes\ you'll\ want\ to\ parameterize\ the\ matcher.\ \ For\ that\ you}}
\DoxyCodeLine{00096\ \textcolor{comment}{//\ can\ use\ another\ macro:}}
\DoxyCodeLine{00097\ \textcolor{comment}{//}}
\DoxyCodeLine{00098\ \textcolor{comment}{//\ \ \ MATCHER\_P(name,\ param\_name,\ description\_string)\ \{\ statements;\ \}}}
\DoxyCodeLine{00099\ \textcolor{comment}{//}}
\DoxyCodeLine{00100\ \textcolor{comment}{//\ For\ example:}}
\DoxyCodeLine{00101\ \textcolor{comment}{//}}
\DoxyCodeLine{00102\ \textcolor{comment}{//\ \ \ MATCHER\_P(HasAbsoluteValue,\ value,\ "{}"{})\ \{\ return\ abs(arg)\ ==\ value;\ \}}}
\DoxyCodeLine{00103\ \textcolor{comment}{//}}
\DoxyCodeLine{00104\ \textcolor{comment}{//\ will\ allow\ you\ to\ write:}}
\DoxyCodeLine{00105\ \textcolor{comment}{//}}
\DoxyCodeLine{00106\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(Blah("{}a"{}),\ HasAbsoluteValue(n));}}
\DoxyCodeLine{00107\ \textcolor{comment}{//}}
\DoxyCodeLine{00108\ \textcolor{comment}{//\ which\ may\ lead\ to\ this\ message\ (assuming\ n\ is\ 10):}}
\DoxyCodeLine{00109\ \textcolor{comment}{//}}
\DoxyCodeLine{00110\ \textcolor{comment}{//\ \ \ Value\ of:\ Blah("{}a"{})}}
\DoxyCodeLine{00111\ \textcolor{comment}{//\ \ \ Expected:\ has\ absolute\ value\ 10}}
\DoxyCodeLine{00112\ \textcolor{comment}{//\ \ \ \ \ Actual:\ -\/9}}
\DoxyCodeLine{00113\ \textcolor{comment}{//}}
\DoxyCodeLine{00114\ \textcolor{comment}{//\ Note\ that\ both\ the\ matcher\ description\ and\ its\ parameter\ are}}
\DoxyCodeLine{00115\ \textcolor{comment}{//\ printed,\ making\ the\ message\ human-\/friendly.}}
\DoxyCodeLine{00116\ \textcolor{comment}{//}}
\DoxyCodeLine{00117\ \textcolor{comment}{//\ In\ the\ matcher\ definition\ body,\ you\ can\ write\ 'foo\_type'\ to}}
\DoxyCodeLine{00118\ \textcolor{comment}{//\ reference\ the\ type\ of\ a\ parameter\ named\ 'foo'.\ \ For\ example,\ in\ the}}
\DoxyCodeLine{00119\ \textcolor{comment}{//\ body\ of\ MATCHER\_P(HasAbsoluteValue,\ value)\ above,\ you\ can\ write}}
\DoxyCodeLine{00120\ \textcolor{comment}{//\ 'value\_type'\ to\ refer\ to\ the\ type\ of\ 'value'.}}
\DoxyCodeLine{00121\ \textcolor{comment}{//}}
\DoxyCodeLine{00122\ \textcolor{comment}{//\ We\ also\ provide\ MATCHER\_P2,\ MATCHER\_P3,\ ...,\ up\ to\ MATCHER\_P\$n\ to}}
\DoxyCodeLine{00123\ \textcolor{comment}{//\ support\ multi-\/parameter\ matchers.}}
\DoxyCodeLine{00124\ \textcolor{comment}{//}}
\DoxyCodeLine{00125\ \textcolor{comment}{//\ Describing\ Parameterized\ Matchers}}
\DoxyCodeLine{00126\ \textcolor{comment}{//\ =================================}}
\DoxyCodeLine{00127\ \textcolor{comment}{//}}
\DoxyCodeLine{00128\ \textcolor{comment}{//\ The\ last\ argument\ to\ MATCHER*()\ is\ a\ string-\/typed\ expression.\ \ The}}
\DoxyCodeLine{00129\ \textcolor{comment}{//\ expression\ can\ reference\ all\ of\ the\ matcher's\ parameters\ and\ a}}
\DoxyCodeLine{00130\ \textcolor{comment}{//\ special\ bool-\/typed\ variable\ named\ 'negation'.\ \ When\ 'negation'\ is}}
\DoxyCodeLine{00131\ \textcolor{comment}{//\ false,\ the\ expression\ should\ evaluate\ to\ the\ matcher's\ description;}}
\DoxyCodeLine{00132\ \textcolor{comment}{//\ otherwise\ it\ should\ evaluate\ to\ the\ description\ of\ the\ negation\ of}}
\DoxyCodeLine{00133\ \textcolor{comment}{//\ the\ matcher.\ \ For\ example,}}
\DoxyCodeLine{00134\ \textcolor{comment}{//}}
\DoxyCodeLine{00135\ \textcolor{comment}{//\ \ \ using\ testing::PrintToString;}}
\DoxyCodeLine{00136\ \textcolor{comment}{//}}
\DoxyCodeLine{00137\ \textcolor{comment}{//\ \ \ MATCHER\_P2(InClosedRange,\ low,\ hi,}}
\DoxyCodeLine{00138\ \textcolor{comment}{//\ \ \ \ \ \ \ std::string(negation\ ?\ "{}is\ not"{}\ :\ "{}is"{})\ +\ "{}\ in\ range\ ["{}\ +}}
\DoxyCodeLine{00139\ \textcolor{comment}{//\ \ \ \ \ \ \ PrintToString(low)\ +\ "{},\ "{}\ +\ PrintToString(hi)\ +\ "{}]"{})\ \{}}
\DoxyCodeLine{00140\ \textcolor{comment}{//\ \ \ \ \ return\ low\ <=\ arg\ \&\&\ arg\ <=\ hi;}}
\DoxyCodeLine{00141\ \textcolor{comment}{//\ \ \ \}}}
\DoxyCodeLine{00142\ \textcolor{comment}{//\ \ \ ...}}
\DoxyCodeLine{00143\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(3,\ InClosedRange(4,\ 6));}}
\DoxyCodeLine{00144\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(3,\ Not(InClosedRange(2,\ 4)));}}
\DoxyCodeLine{00145\ \textcolor{comment}{//}}
\DoxyCodeLine{00146\ \textcolor{comment}{//\ would\ generate\ two\ failures\ that\ contain\ the\ text:}}
\DoxyCodeLine{00147\ \textcolor{comment}{//}}
\DoxyCodeLine{00148\ \textcolor{comment}{//\ \ \ Expected:\ is\ in\ range\ [4,\ 6]}}
\DoxyCodeLine{00149\ \textcolor{comment}{//\ \ \ ...}}
\DoxyCodeLine{00150\ \textcolor{comment}{//\ \ \ Expected:\ is\ not\ in\ range\ [2,\ 4]}}
\DoxyCodeLine{00151\ \textcolor{comment}{//}}
\DoxyCodeLine{00152\ \textcolor{comment}{//\ If\ you\ specify\ "{}"{}\ as\ the\ description,\ the\ failure\ message\ will}}
\DoxyCodeLine{00153\ \textcolor{comment}{//\ contain\ the\ sequence\ of\ words\ in\ the\ matcher\ name\ followed\ by\ the}}
\DoxyCodeLine{00154\ \textcolor{comment}{//\ parameter\ values\ printed\ as\ a\ tuple.\ \ For\ example,}}
\DoxyCodeLine{00155\ \textcolor{comment}{//}}
\DoxyCodeLine{00156\ \textcolor{comment}{//\ \ \ MATCHER\_P2(InClosedRange,\ low,\ hi,\ "{}"{})\ \{\ ...\ \}}}
\DoxyCodeLine{00157\ \textcolor{comment}{//\ \ \ ...}}
\DoxyCodeLine{00158\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(3,\ InClosedRange(4,\ 6));}}
\DoxyCodeLine{00159\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(3,\ Not(InClosedRange(2,\ 4)));}}
\DoxyCodeLine{00160\ \textcolor{comment}{//}}
\DoxyCodeLine{00161\ \textcolor{comment}{//\ would\ generate\ two\ failures\ that\ contain\ the\ text:}}
\DoxyCodeLine{00162\ \textcolor{comment}{//}}
\DoxyCodeLine{00163\ \textcolor{comment}{//\ \ \ Expected:\ in\ closed\ range\ (4,\ 6)}}
\DoxyCodeLine{00164\ \textcolor{comment}{//\ \ \ ...}}
\DoxyCodeLine{00165\ \textcolor{comment}{//\ \ \ Expected:\ not\ (in\ closed\ range\ (2,\ 4))}}
\DoxyCodeLine{00166\ \textcolor{comment}{//}}
\DoxyCodeLine{00167\ \textcolor{comment}{//\ Types\ of\ Matcher\ Parameters}}
\DoxyCodeLine{00168\ \textcolor{comment}{//\ ===========================}}
\DoxyCodeLine{00169\ \textcolor{comment}{//}}
\DoxyCodeLine{00170\ \textcolor{comment}{//\ For\ the\ purpose\ of\ typing,\ you\ can\ view}}
\DoxyCodeLine{00171\ \textcolor{comment}{//}}
\DoxyCodeLine{00172\ \textcolor{comment}{//\ \ \ MATCHER\_Pk(Foo,\ p1,\ ...,\ pk,\ description\_string)\ \{\ ...\ \}}}
\DoxyCodeLine{00173\ \textcolor{comment}{//}}
\DoxyCodeLine{00174\ \textcolor{comment}{//\ as\ shorthand\ for}}
\DoxyCodeLine{00175\ \textcolor{comment}{//}}
\DoxyCodeLine{00176\ \textcolor{comment}{//\ \ \ template\ <typename\ p1\_type,\ ...,\ typename\ pk\_type>}}
\DoxyCodeLine{00177\ \textcolor{comment}{//\ \ \ FooMatcherPk<p1\_type,\ ...,\ pk\_type>}}
\DoxyCodeLine{00178\ \textcolor{comment}{//\ \ \ Foo(p1\_type\ p1,\ ...,\ pk\_type\ pk)\ \{\ ...\ \}}}
\DoxyCodeLine{00179\ \textcolor{comment}{//}}
\DoxyCodeLine{00180\ \textcolor{comment}{//\ When\ you\ write\ Foo(v1,\ ...,\ vk),\ the\ compiler\ infers\ the\ types\ of}}
\DoxyCodeLine{00181\ \textcolor{comment}{//\ the\ parameters\ v1,\ ...,\ and\ vk\ for\ you.\ \ If\ you\ are\ not\ happy\ with}}
\DoxyCodeLine{00182\ \textcolor{comment}{//\ the\ result\ of\ the\ type\ inference,\ you\ can\ specify\ the\ types\ by}}
\DoxyCodeLine{00183\ \textcolor{comment}{//\ explicitly\ instantiating\ the\ template,\ as\ in\ Foo<long,\ bool>(5,}}
\DoxyCodeLine{00184\ \textcolor{comment}{//\ false).\ \ As\ said\ earlier,\ you\ don't\ get\ to\ (or\ need\ to)\ specify}}
\DoxyCodeLine{00185\ \textcolor{comment}{//\ 'arg\_type'\ as\ that's\ determined\ by\ the\ context\ in\ which\ the\ matcher}}
\DoxyCodeLine{00186\ \textcolor{comment}{//\ is\ used.\ \ You\ can\ assign\ the\ result\ of\ expression\ Foo(p1,\ ...,\ pk)}}
\DoxyCodeLine{00187\ \textcolor{comment}{//\ to\ a\ variable\ of\ type\ FooMatcherPk<p1\_type,\ ...,\ pk\_type>.\ \ This}}
\DoxyCodeLine{00188\ \textcolor{comment}{//\ can\ be\ useful\ when\ composing\ matchers.}}
\DoxyCodeLine{00189\ \textcolor{comment}{//}}
\DoxyCodeLine{00190\ \textcolor{comment}{//\ While\ you\ can\ instantiate\ a\ matcher\ template\ with\ reference\ types,}}
\DoxyCodeLine{00191\ \textcolor{comment}{//\ passing\ the\ parameters\ by\ pointer\ usually\ makes\ your\ code\ more}}
\DoxyCodeLine{00192\ \textcolor{comment}{//\ readable.\ \ If,\ however,\ you\ still\ want\ to\ pass\ a\ parameter\ by}}
\DoxyCodeLine{00193\ \textcolor{comment}{//\ reference,\ be\ aware\ that\ in\ the\ failure\ message\ generated\ by\ the}}
\DoxyCodeLine{00194\ \textcolor{comment}{//\ matcher\ you\ will\ see\ the\ value\ of\ the\ referenced\ object\ but\ not\ its}}
\DoxyCodeLine{00195\ \textcolor{comment}{//\ address.}}
\DoxyCodeLine{00196\ \textcolor{comment}{//}}
\DoxyCodeLine{00197\ \textcolor{comment}{//\ Explaining\ Match\ Results}}
\DoxyCodeLine{00198\ \textcolor{comment}{//\ ========================}}
\DoxyCodeLine{00199\ \textcolor{comment}{//}}
\DoxyCodeLine{00200\ \textcolor{comment}{//\ Sometimes\ the\ matcher\ description\ alone\ isn't\ enough\ to\ explain\ why}}
\DoxyCodeLine{00201\ \textcolor{comment}{//\ the\ match\ has\ failed\ or\ succeeded.\ \ For\ example,\ when\ expecting\ a}}
\DoxyCodeLine{00202\ \textcolor{comment}{//\ long\ string,\ it\ can\ be\ very\ helpful\ to\ also\ print\ the\ diff\ between}}
\DoxyCodeLine{00203\ \textcolor{comment}{//\ the\ expected\ string\ and\ the\ actual\ one.\ \ To\ achieve\ that,\ you\ can}}
\DoxyCodeLine{00204\ \textcolor{comment}{//\ optionally\ stream\ additional\ information\ to\ a\ special\ variable}}
\DoxyCodeLine{00205\ \textcolor{comment}{//\ named\ result\_listener,\ whose\ type\ is\ a\ pointer\ to\ class}}
\DoxyCodeLine{00206\ \textcolor{comment}{//\ MatchResultListener:}}
\DoxyCodeLine{00207\ \textcolor{comment}{//}}
\DoxyCodeLine{00208\ \textcolor{comment}{//\ \ \ MATCHER\_P(EqualsLongString,\ str,\ "{}"{})\ \{}}
\DoxyCodeLine{00209\ \textcolor{comment}{//\ \ \ \ \ if\ (arg\ ==\ str)\ return\ true;}}
\DoxyCodeLine{00210\ \textcolor{comment}{//}}
\DoxyCodeLine{00211\ \textcolor{comment}{//\ \ \ \ \ *result\_listener\ <<\ "{}the\ difference:\ "{}}}
\DoxyCodeLine{00213\ \textcolor{comment}{//\ \ \ \ \ return\ false;}}
\DoxyCodeLine{00214\ \textcolor{comment}{//\ \ \ \}}}
\DoxyCodeLine{00215\ \textcolor{comment}{//}}
\DoxyCodeLine{00216\ \textcolor{comment}{//\ Overloading\ Matchers}}
\DoxyCodeLine{00217\ \textcolor{comment}{//\ ====================}}
\DoxyCodeLine{00218\ \textcolor{comment}{//}}
\DoxyCodeLine{00219\ \textcolor{comment}{//\ You\ can\ overload\ matchers\ with\ different\ numbers\ of\ parameters:}}
\DoxyCodeLine{00220\ \textcolor{comment}{//}}
\DoxyCodeLine{00221\ \textcolor{comment}{//\ \ \ MATCHER\_P(Blah,\ a,\ description\_string1)\ \{\ ...\ \}}}
\DoxyCodeLine{00222\ \textcolor{comment}{//\ \ \ MATCHER\_P2(Blah,\ a,\ b,\ description\_string2)\ \{\ ...\ \}}}
\DoxyCodeLine{00223\ \textcolor{comment}{//}}
\DoxyCodeLine{00224\ \textcolor{comment}{//\ Caveats}}
\DoxyCodeLine{00225\ \textcolor{comment}{//\ =======}}
\DoxyCodeLine{00226\ \textcolor{comment}{//}}
\DoxyCodeLine{00227\ \textcolor{comment}{//\ When\ defining\ a\ new\ matcher,\ you\ should\ also\ consider\ implementing}}
\DoxyCodeLine{00228\ \textcolor{comment}{//\ MatcherInterface\ or\ using\ MakePolymorphicMatcher().\ \ These}}
\DoxyCodeLine{00229\ \textcolor{comment}{//\ approaches\ require\ more\ work\ than\ the\ MATCHER*\ macros,\ but\ also}}
\DoxyCodeLine{00230\ \textcolor{comment}{//\ give\ you\ more\ control\ on\ the\ types\ of\ the\ value\ being\ matched\ and}}
\DoxyCodeLine{00231\ \textcolor{comment}{//\ the\ matcher\ parameters,\ which\ may\ leads\ to\ better\ compiler\ error}}
\DoxyCodeLine{00232\ \textcolor{comment}{//\ messages\ when\ the\ matcher\ is\ used\ wrong.\ \ They\ also\ allow}}
\DoxyCodeLine{00233\ \textcolor{comment}{//\ overloading\ matchers\ based\ on\ parameter\ types\ (as\ opposed\ to\ just}}
\DoxyCodeLine{00234\ \textcolor{comment}{//\ based\ on\ the\ number\ of\ parameters).}}
\DoxyCodeLine{00235\ \textcolor{comment}{//}}
\DoxyCodeLine{00236\ \textcolor{comment}{//\ MATCHER*()\ can\ only\ be\ used\ in\ a\ namespace\ scope\ as\ templates\ cannot\ be}}
\DoxyCodeLine{00237\ \textcolor{comment}{//\ declared\ inside\ of\ a\ local\ class.}}
\DoxyCodeLine{00238\ \textcolor{comment}{//}}
\DoxyCodeLine{00239\ \textcolor{comment}{//\ More\ Information}}
\DoxyCodeLine{00240\ \textcolor{comment}{//\ ================}}
\DoxyCodeLine{00241\ \textcolor{comment}{//}}
\DoxyCodeLine{00242\ \textcolor{comment}{//\ To\ learn\ more\ about\ using\ these\ macros,\ please\ search\ for\ 'MATCHER'}}
\DoxyCodeLine{00243\ \textcolor{comment}{//\ on}}
\DoxyCodeLine{00244\ \textcolor{comment}{//\ https://github.com/google/googletest/blob/master/docs/gmock\_cook\_book.md}}
\DoxyCodeLine{00245\ \textcolor{comment}{//}}
\DoxyCodeLine{00246\ \textcolor{comment}{//\ This\ file\ also\ implements\ some\ commonly\ used\ argument\ matchers.\ \ More}}
\DoxyCodeLine{00247\ \textcolor{comment}{//\ matchers\ can\ be\ defined\ by\ the\ user\ implementing\ the}}
\DoxyCodeLine{00248\ \textcolor{comment}{//\ MatcherInterface<T>\ interface\ if\ necessary.}}
\DoxyCodeLine{00249\ \textcolor{comment}{//}}
\DoxyCodeLine{00250\ \textcolor{comment}{//\ See\ googletest/include/gtest/gtest-\/matchers.h\ for\ the\ definition\ of\ class}}
\DoxyCodeLine{00251\ \textcolor{comment}{//\ Matcher,\ class\ MatcherInterface,\ and\ others.}}
\DoxyCodeLine{00252\ }
\DoxyCodeLine{00253\ \textcolor{preprocessor}{\#ifndef\ GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}
\DoxyCodeLine{00254\ \textcolor{preprocessor}{\#define\ GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}
\DoxyCodeLine{00255\ }
\DoxyCodeLine{00256\ \textcolor{preprocessor}{\#include\ <algorithm>}}
\DoxyCodeLine{00257\ \textcolor{preprocessor}{\#include\ <cmath>}}
\DoxyCodeLine{00258\ \textcolor{preprocessor}{\#include\ <initializer\_list>}}
\DoxyCodeLine{00259\ \textcolor{preprocessor}{\#include\ <iterator>}}
\DoxyCodeLine{00260\ \textcolor{preprocessor}{\#include\ <limits>}}
\DoxyCodeLine{00261\ \textcolor{preprocessor}{\#include\ <memory>}}
\DoxyCodeLine{00262\ \textcolor{preprocessor}{\#include\ <ostream>}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00263\ \textcolor{preprocessor}{\#include\ <sstream>}}
\DoxyCodeLine{00264\ \textcolor{preprocessor}{\#include\ <string>}}
\DoxyCodeLine{00265\ \textcolor{preprocessor}{\#include\ <type\_traits>}}
\DoxyCodeLine{00266\ \textcolor{preprocessor}{\#include\ <utility>}}
\DoxyCodeLine{00267\ \textcolor{preprocessor}{\#include\ <vector>}}
\DoxyCodeLine{00268\ }
\DoxyCodeLine{00269\ \textcolor{preprocessor}{\#include\ "{}gmock/internal/gmock-\/internal-\/utils.h"{}}}
\DoxyCodeLine{00270\ \textcolor{preprocessor}{\#include\ "{}gmock/internal/gmock-\/port.h"{}}}
\DoxyCodeLine{00271\ \textcolor{preprocessor}{\#include\ "{}gmock/internal/gmock-\/pp.h"{}}}
\DoxyCodeLine{00272\ \textcolor{preprocessor}{\#include\ "{}gtest/gtest.h"{}}}
\DoxyCodeLine{00273\ }
\DoxyCodeLine{00274\ \textcolor{comment}{//\ MSVC\ warning\ C5046\ is\ new\ as\ of\ VS2017\ version\ 15.8.}}
\DoxyCodeLine{00275\ \textcolor{preprocessor}{\#if\ defined(\_MSC\_VER)\ \&\&\ \_MSC\_VER\ >=\ 1915}}
\DoxyCodeLine{00276\ \textcolor{preprocessor}{\#define\ GMOCK\_MAYBE\_5046\_\ 5046}}
\DoxyCodeLine{00277\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00278\ \textcolor{preprocessor}{\#define\ GMOCK\_MAYBE\_5046\_}}
\DoxyCodeLine{00279\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00280\ }
\DoxyCodeLine{00281\ GTEST\_DISABLE\_MSC\_WARNINGS\_PUSH\_(}
\DoxyCodeLine{00282\ \ \ \ \ 4251\ GMOCK\_MAYBE\_5046\_\ \textcolor{comment}{/*\ class\ A\ needs\ to\ have\ dll-\/interface\ to\ be\ used\ by}}
\DoxyCodeLine{00283\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ clients\ of\ class\ B\ */}}
\DoxyCodeLine{00284\ \ \ \ \ \textcolor{comment}{/*\ Symbol\ involving\ type\ with\ internal\ linkage\ not\ defined\ */})}
\DoxyCodeLine{00285\ }
\DoxyCodeLine{00286\ \textcolor{keyword}{namespace\ }testing\ \{}
\DoxyCodeLine{00287\ }
\DoxyCodeLine{00288\ \textcolor{comment}{//\ To\ implement\ a\ matcher\ Foo\ for\ type\ T,\ define:}}
\DoxyCodeLine{00289\ \textcolor{comment}{//\ \ \ 1.\ a\ class\ FooMatcherImpl\ that\ implements\ the}}
\DoxyCodeLine{00290\ \textcolor{comment}{//\ \ \ \ \ \ MatcherInterface<T>\ interface,\ and}}
\DoxyCodeLine{00291\ \textcolor{comment}{//\ \ \ 2.\ a\ factory\ function\ that\ creates\ a\ Matcher<T>\ object\ from\ a}}
\DoxyCodeLine{00292\ \textcolor{comment}{//\ \ \ \ \ \ FooMatcherImpl*.}}
\DoxyCodeLine{00293\ \textcolor{comment}{//}}
\DoxyCodeLine{00294\ \textcolor{comment}{//\ The\ two-\/level\ delegation\ design\ makes\ it\ possible\ to\ allow\ a\ user}}
\DoxyCodeLine{00295\ \textcolor{comment}{//\ to\ write\ "{}v"{}\ instead\ of\ "{}Eq(v)"{}\ where\ a\ Matcher\ is\ expected,\ which}}
\DoxyCodeLine{00296\ \textcolor{comment}{//\ is\ impossible\ if\ we\ pass\ matchers\ by\ pointers.\ \ It\ also\ eases}}
\DoxyCodeLine{00297\ \textcolor{comment}{//\ ownership\ management\ as\ Matcher\ objects\ can\ now\ be\ copied\ like}}
\DoxyCodeLine{00298\ \textcolor{comment}{//\ plain\ values.}}
\DoxyCodeLine{00299\ }
\DoxyCodeLine{00300\ \textcolor{comment}{//\ A\ match\ result\ listener\ that\ stores\ the\ explanation\ in\ a\ string.}}
\DoxyCodeLine{00301\ \textcolor{keyword}{class\ }StringMatchResultListener\ :\ \textcolor{keyword}{public}\ MatchResultListener\ \{}
\DoxyCodeLine{00302\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00303\ \ \ StringMatchResultListener()\ :\ MatchResultListener(\&ss\_)\ \{\}}
\DoxyCodeLine{00304\ }
\DoxyCodeLine{00305\ \ \ \textcolor{comment}{//\ Returns\ the\ explanation\ accumulated\ so\ far.}}
\DoxyCodeLine{00306\ \ \ std::string\ str()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ ss\_.str();\ \}}
\DoxyCodeLine{00307\ }
\DoxyCodeLine{00308\ \ \ \textcolor{comment}{//\ Clears\ the\ explanation\ accumulated\ so\ far.}}
\DoxyCodeLine{00309\ \ \ \textcolor{keywordtype}{void}\ Clear()\ \{\ ss\_.str(\textcolor{stringliteral}{"{}"{}});\ \}}
\DoxyCodeLine{00310\ }
\DoxyCodeLine{00311\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00312\ \ \ ::std::stringstream\ ss\_;}
\DoxyCodeLine{00313\ }
\DoxyCodeLine{00314\ \ \ GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(StringMatchResultListener);}
\DoxyCodeLine{00315\ \};}
\DoxyCodeLine{00316\ }
\DoxyCodeLine{00317\ \textcolor{comment}{//\ Anything\ inside\ the\ 'internal'\ namespace\ IS\ INTERNAL\ IMPLEMENTATION}}
\DoxyCodeLine{00318\ \textcolor{comment}{//\ and\ MUST\ NOT\ BE\ USED\ IN\ USER\ CODE!!!}}
\DoxyCodeLine{00319\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{00320\ }
\DoxyCodeLine{00321\ \textcolor{comment}{//\ The\ MatcherCastImpl\ class\ template\ is\ a\ helper\ for\ implementing}}
\DoxyCodeLine{00322\ \textcolor{comment}{//\ MatcherCast().\ \ We\ need\ this\ helper\ in\ order\ to\ partially}}
\DoxyCodeLine{00323\ \textcolor{comment}{//\ specialize\ the\ implementation\ of\ MatcherCast()\ (C++\ allows}}
\DoxyCodeLine{00324\ \textcolor{comment}{//\ class/struct\ templates\ to\ be\ partially\ specialized,\ but\ not}}
\DoxyCodeLine{00325\ \textcolor{comment}{//\ function\ templates.).}}
\DoxyCodeLine{00326\ }
\DoxyCodeLine{00327\ \textcolor{comment}{//\ This\ general\ version\ is\ used\ when\ MatcherCast()'s\ argument\ is\ a}}
\DoxyCodeLine{00328\ \textcolor{comment}{//\ polymorphic\ matcher\ (i.e.\ something\ that\ can\ be\ converted\ to\ a}}
\DoxyCodeLine{00329\ \textcolor{comment}{//\ Matcher\ but\ is\ not\ one\ yet;\ for\ example,\ Eq(value))\ or\ a\ value\ (for}}
\DoxyCodeLine{00330\ \textcolor{comment}{//\ example,\ "{}hello"{}).}}
\DoxyCodeLine{00331\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{00332\ \textcolor{keyword}{class\ }MatcherCastImpl\ \{}
\DoxyCodeLine{00333\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00334\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ Cast(\textcolor{keyword}{const}\ M\&\ polymorphic\_matcher\_or\_value)\ \{}
\DoxyCodeLine{00335\ \ \ \ \ \textcolor{comment}{//\ M\ can\ be\ a\ polymorphic\ matcher,\ in\ which\ case\ we\ want\ to\ use}}
\DoxyCodeLine{00336\ \ \ \ \ \textcolor{comment}{//\ its\ conversion\ operator\ to\ create\ Matcher<T>.\ \ Or\ it\ can\ be\ a\ value}}
\DoxyCodeLine{00337\ \ \ \ \ \textcolor{comment}{//\ that\ should\ be\ passed\ to\ the\ Matcher<T>'s\ constructor.}}
\DoxyCodeLine{00338\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00339\ \ \ \ \ \textcolor{comment}{//\ We\ can't\ call\ Matcher<T>(polymorphic\_matcher\_or\_value)\ when\ M\ is\ a}}
\DoxyCodeLine{00340\ \ \ \ \ \textcolor{comment}{//\ polymorphic\ matcher\ because\ it'll\ be\ ambiguous\ if\ T\ has\ an\ implicit}}
\DoxyCodeLine{00341\ \ \ \ \ \textcolor{comment}{//\ constructor\ from\ M\ (this\ usually\ happens\ when\ T\ has\ an\ implicit}}
\DoxyCodeLine{00342\ \ \ \ \ \textcolor{comment}{//\ constructor\ from\ any\ type).}}
\DoxyCodeLine{00343\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00344\ \ \ \ \ \textcolor{comment}{//\ It\ won't\ work\ to\ unconditionally\ implicit\_cast}}
\DoxyCodeLine{00345\ \ \ \ \ \textcolor{comment}{//\ polymorphic\_matcher\_or\_value\ to\ Matcher<T>\ because\ it\ won't\ trigger}}
\DoxyCodeLine{00346\ \ \ \ \ \textcolor{comment}{//\ a\ user-\/defined\ conversion\ from\ M\ to\ T\ if\ one\ exists\ (assuming\ M\ is}}
\DoxyCodeLine{00347\ \ \ \ \ \textcolor{comment}{//\ a\ value).}}
\DoxyCodeLine{00348\ \ \ \ \ \textcolor{keywordflow}{return}\ CastImpl(polymorphic\_matcher\_or\_value,}
\DoxyCodeLine{00349\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_convertible<M,\ Matcher<T>>\{\},}
\DoxyCodeLine{00350\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_convertible<M,\ T>\{\});}
\DoxyCodeLine{00351\ \ \ \}}
\DoxyCodeLine{00352\ }
\DoxyCodeLine{00353\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00354\ \ \ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{bool}\ Ignore>}
\DoxyCodeLine{00355\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ CastImpl(\textcolor{keyword}{const}\ M\&\ polymorphic\_matcher\_or\_value,}
\DoxyCodeLine{00356\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::true\_type\ \textcolor{comment}{/*\ convertible\_to\_matcher\ */},}
\DoxyCodeLine{00357\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::integral\_constant<bool,\ Ignore>)\ \{}
\DoxyCodeLine{00358\ \ \ \ \ \textcolor{comment}{//\ M\ is\ implicitly\ convertible\ to\ Matcher<T>,\ which\ means\ that\ either}}
\DoxyCodeLine{00359\ \ \ \ \ \textcolor{comment}{//\ M\ is\ a\ polymorphic\ matcher\ or\ Matcher<T>\ has\ an\ implicit\ constructor}}
\DoxyCodeLine{00360\ \ \ \ \ \textcolor{comment}{//\ from\ M.\ \ In\ both\ cases\ using\ the\ implicit\ conversion\ will\ produce\ a}}
\DoxyCodeLine{00361\ \ \ \ \ \textcolor{comment}{//\ matcher.}}
\DoxyCodeLine{00362\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00363\ \ \ \ \ \textcolor{comment}{//\ Even\ if\ T\ has\ an\ implicit\ constructor\ from\ M,\ it\ won't\ be\ called\ because}}
\DoxyCodeLine{00364\ \ \ \ \ \textcolor{comment}{//\ creating\ Matcher<T>\ would\ require\ a\ chain\ of\ two\ user-\/defined\ conversions}}
\DoxyCodeLine{00365\ \ \ \ \ \textcolor{comment}{//\ (first\ to\ create\ T\ from\ M\ and\ then\ to\ create\ Matcher<T>\ from\ T).}}
\DoxyCodeLine{00366\ \ \ \ \ \textcolor{keywordflow}{return}\ polymorphic\_matcher\_or\_value;}
\DoxyCodeLine{00367\ \ \ \}}
\DoxyCodeLine{00368\ }
\DoxyCodeLine{00369\ \ \ \textcolor{comment}{//\ M\ can't\ be\ implicitly\ converted\ to\ Matcher<T>,\ so\ M\ isn't\ a\ polymorphic}}
\DoxyCodeLine{00370\ \ \ \textcolor{comment}{//\ matcher.\ It's\ a\ value\ of\ a\ type\ implicitly\ convertible\ to\ T.\ Use\ direct}}
\DoxyCodeLine{00371\ \ \ \textcolor{comment}{//\ initialization\ to\ create\ a\ matcher.}}
\DoxyCodeLine{00372\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ CastImpl(\textcolor{keyword}{const}\ M\&\ value,}
\DoxyCodeLine{00373\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::false\_type\ \textcolor{comment}{/*\ convertible\_to\_matcher\ */},}
\DoxyCodeLine{00374\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::true\_type\ \textcolor{comment}{/*\ convertible\_to\_T\ */})\ \{}
\DoxyCodeLine{00375\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(ImplicitCast\_<T>(value));}
\DoxyCodeLine{00376\ \ \ \}}
\DoxyCodeLine{00377\ }
\DoxyCodeLine{00378\ \ \ \textcolor{comment}{//\ M\ can't\ be\ implicitly\ converted\ to\ either\ Matcher<T>\ or\ T.\ Attempt\ to\ use}}
\DoxyCodeLine{00379\ \ \ \textcolor{comment}{//\ polymorphic\ matcher\ Eq(value)\ in\ this\ case.}}
\DoxyCodeLine{00380\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00381\ \ \ \textcolor{comment}{//\ Note\ that\ we\ first\ attempt\ to\ perform\ an\ implicit\ cast\ on\ the\ value\ and}}
\DoxyCodeLine{00382\ \ \ \textcolor{comment}{//\ only\ fall\ back\ to\ the\ polymorphic\ Eq()\ matcher\ afterwards\ because\ the}}
\DoxyCodeLine{00383\ \ \ \textcolor{comment}{//\ latter\ calls\ bool\ operator==(const\ Lhs\&\ lhs,\ const\ Rhs\&\ rhs)\ in\ the\ end}}
\DoxyCodeLine{00384\ \ \ \textcolor{comment}{//\ which\ might\ be\ undefined\ even\ when\ Rhs\ is\ implicitly\ convertible\ to\ Lhs}}
\DoxyCodeLine{00385\ \ \ \textcolor{comment}{//\ (e.g.\ std::pair<const\ int,\ int>\ vs.\ std::pair<int,\ int>).}}
\DoxyCodeLine{00386\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00387\ \ \ \textcolor{comment}{//\ We\ don't\ define\ this\ method\ inline\ as\ we\ need\ the\ declaration\ of\ Eq().}}
\DoxyCodeLine{00388\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ CastImpl(\textcolor{keyword}{const}\ M\&\ value,}
\DoxyCodeLine{00389\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::false\_type\ \textcolor{comment}{/*\ convertible\_to\_matcher\ */},}
\DoxyCodeLine{00390\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::false\_type\ \textcolor{comment}{/*\ convertible\_to\_T\ */});}
\DoxyCodeLine{00391\ \};}
\DoxyCodeLine{00392\ }
\DoxyCodeLine{00393\ \textcolor{comment}{//\ This\ more\ specialized\ version\ is\ used\ when\ MatcherCast()'s\ argument}}
\DoxyCodeLine{00394\ \textcolor{comment}{//\ is\ already\ a\ Matcher.\ \ This\ only\ compiles\ when\ type\ T\ can\ be}}
\DoxyCodeLine{00395\ \textcolor{comment}{//\ statically\ converted\ to\ type\ U.}}
\DoxyCodeLine{00396\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00397\ \textcolor{keyword}{class\ }MatcherCastImpl<T,\ Matcher<U>\ >\ \{}
\DoxyCodeLine{00398\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00399\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ Cast(\textcolor{keyword}{const}\ Matcher<U>\&\ source\_matcher)\ \{}
\DoxyCodeLine{00400\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(\textcolor{keyword}{new}\ Impl(source\_matcher));}
\DoxyCodeLine{00401\ \ \ \}}
\DoxyCodeLine{00402\ }
\DoxyCodeLine{00403\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00404\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<T>\ \{}
\DoxyCodeLine{00405\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00406\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ Matcher<U>\&\ source\_matcher)}
\DoxyCodeLine{00407\ \ \ \ \ \ \ \ \ :\ source\_matcher\_(source\_matcher)\ \{\}}
\DoxyCodeLine{00408\ }
\DoxyCodeLine{00409\ \ \ \ \ \textcolor{comment}{//\ We\ delegate\ the\ matching\ logic\ to\ the\ source\ matcher.}}
\DoxyCodeLine{00410\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\ x,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00411\ \ \ \ \ \ \ \textcolor{keyword}{using\ }FromType\ =\ \textcolor{keyword}{typename}\ std::remove\_cv<\textcolor{keyword}{typename}\ std::remove\_pointer<}
\DoxyCodeLine{00412\ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_reference<T>::type>::type>::type;}
\DoxyCodeLine{00413\ \ \ \ \ \ \ \textcolor{keyword}{using\ }ToType\ =\ \textcolor{keyword}{typename}\ std::remove\_cv<\textcolor{keyword}{typename}\ std::remove\_pointer<}
\DoxyCodeLine{00414\ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_reference<U>::type>::type>::type;}
\DoxyCodeLine{00415\ \ \ \ \ \ \ \textcolor{comment}{//\ Do\ not\ allow\ implicitly\ converting\ base*/\&\ to\ derived*/\&.}}
\DoxyCodeLine{00416\ \ \ \ \ \ \ \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{00417\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Do\ not\ trigger\ if\ only\ one\ of\ them\ is\ a\ pointer.\ That\ implies\ a}}
\DoxyCodeLine{00418\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ regular\ conversion\ and\ not\ a\ down\_cast.}}
\DoxyCodeLine{00419\ \ \ \ \ \ \ \ \ \ \ (std::is\_pointer<typename\ std::remove\_reference<T>::type>::value\ !=}
\DoxyCodeLine{00420\ \ \ \ \ \ \ \ \ \ \ \ std::is\_pointer<typename\ std::remove\_reference<U>::type>::value)\ ||}
\DoxyCodeLine{00421\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<FromType,\ ToType>::value\ ||}
\DoxyCodeLine{00422\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ !std::is\_base\_of<FromType,\ ToType>::value,}
\DoxyCodeLine{00423\ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Can't\ implicitly\ convert\ from\ <base>\ to\ <derived>"{}});}
\DoxyCodeLine{00424\ }
\DoxyCodeLine{00425\ \ \ \ \ \ \ \textcolor{comment}{//\ Do\ the\ cast\ to\ \`{}U`\ explicitly\ if\ necessary.}}
\DoxyCodeLine{00426\ \ \ \ \ \ \ \textcolor{comment}{//\ Otherwise,\ let\ implicit\ conversions\ do\ the\ trick.}}
\DoxyCodeLine{00427\ \ \ \ \ \ \ \textcolor{keyword}{using\ }CastType\ =}
\DoxyCodeLine{00428\ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::conditional<std::is\_convertible<T\&,\ const\ U\&>::value,}
\DoxyCodeLine{00429\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ T\&,\ U>::type;}
\DoxyCodeLine{00430\ }
\DoxyCodeLine{00431\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ source\_matcher\_.MatchAndExplain(\textcolor{keyword}{static\_cast<}CastType\textcolor{keyword}{>}(x),}
\DoxyCodeLine{00432\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ listener);}
\DoxyCodeLine{00433\ \ \ \ \ \}}
\DoxyCodeLine{00434\ }
\DoxyCodeLine{00435\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00436\ \ \ \ \ \ \ source\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{00437\ \ \ \ \ \}}
\DoxyCodeLine{00438\ }
\DoxyCodeLine{00439\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00440\ \ \ \ \ \ \ source\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{00441\ \ \ \ \ \}}
\DoxyCodeLine{00442\ }
\DoxyCodeLine{00443\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00444\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<U>\ source\_matcher\_;}
\DoxyCodeLine{00445\ \ \ \};}
\DoxyCodeLine{00446\ \};}
\DoxyCodeLine{00447\ }
\DoxyCodeLine{00448\ \textcolor{comment}{//\ This\ even\ more\ specialized\ version\ is\ used\ for\ efficiently\ casting}}
\DoxyCodeLine{00449\ \textcolor{comment}{//\ a\ matcher\ to\ its\ own\ type.}}
\DoxyCodeLine{00450\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00451\ \textcolor{keyword}{class\ }MatcherCastImpl<T,\ Matcher<T>\ >\ \{}
\DoxyCodeLine{00452\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00453\ \ \ \textcolor{keyword}{static}\ Matcher<T>\ Cast(\textcolor{keyword}{const}\ Matcher<T>\&\ matcher)\ \{\ \textcolor{keywordflow}{return}\ matcher;\ \}}
\DoxyCodeLine{00454\ \};}
\DoxyCodeLine{00455\ }
\DoxyCodeLine{00456\ \textcolor{comment}{//\ Template\ specialization\ for\ parameterless\ Matcher.}}
\DoxyCodeLine{00457\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Derived>}
\DoxyCodeLine{00458\ \textcolor{keyword}{class\ }MatcherBaseImpl\ \{}
\DoxyCodeLine{00459\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00460\ \ \ MatcherBaseImpl()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{00461\ }
\DoxyCodeLine{00462\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00463\ \ \ operator\ ::testing::Matcher<T>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT(runtime/explicit)}}
\DoxyCodeLine{00464\ \ \ \ \ return\ ::testing::Matcher<T>(\textcolor{keyword}{new}}
\DoxyCodeLine{00465\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ Derived::template\ gmock\_Impl<T>());}
\DoxyCodeLine{00466\ \ \ \}}
\DoxyCodeLine{00467\ \};}
\DoxyCodeLine{00468\ }
\DoxyCodeLine{00469\ \textcolor{comment}{//\ Template\ specialization\ for\ Matcher\ with\ parameters.}}
\DoxyCodeLine{00470\ \textcolor{keyword}{template}\ <\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...>\ \textcolor{keyword}{class\ }Derived,\ \textcolor{keyword}{typename}...\ Ts>}
\DoxyCodeLine{00471\ \textcolor{keyword}{class\ }MatcherBaseImpl<Derived<Ts...>>\ \{}
\DoxyCodeLine{00472\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00473\ \ \ \textcolor{comment}{//\ Mark\ the\ constructor\ explicit\ for\ single\ argument\ T\ to\ avoid\ implicit}}
\DoxyCodeLine{00474\ \ \ \textcolor{comment}{//\ conversions.}}
\DoxyCodeLine{00475\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ E\ =\ std::enable\_if<\textcolor{keyword}{sizeof}...(Ts)\ ==\ 1>,}
\DoxyCodeLine{00476\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ E::type*\ =\ \textcolor{keyword}{nullptr}>}
\DoxyCodeLine{00477\ \ \ \textcolor{keyword}{explicit}\ MatcherBaseImpl(Ts...\ params)}
\DoxyCodeLine{00478\ \ \ \ \ \ \ :\ params\_(std::forward<Ts>(params)...)\ \{\}}
\DoxyCodeLine{00479\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ E\ =\ std::enable\_if<\textcolor{keyword}{sizeof}...(Ts)\ !=\ 1>,}
\DoxyCodeLine{00480\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ =\ \textcolor{keyword}{typename}\ E::type>}
\DoxyCodeLine{00481\ \ \ MatcherBaseImpl(Ts...\ params)\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00482\ \ \ \ \ \ \ :\ params\_(std::forward<Ts>(params)...)\ \{\}}
\DoxyCodeLine{00483\ }
\DoxyCodeLine{00484\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ F>}
\DoxyCodeLine{00485\ \ \ operator\ ::testing::Matcher<F>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT(runtime/explicit)}}
\DoxyCodeLine{00486\ \ \ \ \ \textcolor{keywordflow}{return}\ Apply<F>(MakeIndexSequence<\textcolor{keyword}{sizeof}...(Ts)>\{\});}
\DoxyCodeLine{00487\ \ \ \}}
\DoxyCodeLine{00488\ }
\DoxyCodeLine{00489\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00490\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ F,\ std::size\_t...\ tuple\_ids>}
\DoxyCodeLine{00491\ \ \ \mbox{\hyperlink{classtesting_1_1_matcher}{::testing::Matcher<F>}}\ Apply(IndexSequence<tuple\_ids...>)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00492\ \ \ \ \ return\ ::testing::Matcher<F>(}
\DoxyCodeLine{00493\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ \textcolor{keyword}{typename}\ Derived<Ts...>::template\ gmock\_Impl<F>(}
\DoxyCodeLine{00494\ \ \ \ \ \ \ \ \ \ \ \ \ std::get<tuple\_ids>(params\_)...));}
\DoxyCodeLine{00495\ \ \ \}}
\DoxyCodeLine{00496\ }
\DoxyCodeLine{00497\ \ \ \textcolor{keyword}{const}\ std::tuple<Ts...>\ params\_;}
\DoxyCodeLine{00498\ \};}
\DoxyCodeLine{00499\ }
\DoxyCodeLine{00500\ \}\ \ \textcolor{comment}{//\ namespace\ internal}}
\DoxyCodeLine{00501\ }
\DoxyCodeLine{00502\ \textcolor{comment}{//\ In\ order\ to\ be\ safe\ and\ clear,\ casting\ between\ different\ matcher}}
\DoxyCodeLine{00503\ \textcolor{comment}{//\ types\ is\ done\ explicitly\ via\ MatcherCast<T>(m),\ which\ takes\ a}}
\DoxyCodeLine{00504\ \textcolor{comment}{//\ matcher\ m\ and\ returns\ a\ Matcher<T>.\ \ It\ compiles\ only\ when\ T\ can\ be}}
\DoxyCodeLine{00505\ \textcolor{comment}{//\ statically\ converted\ to\ the\ argument\ type\ of\ m.}}
\DoxyCodeLine{00506\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{00507\ \textcolor{keyword}{inline}\ Matcher<T>\ MatcherCast(\textcolor{keyword}{const}\ M\&\ matcher)\ \{}
\DoxyCodeLine{00508\ \ \ \textcolor{keywordflow}{return}\ internal::MatcherCastImpl<T,\ M>::Cast(matcher);}
\DoxyCodeLine{00509\ \}}
\DoxyCodeLine{00510\ }
\DoxyCodeLine{00511\ \textcolor{comment}{//\ This\ overload\ handles\ polymorphic\ matchers\ and\ values\ only\ since}}
\DoxyCodeLine{00512\ \textcolor{comment}{//\ monomorphic\ matchers\ are\ handled\ by\ the\ next\ one.}}
\DoxyCodeLine{00513\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{00514\ \textcolor{keyword}{inline}\ Matcher<T>\ SafeMatcherCast(\textcolor{keyword}{const}\ M\&\ polymorphic\_matcher\_or\_value)\ \{}
\DoxyCodeLine{00515\ \ \ \textcolor{keywordflow}{return}\ MatcherCast<T>(polymorphic\_matcher\_or\_value);}
\DoxyCodeLine{00516\ \}}
\DoxyCodeLine{00517\ }
\DoxyCodeLine{00518\ \textcolor{comment}{//\ This\ overload\ handles\ monomorphic\ matchers.}}
\DoxyCodeLine{00519\ \textcolor{comment}{//}}
\DoxyCodeLine{00520\ \textcolor{comment}{//\ In\ general,\ if\ type\ T\ can\ be\ implicitly\ converted\ to\ type\ U,\ we\ can}}
\DoxyCodeLine{00521\ \textcolor{comment}{//\ safely\ convert\ a\ Matcher<U>\ to\ a\ Matcher<T>\ (i.e.\ Matcher\ is}}
\DoxyCodeLine{00522\ \textcolor{comment}{//\ contravariant):\ just\ keep\ a\ copy\ of\ the\ original\ Matcher<U>,\ convert\ the}}
\DoxyCodeLine{00523\ \textcolor{comment}{//\ argument\ from\ type\ T\ to\ U,\ and\ then\ pass\ it\ to\ the\ underlying\ Matcher<U>.}}
\DoxyCodeLine{00524\ \textcolor{comment}{//\ The\ only\ exception\ is\ when\ U\ is\ a\ reference\ and\ T\ is\ not,\ as\ the}}
\DoxyCodeLine{00525\ \textcolor{comment}{//\ underlying\ Matcher<U>\ may\ be\ interested\ in\ the\ argument's\ address,\ which}}
\DoxyCodeLine{00526\ \textcolor{comment}{//\ is\ not\ preserved\ in\ the\ conversion\ from\ T\ to\ U.}}
\DoxyCodeLine{00527\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00528\ \textcolor{keyword}{inline}\ Matcher<T>\ SafeMatcherCast(\textcolor{keyword}{const}\ Matcher<U>\&\ matcher)\ \{}
\DoxyCodeLine{00529\ \ \ \textcolor{comment}{//\ Enforce\ that\ T\ can\ be\ implicitly\ converted\ to\ U.}}
\DoxyCodeLine{00530\ \ \ \textcolor{keyword}{static\_assert}(std::is\_convertible<const\ T\&,\ const\ U\&>::value,}
\DoxyCodeLine{00531\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}T\ must\ be\ implicitly\ convertible\ to\ U"{}});}
\DoxyCodeLine{00532\ \ \ \textcolor{comment}{//\ Enforce\ that\ we\ are\ not\ converting\ a\ non-\/reference\ type\ T\ to\ a\ reference}}
\DoxyCodeLine{00533\ \ \ \textcolor{comment}{//\ type\ U.}}
\DoxyCodeLine{00534\ \ \ GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{00535\ \ \ \ \ \ \ std::is\_reference<T>::value\ ||\ !std::is\_reference<U>::value,}
\DoxyCodeLine{00536\ \ \ \ \ \ \ cannot\_convert\_non\_reference\_arg\_to\_reference);}
\DoxyCodeLine{00537\ \ \ \textcolor{comment}{//\ In\ case\ both\ T\ and\ U\ are\ arithmetic\ types,\ enforce\ that\ the}}
\DoxyCodeLine{00538\ \ \ \textcolor{comment}{//\ conversion\ is\ not\ lossy.}}
\DoxyCodeLine{00539\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(T)\ RawT;}
\DoxyCodeLine{00540\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(U)\ RawU;}
\DoxyCodeLine{00541\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ kTIsOther\ =\ GMOCK\_KIND\_OF\_(RawT)\ ==\ internal::kOther;}
\DoxyCodeLine{00542\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ kUIsOther\ =\ GMOCK\_KIND\_OF\_(RawU)\ ==\ internal::kOther;}
\DoxyCodeLine{00543\ \ \ GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{00544\ \ \ \ \ \ \ kTIsOther\ ||\ kUIsOther\ ||}
\DoxyCodeLine{00545\ \ \ \ \ \ \ (internal::LosslessArithmeticConvertible<RawT,\ RawU>::value),}
\DoxyCodeLine{00546\ \ \ \ \ \ \ conversion\_of\_arithmetic\_types\_must\_be\_lossless);}
\DoxyCodeLine{00547\ \ \ \textcolor{keywordflow}{return}\ MatcherCast<T>(matcher);}
\DoxyCodeLine{00548\ \}}
\DoxyCodeLine{00549\ }
\DoxyCodeLine{00550\ \textcolor{comment}{//\ A<T>()\ returns\ a\ matcher\ that\ matches\ any\ value\ of\ type\ T.}}
\DoxyCodeLine{00551\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00552\ Matcher<T>\ A();}
\DoxyCodeLine{00553\ }
\DoxyCodeLine{00554\ \textcolor{comment}{//\ Anything\ inside\ the\ 'internal'\ namespace\ IS\ INTERNAL\ IMPLEMENTATION}}
\DoxyCodeLine{00555\ \textcolor{comment}{//\ and\ MUST\ NOT\ BE\ USED\ IN\ USER\ CODE!!!}}
\DoxyCodeLine{00556\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{00557\ }
\DoxyCodeLine{00558\ \textcolor{comment}{//\ If\ the\ explanation\ is\ not\ empty,\ prints\ it\ to\ the\ ostream.}}
\DoxyCodeLine{00559\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ PrintIfNotEmpty(\textcolor{keyword}{const}\ std::string\&\ explanation,}
\DoxyCodeLine{00560\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::ostream*\ os)\ \{}
\DoxyCodeLine{00561\ \ \ \textcolor{keywordflow}{if}\ (explanation\ !=\ \textcolor{stringliteral}{"{}"{}}\ \&\&\ os\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00562\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ "{}}\ <<\ explanation;}
\DoxyCodeLine{00563\ \ \ \}}
\DoxyCodeLine{00564\ \}}
\DoxyCodeLine{00565\ }
\DoxyCodeLine{00566\ \textcolor{comment}{//\ Returns\ true\ if\ the\ given\ type\ name\ is\ easy\ to\ read\ by\ a\ human.}}
\DoxyCodeLine{00567\ \textcolor{comment}{//\ This\ is\ used\ to\ decide\ whether\ printing\ the\ type\ of\ a\ value\ might}}
\DoxyCodeLine{00568\ \textcolor{comment}{//\ be\ helpful.}}
\DoxyCodeLine{00569\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ IsReadableTypeName(\textcolor{keyword}{const}\ std::string\&\ type\_name)\ \{}
\DoxyCodeLine{00570\ \ \ \textcolor{comment}{//\ We\ consider\ a\ type\ name\ readable\ if\ it's\ short\ or\ doesn't\ contain}}
\DoxyCodeLine{00571\ \ \ \textcolor{comment}{//\ a\ template\ or\ function\ type.}}
\DoxyCodeLine{00572\ \ \ \textcolor{keywordflow}{return}\ (type\_name.length()\ <=\ 20\ ||}
\DoxyCodeLine{00573\ \ \ \ \ \ \ \ \ \ \ type\_name.find\_first\_of(\textcolor{stringliteral}{"{}<("{}})\ ==\ std::string::npos);}
\DoxyCodeLine{00574\ \}}
\DoxyCodeLine{00575\ }
\DoxyCodeLine{00576\ \textcolor{comment}{//\ Matches\ the\ value\ against\ the\ given\ matcher,\ prints\ the\ value\ and\ explains}}
\DoxyCodeLine{00577\ \textcolor{comment}{//\ the\ match\ result\ to\ the\ listener.\ Returns\ the\ match\ result.}}
\DoxyCodeLine{00578\ \textcolor{comment}{//\ 'listener'\ must\ not\ be\ NULL.}}
\DoxyCodeLine{00579\ \textcolor{comment}{//\ Value\ cannot\ be\ passed\ by\ const\ reference,\ because\ some\ matchers\ take\ a}}
\DoxyCodeLine{00580\ \textcolor{comment}{//\ non-\/const\ argument.}}
\DoxyCodeLine{00581\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Value,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00582\ \textcolor{keywordtype}{bool}\ MatchPrintAndExplain(Value\&\ value,\ \textcolor{keyword}{const}\ Matcher<T>\&\ matcher,}
\DoxyCodeLine{00583\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\ \{}
\DoxyCodeLine{00584\ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{00585\ \ \ \ \ \textcolor{comment}{//\ If\ the\ listener\ is\ not\ interested,\ we\ do\ not\ need\ to\ construct\ the}}
\DoxyCodeLine{00586\ \ \ \ \ \textcolor{comment}{//\ inner\ explanation.}}
\DoxyCodeLine{00587\ \ \ \ \ \textcolor{keywordflow}{return}\ matcher.Matches(value);}
\DoxyCodeLine{00588\ \ \ \}}
\DoxyCodeLine{00589\ }
\DoxyCodeLine{00590\ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{00591\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ matcher.MatchAndExplain(value,\ \&inner\_listener);}
\DoxyCodeLine{00592\ }
\DoxyCodeLine{00593\ \ \ UniversalPrint(value,\ listener-\/>stream());}
\DoxyCodeLine{00594\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{00595\ \ \ \textcolor{keyword}{const}\ std::string\&\ type\_name\ =\ GetTypeName<Value>();}
\DoxyCodeLine{00596\ \ \ \textcolor{keywordflow}{if}\ (IsReadableTypeName(type\_name))}
\DoxyCodeLine{00597\ \ \ \ \ *listener-\/>stream()\ <<\ \textcolor{stringliteral}{"{}\ (of\ type\ "{}}\ <<\ type\_name\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00598\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00599\ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{00600\ }
\DoxyCodeLine{00601\ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{00602\ \}}
\DoxyCodeLine{00603\ }
\DoxyCodeLine{00604\ \textcolor{comment}{//\ An\ internal\ helper\ class\ for\ doing\ compile-\/time\ loop\ on\ a\ tuple's}}
\DoxyCodeLine{00605\ \textcolor{comment}{//\ fields.}}
\DoxyCodeLine{00606\ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{00607\ \textcolor{keyword}{class\ }TuplePrefix\ \{}
\DoxyCodeLine{00608\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00609\ \ \ \textcolor{comment}{//\ TuplePrefix<N>::Matches(matcher\_tuple,\ value\_tuple)\ returns\ true}}
\DoxyCodeLine{00610\ \ \ \textcolor{comment}{//\ if\ and\ only\ if\ the\ first\ N\ fields\ of\ matcher\_tuple\ matches}}
\DoxyCodeLine{00611\ \ \ \textcolor{comment}{//\ the\ first\ N\ fields\ of\ value\_tuple,\ respectively.}}
\DoxyCodeLine{00612\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00613\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{bool}\ Matches(\textcolor{keyword}{const}\ MatcherTuple\&\ matcher\_tuple,}
\DoxyCodeLine{00614\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ value\_tuple)\ \{}
\DoxyCodeLine{00615\ \ \ \ \ \textcolor{keywordflow}{return}\ TuplePrefix<N\ -\/\ 1>::Matches(matcher\_tuple,\ value\_tuple)\ \&\&}
\DoxyCodeLine{00616\ \ \ \ \ \ \ \ \ \ \ \ std::get<N\ -\/\ 1>(matcher\_tuple).Matches(std::get<N\ -\/\ 1>(value\_tuple));}
\DoxyCodeLine{00617\ \ \ \}}
\DoxyCodeLine{00618\ }
\DoxyCodeLine{00619\ \ \ \textcolor{comment}{//\ TuplePrefix<N>::ExplainMatchFailuresTo(matchers,\ values,\ os)}}
\DoxyCodeLine{00620\ \ \ \textcolor{comment}{//\ describes\ failures\ in\ matching\ the\ first\ N\ fields\ of\ matchers}}
\DoxyCodeLine{00621\ \ \ \textcolor{comment}{//\ against\ the\ first\ N\ fields\ of\ values.\ \ If\ there\ is\ no\ failure,}}
\DoxyCodeLine{00622\ \ \ \textcolor{comment}{//\ nothing\ will\ be\ streamed\ to\ os.}}
\DoxyCodeLine{00623\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00624\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ ExplainMatchFailuresTo(\textcolor{keyword}{const}\ MatcherTuple\&\ matchers,}
\DoxyCodeLine{00625\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ values,}
\DoxyCodeLine{00626\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::ostream*\ os)\ \{}
\DoxyCodeLine{00627\ \ \ \ \ \textcolor{comment}{//\ First,\ describes\ failures\ in\ the\ first\ N\ -\/\ 1\ fields.}}
\DoxyCodeLine{00628\ \ \ \ \ TuplePrefix<N\ -\/\ 1>::ExplainMatchFailuresTo(matchers,\ values,\ os);}
\DoxyCodeLine{00629\ }
\DoxyCodeLine{00630\ \ \ \ \ \textcolor{comment}{//\ Then\ describes\ the\ failure\ (if\ any)\ in\ the\ (N\ -\/\ 1)-\/th\ (0-\/based)}}
\DoxyCodeLine{00631\ \ \ \ \ \textcolor{comment}{//\ field.}}
\DoxyCodeLine{00632\ \ \ \ \ \textcolor{keyword}{typename}\ std::tuple\_element<N\ -\/\ 1,\ MatcherTuple>::type\ matcher\ =}
\DoxyCodeLine{00633\ \ \ \ \ \ \ \ \ std::get<N\ -\/\ 1>(matchers);}
\DoxyCodeLine{00634\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ std::tuple\_element<N\ -\/\ 1,\ ValueTuple>::type\ Value;}
\DoxyCodeLine{00635\ \ \ \ \ \textcolor{keyword}{const}\ Value\&\ value\ =\ std::get<N\ -\/\ 1>(values);}
\DoxyCodeLine{00636\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{00637\ \ \ \ \ \textcolor{keywordflow}{if}\ (!matcher.MatchAndExplain(value,\ \&listener))\ \{}
\DoxyCodeLine{00638\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ \ Expected\ arg\ \#"{}}\ <<\ N\ -\/\ 1\ <<\ \textcolor{stringliteral}{"{}:\ "{}};}
\DoxyCodeLine{00639\ \ \ \ \ \ \ std::get<N\ -\/\ 1>(matchers).DescribeTo(os);}
\DoxyCodeLine{00640\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\ \ \ \ \ \ \ \ \ \ \ Actual:\ "{}};}
\DoxyCodeLine{00641\ \ \ \ \ \ \ \textcolor{comment}{//\ We\ remove\ the\ reference\ in\ type\ Value\ to\ prevent\ the}}
\DoxyCodeLine{00642\ \ \ \ \ \ \ \textcolor{comment}{//\ universal\ printer\ from\ printing\ the\ address\ of\ value,\ which}}
\DoxyCodeLine{00643\ \ \ \ \ \ \ \textcolor{comment}{//\ isn't\ interesting\ to\ the\ user\ most\ of\ the\ time.\ \ The}}
\DoxyCodeLine{00644\ \ \ \ \ \ \ \textcolor{comment}{//\ matcher's\ MatchAndExplain()\ method\ handles\ the\ case\ when}}
\DoxyCodeLine{00645\ \ \ \ \ \ \ \textcolor{comment}{//\ the\ address\ is\ interesting.}}
\DoxyCodeLine{00646\ \ \ \ \ \ \ internal::UniversalPrint(value,\ os);}
\DoxyCodeLine{00647\ \ \ \ \ \ \ PrintIfNotEmpty(listener.str(),\ os);}
\DoxyCodeLine{00648\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{00649\ \ \ \ \ \}}
\DoxyCodeLine{00650\ \ \ \}}
\DoxyCodeLine{00651\ \};}
\DoxyCodeLine{00652\ }
\DoxyCodeLine{00653\ \textcolor{comment}{//\ The\ base\ case.}}
\DoxyCodeLine{00654\ \textcolor{keyword}{template}\ <>}
\DoxyCodeLine{00655\ \textcolor{keyword}{class\ }TuplePrefix<0>\ \{}
\DoxyCodeLine{00656\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00657\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00658\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{bool}\ Matches(\textcolor{keyword}{const}\ MatcherTuple\&\ \textcolor{comment}{/*\ matcher\_tuple\ */},}
\DoxyCodeLine{00659\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ \textcolor{comment}{/*\ value\_tuple\ */})\ \{}
\DoxyCodeLine{00660\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00661\ \ \ \}}
\DoxyCodeLine{00662\ }
\DoxyCodeLine{00663\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00664\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ ExplainMatchFailuresTo(\textcolor{keyword}{const}\ MatcherTuple\&\ \textcolor{comment}{/*\ matchers\ */},}
\DoxyCodeLine{00665\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ \textcolor{comment}{/*\ values\ */},}
\DoxyCodeLine{00666\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::ostream*\ \textcolor{comment}{/*\ os\ */})\ \{\}}
\DoxyCodeLine{00667\ \};}
\DoxyCodeLine{00668\ }
\DoxyCodeLine{00669\ \textcolor{comment}{//\ TupleMatches(matcher\_tuple,\ value\_tuple)\ returns\ true\ if\ and\ only\ if}}
\DoxyCodeLine{00670\ \textcolor{comment}{//\ all\ matchers\ in\ matcher\_tuple\ match\ the\ corresponding\ fields\ in}}
\DoxyCodeLine{00671\ \textcolor{comment}{//\ value\_tuple.\ \ It\ is\ a\ compiler\ error\ if\ matcher\_tuple\ and}}
\DoxyCodeLine{00672\ \textcolor{comment}{//\ value\_tuple\ have\ different\ number\ of\ fields\ or\ incompatible\ field}}
\DoxyCodeLine{00673\ \textcolor{comment}{//\ types.}}
\DoxyCodeLine{00674\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00675\ \textcolor{keywordtype}{bool}\ TupleMatches(\textcolor{keyword}{const}\ MatcherTuple\&\ matcher\_tuple,}
\DoxyCodeLine{00676\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ value\_tuple)\ \{}
\DoxyCodeLine{00677\ \ \ \textcolor{comment}{//\ Makes\ sure\ that\ matcher\_tuple\ and\ value\_tuple\ have\ the\ same}}
\DoxyCodeLine{00678\ \ \ \textcolor{comment}{//\ number\ of\ fields.}}
\DoxyCodeLine{00679\ \ \ GTEST\_COMPILE\_ASSERT\_(std::tuple\_size<MatcherTuple>::value\ ==}
\DoxyCodeLine{00680\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::tuple\_size<ValueTuple>::value,}
\DoxyCodeLine{00681\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ matcher\_and\_value\_have\_different\_numbers\_of\_fields);}
\DoxyCodeLine{00682\ \ \ \textcolor{keywordflow}{return}\ TuplePrefix<std::tuple\_size<ValueTuple>::value>::Matches(matcher\_tuple,}
\DoxyCodeLine{00683\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ value\_tuple);}
\DoxyCodeLine{00684\ \}}
\DoxyCodeLine{00685\ }
\DoxyCodeLine{00686\ \textcolor{comment}{//\ Describes\ failures\ in\ matching\ matchers\ against\ values.\ \ If\ there}}
\DoxyCodeLine{00687\ \textcolor{comment}{//\ is\ no\ failure,\ nothing\ will\ be\ streamed\ to\ os.}}
\DoxyCodeLine{00688\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple,\ \textcolor{keyword}{typename}\ ValueTuple>}
\DoxyCodeLine{00689\ \textcolor{keywordtype}{void}\ ExplainMatchFailureTupleTo(\textcolor{keyword}{const}\ MatcherTuple\&\ matchers,}
\DoxyCodeLine{00690\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueTuple\&\ values,}
\DoxyCodeLine{00691\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::ostream*\ os)\ \{}
\DoxyCodeLine{00692\ \ \ TuplePrefix<std::tuple\_size<MatcherTuple>::value>::ExplainMatchFailuresTo(}
\DoxyCodeLine{00693\ \ \ \ \ \ \ matchers,\ values,\ os);}
\DoxyCodeLine{00694\ \}}
\DoxyCodeLine{00695\ }
\DoxyCodeLine{00696\ \textcolor{comment}{//\ TransformTupleValues\ and\ its\ helper.}}
\DoxyCodeLine{00697\ \textcolor{comment}{//}}
\DoxyCodeLine{00698\ \textcolor{comment}{//\ TransformTupleValuesHelper\ hides\ the\ internal\ machinery\ that}}
\DoxyCodeLine{00699\ \textcolor{comment}{//\ TransformTupleValues\ uses\ to\ implement\ a\ tuple\ traversal.}}
\DoxyCodeLine{00700\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple,\ \textcolor{keyword}{typename}\ Func,\ \textcolor{keyword}{typename}\ OutIter>}
\DoxyCodeLine{00701\ \textcolor{keyword}{class\ }TransformTupleValuesHelper\ \{}
\DoxyCodeLine{00702\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00703\ \ \ typedef\ ::std::tuple\_size<Tuple>\ TupleSize;}
\DoxyCodeLine{00704\ }
\DoxyCodeLine{00705\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00706\ \ \ \textcolor{comment}{//\ For\ each\ member\ of\ tuple\ 't',\ taken\ in\ order,\ evaluates\ '*out++\ =\ f(t)'.}}
\DoxyCodeLine{00707\ \ \ \textcolor{comment}{//\ Returns\ the\ final\ value\ of\ 'out'\ in\ case\ the\ caller\ needs\ it.}}
\DoxyCodeLine{00708\ \ \ \textcolor{keyword}{static}\ OutIter\ Run(Func\ f,\ \textcolor{keyword}{const}\ Tuple\&\ t,\ OutIter\ out)\ \{}
\DoxyCodeLine{00709\ \ \ \ \ \textcolor{keywordflow}{return}\ IterateOverTuple<Tuple,\ TupleSize::value>()(f,\ t,\ out);}
\DoxyCodeLine{00710\ \ \ \}}
\DoxyCodeLine{00711\ }
\DoxyCodeLine{00712\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00713\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tup,\ \textcolor{keywordtype}{size\_t}\ kRemainingSize>}
\DoxyCodeLine{00714\ \ \ \textcolor{keyword}{struct\ }IterateOverTuple\ \{}
\DoxyCodeLine{00715\ \ \ \ \ OutIter\ operator()\ (Func\ f,\ \textcolor{keyword}{const}\ Tup\&\ t,\ OutIter\ out)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00716\ \ \ \ \ \ \ *out++\ =\ f(::std::get<TupleSize::value\ -\/\ kRemainingSize>(t));}
\DoxyCodeLine{00717\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ IterateOverTuple<Tup,\ kRemainingSize\ -\/\ 1>()(f,\ t,\ out);}
\DoxyCodeLine{00718\ \ \ \ \ \}}
\DoxyCodeLine{00719\ \ \ \};}
\DoxyCodeLine{00720\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tup>}
\DoxyCodeLine{00721\ \ \ \textcolor{keyword}{struct\ }IterateOverTuple<Tup,\ 0>\ \{}
\DoxyCodeLine{00722\ \ \ \ \ OutIter\ operator()\ (Func\ \textcolor{comment}{/*\ f\ */},\ \textcolor{keyword}{const}\ Tup\&\ \textcolor{comment}{/*\ t\ */},\ OutIter\ out)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00723\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ out;}
\DoxyCodeLine{00724\ \ \ \ \ \}}
\DoxyCodeLine{00725\ \ \ \};}
\DoxyCodeLine{00726\ \};}
\DoxyCodeLine{00727\ }
\DoxyCodeLine{00728\ \textcolor{comment}{//\ Successively\ invokes\ 'f(element)'\ on\ each\ element\ of\ the\ tuple\ 't',}}
\DoxyCodeLine{00729\ \textcolor{comment}{//\ appending\ each\ result\ to\ the\ 'out'\ iterator.\ Returns\ the\ final\ value}}
\DoxyCodeLine{00730\ \textcolor{comment}{//\ of\ 'out'.}}
\DoxyCodeLine{00731\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple,\ \textcolor{keyword}{typename}\ Func,\ \textcolor{keyword}{typename}\ OutIter>}
\DoxyCodeLine{00732\ OutIter\ TransformTupleValues(Func\ f,\ \textcolor{keyword}{const}\ Tuple\&\ t,\ OutIter\ out)\ \{}
\DoxyCodeLine{00733\ \ \ \textcolor{keywordflow}{return}\ TransformTupleValuesHelper<Tuple,\ Func,\ OutIter>::Run(f,\ t,\ out);}
\DoxyCodeLine{00734\ \}}
\DoxyCodeLine{00735\ }
\DoxyCodeLine{00736\ \textcolor{comment}{//\ Implements\ \_,\ a\ matcher\ that\ matches\ any\ value\ of\ any}}
\DoxyCodeLine{00737\ \textcolor{comment}{//\ type.\ \ This\ is\ a\ polymorphic\ matcher,\ so\ we\ need\ a\ template\ type}}
\DoxyCodeLine{00738\ \textcolor{comment}{//\ conversion\ operator\ to\ make\ it\ appearing\ as\ a\ Matcher<T>\ for\ any}}
\DoxyCodeLine{00739\ \textcolor{comment}{//\ type\ T.}}
\DoxyCodeLine{00740\ \textcolor{keyword}{class\ }AnythingMatcher\ \{}
\DoxyCodeLine{00741\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00742\ \ \ \textcolor{keyword}{using\ }is\_gtest\_matcher\ =\ void;}
\DoxyCodeLine{00743\ }
\DoxyCodeLine{00744\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00745\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ \textcolor{comment}{/*\ x\ */},\ std::ostream*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00746\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00747\ \ \ \}}
\DoxyCodeLine{00748\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ anything"{}};\ \}}
\DoxyCodeLine{00749\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00750\ \ \ \ \ \textcolor{comment}{//\ This\ is\ mostly\ for\ completeness'\ sake,\ as\ it's\ not\ very\ useful}}
\DoxyCodeLine{00751\ \ \ \ \ \textcolor{comment}{//\ to\ write\ Not(A<bool>()).\ \ However\ we\ cannot\ completely\ rule\ out}}
\DoxyCodeLine{00752\ \ \ \ \ \textcolor{comment}{//\ such\ a\ possibility,\ and\ it\ doesn't\ hurt\ to\ be\ prepared.}}
\DoxyCodeLine{00753\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}never\ matches"{}};}
\DoxyCodeLine{00754\ \ \ \}}
\DoxyCodeLine{00755\ \};}
\DoxyCodeLine{00756\ }
\DoxyCodeLine{00757\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ IsNull()\ matcher,\ which\ matches\ any\ raw\ or\ smart}}
\DoxyCodeLine{00758\ \textcolor{comment}{//\ pointer\ that\ is\ NULL.}}
\DoxyCodeLine{00759\ \textcolor{keyword}{class\ }IsNullMatcher\ \{}
\DoxyCodeLine{00760\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00761\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{00762\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ Pointer\&\ p,}
\DoxyCodeLine{00763\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00764\ \ \ \ \ \textcolor{keywordflow}{return}\ p\ ==\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00765\ \ \ \}}
\DoxyCodeLine{00766\ }
\DoxyCodeLine{00767\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ NULL"{}};\ \}}
\DoxyCodeLine{00768\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00769\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ NULL"{}};}
\DoxyCodeLine{00770\ \ \ \}}
\DoxyCodeLine{00771\ \};}
\DoxyCodeLine{00772\ }
\DoxyCodeLine{00773\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ NotNull()\ matcher,\ which\ matches\ any\ raw\ or\ smart}}
\DoxyCodeLine{00774\ \textcolor{comment}{//\ pointer\ that\ is\ not\ NULL.}}
\DoxyCodeLine{00775\ \textcolor{keyword}{class\ }NotNullMatcher\ \{}
\DoxyCodeLine{00776\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00777\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{00778\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ Pointer\&\ p,}
\DoxyCodeLine{00779\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00780\ \ \ \ \ \textcolor{keywordflow}{return}\ p\ !=\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00781\ \ \ \}}
\DoxyCodeLine{00782\ }
\DoxyCodeLine{00783\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ NULL"{}};\ \}}
\DoxyCodeLine{00784\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00785\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ NULL"{}};}
\DoxyCodeLine{00786\ \ \ \}}
\DoxyCodeLine{00787\ \};}
\DoxyCodeLine{00788\ }
\DoxyCodeLine{00789\ \textcolor{comment}{//\ Ref(variable)\ matches\ any\ argument\ that\ is\ a\ reference\ to}}
\DoxyCodeLine{00790\ \textcolor{comment}{//\ 'variable'.\ \ This\ matcher\ is\ polymorphic\ as\ it\ can\ match\ any}}
\DoxyCodeLine{00791\ \textcolor{comment}{//\ super\ type\ of\ the\ type\ of\ 'variable'.}}
\DoxyCodeLine{00792\ \textcolor{comment}{//}}
\DoxyCodeLine{00793\ \textcolor{comment}{//\ The\ RefMatcher\ template\ class\ implements\ Ref(variable).\ \ It\ can}}
\DoxyCodeLine{00794\ \textcolor{comment}{//\ only\ be\ instantiated\ with\ a\ reference\ type.\ \ This\ prevents\ a\ user}}
\DoxyCodeLine{00795\ \textcolor{comment}{//\ from\ mistakenly\ using\ Ref(x)\ to\ match\ a\ non-\/reference\ function}}
\DoxyCodeLine{00796\ \textcolor{comment}{//\ argument.\ \ For\ example,\ the\ following\ will\ righteously\ cause\ a}}
\DoxyCodeLine{00797\ \textcolor{comment}{//\ compiler\ error:}}
\DoxyCodeLine{00798\ \textcolor{comment}{//}}
\DoxyCodeLine{00799\ \textcolor{comment}{//\ \ \ int\ n;}}
\DoxyCodeLine{00800\ \textcolor{comment}{//\ \ \ Matcher<int>\ m1\ =\ Ref(n);\ \ \ //\ This\ won't\ compile.}}
\DoxyCodeLine{00801\ \textcolor{comment}{//\ \ \ Matcher<int\&>\ m2\ =\ Ref(n);\ \ //\ This\ will\ compile.}}
\DoxyCodeLine{00802\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00803\ \textcolor{keyword}{class\ }RefMatcher;}
\DoxyCodeLine{00804\ }
\DoxyCodeLine{00805\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00806\ \textcolor{keyword}{class\ }RefMatcher<T\&>\ \{}
\DoxyCodeLine{00807\ \ \ \textcolor{comment}{//\ Google\ Mock\ is\ a\ generic\ framework\ and\ thus\ needs\ to\ support}}
\DoxyCodeLine{00808\ \ \ \textcolor{comment}{//\ mocking\ any\ function\ types,\ including\ those\ that\ take\ non-\/const}}
\DoxyCodeLine{00809\ \ \ \textcolor{comment}{//\ reference\ arguments.\ \ Therefore\ the\ template\ parameter\ T\ (and}}
\DoxyCodeLine{00810\ \ \ \textcolor{comment}{//\ Super\ below)\ can\ be\ instantiated\ to\ either\ a\ const\ type\ or\ a}}
\DoxyCodeLine{00811\ \ \ \textcolor{comment}{//\ non-\/const\ type.}}
\DoxyCodeLine{00812\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00813\ \ \ \textcolor{comment}{//\ RefMatcher()\ takes\ a\ T\&\ instead\ of\ const\ T\&,\ as\ we\ want\ the}}
\DoxyCodeLine{00814\ \ \ \textcolor{comment}{//\ compiler\ to\ catch\ using\ Ref(const\_value)\ as\ a\ matcher\ for\ a}}
\DoxyCodeLine{00815\ \ \ \textcolor{comment}{//\ non-\/const\ reference.}}
\DoxyCodeLine{00816\ \ \ \textcolor{keyword}{explicit}\ RefMatcher(T\&\ x)\ :\ object\_(x)\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00817\ }
\DoxyCodeLine{00818\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Super>}
\DoxyCodeLine{00819\ \ \ \textcolor{keyword}{operator}\ Matcher<Super\&>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00820\ \ \ \ \ \textcolor{comment}{//\ By\ passing\ object\_\ (type\ T\&)\ to\ Impl(),\ which\ expects\ a\ Super\&,}}
\DoxyCodeLine{00821\ \ \ \ \ \textcolor{comment}{//\ we\ make\ sure\ that\ Super\ is\ a\ super\ type\ of\ T.\ \ In\ particular,}}
\DoxyCodeLine{00822\ \ \ \ \ \textcolor{comment}{//\ this\ catches\ using\ Ref(const\_value)\ as\ a\ matcher\ for\ a}}
\DoxyCodeLine{00823\ \ \ \ \ \textcolor{comment}{//\ non-\/const\ reference,\ as\ you\ cannot\ implicitly\ convert\ a\ const}}
\DoxyCodeLine{00824\ \ \ \ \ \textcolor{comment}{//\ reference\ to\ a\ non-\/const\ reference.}}
\DoxyCodeLine{00825\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ Impl<Super>(object\_));}
\DoxyCodeLine{00826\ \ \ \}}
\DoxyCodeLine{00827\ }
\DoxyCodeLine{00828\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00829\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Super>}
\DoxyCodeLine{00830\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Super\&>\ \{}
\DoxyCodeLine{00831\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00832\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(Super\&\ x)\ :\ object\_(x)\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00833\ }
\DoxyCodeLine{00834\ \ \ \ \ \textcolor{comment}{//\ MatchAndExplain()\ takes\ a\ Super\&\ (as\ opposed\ to\ const\ Super\&)}}
\DoxyCodeLine{00835\ \ \ \ \ \textcolor{comment}{//\ in\ order\ to\ match\ the\ interface\ MatcherInterface<Super\&>.}}
\DoxyCodeLine{00836\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Super\&\ x,}
\DoxyCodeLine{00837\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00838\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ located\ @"{}}\ <<\ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const\ }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&x);}
\DoxyCodeLine{00839\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \&x\ ==\ \&object\_;}
\DoxyCodeLine{00840\ \ \ \ \ \}}
\DoxyCodeLine{00841\ }
\DoxyCodeLine{00842\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00843\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}references\ the\ variable\ "{}};}
\DoxyCodeLine{00844\ \ \ \ \ \ \ UniversalPrinter<Super\&>::Print(object\_,\ os);}
\DoxyCodeLine{00845\ \ \ \ \ \}}
\DoxyCodeLine{00846\ }
\DoxyCodeLine{00847\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00848\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ reference\ the\ variable\ "{}};}
\DoxyCodeLine{00849\ \ \ \ \ \ \ UniversalPrinter<Super\&>::Print(object\_,\ os);}
\DoxyCodeLine{00850\ \ \ \ \ \}}
\DoxyCodeLine{00851\ }
\DoxyCodeLine{00852\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00853\ \ \ \ \ \textcolor{keyword}{const}\ Super\&\ object\_;}
\DoxyCodeLine{00854\ \ \ \};}
\DoxyCodeLine{00855\ }
\DoxyCodeLine{00856\ \ \ T\&\ object\_;}
\DoxyCodeLine{00857\ \};}
\DoxyCodeLine{00858\ }
\DoxyCodeLine{00859\ \textcolor{comment}{//\ Polymorphic\ helper\ functions\ for\ narrow\ and\ wide\ string\ matchers.}}
\DoxyCodeLine{00860\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ CaseInsensitiveCStringEquals(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ lhs,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ rhs)\ \{}
\DoxyCodeLine{00861\ \ \ \textcolor{keywordflow}{return}\ String::CaseInsensitiveCStringEquals(lhs,\ rhs);}
\DoxyCodeLine{00862\ \}}
\DoxyCodeLine{00863\ }
\DoxyCodeLine{00864\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ CaseInsensitiveCStringEquals(\textcolor{keyword}{const}\ \textcolor{keywordtype}{wchar\_t}*\ lhs,}
\DoxyCodeLine{00865\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{wchar\_t}*\ rhs)\ \{}
\DoxyCodeLine{00866\ \ \ \textcolor{keywordflow}{return}\ String::CaseInsensitiveWideCStringEquals(lhs,\ rhs);}
\DoxyCodeLine{00867\ \}}
\DoxyCodeLine{00868\ }
\DoxyCodeLine{00869\ \textcolor{comment}{//\ String\ comparison\ for\ narrow\ or\ wide\ strings\ that\ can\ have\ embedded\ NUL}}
\DoxyCodeLine{00870\ \textcolor{comment}{//\ characters.}}
\DoxyCodeLine{00871\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{00872\ \textcolor{keywordtype}{bool}\ CaseInsensitiveStringEquals(\textcolor{keyword}{const}\ StringType\&\ s1,}
\DoxyCodeLine{00873\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ s2)\ \{}
\DoxyCodeLine{00874\ \ \ \textcolor{comment}{//\ Are\ the\ heads\ equal?}}
\DoxyCodeLine{00875\ \ \ \textcolor{keywordflow}{if}\ (!CaseInsensitiveCStringEquals(s1.c\_str(),\ s2.c\_str()))\ \{}
\DoxyCodeLine{00876\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00877\ \ \ \}}
\DoxyCodeLine{00878\ }
\DoxyCodeLine{00879\ \ \ \textcolor{comment}{//\ Skip\ the\ equal\ heads.}}
\DoxyCodeLine{00880\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{typename}\ StringType::value\_type\ nul\ =\ 0;}
\DoxyCodeLine{00881\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ i1\ =\ s1.find(nul),\ i2\ =\ s2.find(nul);}
\DoxyCodeLine{00882\ }
\DoxyCodeLine{00883\ \ \ \textcolor{comment}{//\ Are\ we\ at\ the\ end\ of\ either\ s1\ or\ s2?}}
\DoxyCodeLine{00884\ \ \ \textcolor{keywordflow}{if}\ (i1\ ==\ StringType::npos\ ||\ i2\ ==\ StringType::npos)\ \{}
\DoxyCodeLine{00885\ \ \ \ \ \textcolor{keywordflow}{return}\ i1\ ==\ i2;}
\DoxyCodeLine{00886\ \ \ \}}
\DoxyCodeLine{00887\ }
\DoxyCodeLine{00888\ \ \ \textcolor{comment}{//\ Are\ the\ tails\ equal?}}
\DoxyCodeLine{00889\ \ \ \textcolor{keywordflow}{return}\ CaseInsensitiveStringEquals(s1.substr(i1\ +\ 1),\ s2.substr(i2\ +\ 1));}
\DoxyCodeLine{00890\ \}}
\DoxyCodeLine{00891\ }
\DoxyCodeLine{00892\ \textcolor{comment}{//\ String\ matchers.}}
\DoxyCodeLine{00893\ }
\DoxyCodeLine{00894\ \textcolor{comment}{//\ Implements\ equality-\/based\ string\ matchers\ like\ StrEq,\ StrCaseNe,\ and\ etc.}}
\DoxyCodeLine{00895\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{00896\ \textcolor{keyword}{class\ }StrEqualityMatcher\ \{}
\DoxyCodeLine{00897\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00898\ \ \ StrEqualityMatcher(StringType\ str,\ \textcolor{keywordtype}{bool}\ expect\_eq,\ \textcolor{keywordtype}{bool}\ case\_sensitive)}
\DoxyCodeLine{00899\ \ \ \ \ \ \ :\ string\_(std::move(str)),}
\DoxyCodeLine{00900\ \ \ \ \ \ \ \ \ expect\_eq\_(expect\_eq),}
\DoxyCodeLine{00901\ \ \ \ \ \ \ \ \ case\_sensitive\_(case\_sensitive)\ \{\}}
\DoxyCodeLine{00902\ }
\DoxyCodeLine{00903\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00904\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ internal::StringView\&\ s,}
\DoxyCodeLine{00905\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00906\ \ \ \ \ \textcolor{comment}{//\ This\ should\ fail\ to\ compile\ if\ StringView\ is\ used\ with\ wide}}
\DoxyCodeLine{00907\ \ \ \ \ \textcolor{comment}{//\ strings.}}
\DoxyCodeLine{00908\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ str\ =\ std::string(s);}
\DoxyCodeLine{00909\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(str,\ listener);}
\DoxyCodeLine{00910\ \ \ \}}
\DoxyCodeLine{00911\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00912\ }
\DoxyCodeLine{00913\ \ \ \textcolor{comment}{//\ Accepts\ pointer\ types,\ particularly:}}
\DoxyCodeLine{00914\ \ \ \textcolor{comment}{//\ \ \ const\ char*}}
\DoxyCodeLine{00915\ \ \ \textcolor{comment}{//\ \ \ char*}}
\DoxyCodeLine{00916\ \ \ \textcolor{comment}{//\ \ \ const\ wchar\_t*}}
\DoxyCodeLine{00917\ \ \ \textcolor{comment}{//\ \ \ wchar\_t*}}
\DoxyCodeLine{00918\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CharType>}
\DoxyCodeLine{00919\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(CharType*\ s,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00920\ \ \ \ \ \textcolor{keywordflow}{if}\ (s\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00921\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ !expect\_eq\_;}
\DoxyCodeLine{00922\ \ \ \ \ \}}
\DoxyCodeLine{00923\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(StringType(s),\ listener);}
\DoxyCodeLine{00924\ \ \ \}}
\DoxyCodeLine{00925\ }
\DoxyCodeLine{00926\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ StringType.}}
\DoxyCodeLine{00927\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00928\ \ \ \textcolor{comment}{//\ This\ is\ a\ template,\ not\ just\ a\ plain\ function\ with\ const\ StringType\&,}}
\DoxyCodeLine{00929\ \ \ \textcolor{comment}{//\ because\ StringView\ has\ some\ interfering\ non-\/explicit\ constructors.}}
\DoxyCodeLine{00930\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{00931\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{00932\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00933\ \ \ \ \ \textcolor{keyword}{const}\ StringType\ s2(s);}
\DoxyCodeLine{00934\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ eq\ =\ case\_sensitive\_\ ?\ s2\ ==\ string\_\ :}
\DoxyCodeLine{00935\ \ \ \ \ \ \ \ \ CaseInsensitiveStringEquals(s2,\ string\_);}
\DoxyCodeLine{00936\ \ \ \ \ \textcolor{keywordflow}{return}\ expect\_eq\_\ ==\ eq;}
\DoxyCodeLine{00937\ \ \ \}}
\DoxyCodeLine{00938\ }
\DoxyCodeLine{00939\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00940\ \ \ \ \ DescribeToHelper(expect\_eq\_,\ os);}
\DoxyCodeLine{00941\ \ \ \}}
\DoxyCodeLine{00942\ }
\DoxyCodeLine{00943\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00944\ \ \ \ \ DescribeToHelper(!expect\_eq\_,\ os);}
\DoxyCodeLine{00945\ \ \ \}}
\DoxyCodeLine{00946\ }
\DoxyCodeLine{00947\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00948\ \ \ \textcolor{keywordtype}{void}\ DescribeToHelper(\textcolor{keywordtype}{bool}\ expect\_eq,\ ::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00949\ \ \ \ \ *os\ <<\ (expect\_eq\ ?\ \textcolor{stringliteral}{"{}is\ "{}}\ :\ \textcolor{stringliteral}{"{}isn't\ "{}});}
\DoxyCodeLine{00950\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}equal\ to\ "{}};}
\DoxyCodeLine{00951\ \ \ \ \ \textcolor{keywordflow}{if}\ (!case\_sensitive\_)\ \{}
\DoxyCodeLine{00952\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}(ignoring\ case)\ "{}};}
\DoxyCodeLine{00953\ \ \ \ \ \}}
\DoxyCodeLine{00954\ \ \ \ \ UniversalPrint(string\_,\ os);}
\DoxyCodeLine{00955\ \ \ \}}
\DoxyCodeLine{00956\ }
\DoxyCodeLine{00957\ \ \ \textcolor{keyword}{const}\ StringType\ string\_;}
\DoxyCodeLine{00958\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ expect\_eq\_;}
\DoxyCodeLine{00959\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ case\_sensitive\_;}
\DoxyCodeLine{00960\ \};}
\DoxyCodeLine{00961\ }
\DoxyCodeLine{00962\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ HasSubstr(substring)\ matcher,\ which}}
\DoxyCodeLine{00963\ \textcolor{comment}{//\ can\ be\ used\ as\ a\ Matcher<T>\ as\ long\ as\ T\ can\ be\ converted\ to\ a}}
\DoxyCodeLine{00964\ \textcolor{comment}{//\ string.}}
\DoxyCodeLine{00965\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{00966\ \textcolor{keyword}{class\ }HasSubstrMatcher\ \{}
\DoxyCodeLine{00967\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00968\ \ \ \textcolor{keyword}{explicit}\ HasSubstrMatcher(\textcolor{keyword}{const}\ StringType\&\ substring)}
\DoxyCodeLine{00969\ \ \ \ \ \ \ :\ substring\_(substring)\ \{\}}
\DoxyCodeLine{00970\ }
\DoxyCodeLine{00971\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00972\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ internal::StringView\&\ s,}
\DoxyCodeLine{00973\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00974\ \ \ \ \ \textcolor{comment}{//\ This\ should\ fail\ to\ compile\ if\ StringView\ is\ used\ with\ wide}}
\DoxyCodeLine{00975\ \ \ \ \ \textcolor{comment}{//\ strings.}}
\DoxyCodeLine{00976\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ str\ =\ std::string(s);}
\DoxyCodeLine{00977\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(str,\ listener);}
\DoxyCodeLine{00978\ \ \ \}}
\DoxyCodeLine{00979\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00980\ }
\DoxyCodeLine{00981\ \ \ \textcolor{comment}{//\ Accepts\ pointer\ types,\ particularly:}}
\DoxyCodeLine{00982\ \ \ \textcolor{comment}{//\ \ \ const\ char*}}
\DoxyCodeLine{00983\ \ \ \textcolor{comment}{//\ \ \ char*}}
\DoxyCodeLine{00984\ \ \ \textcolor{comment}{//\ \ \ const\ wchar\_t*}}
\DoxyCodeLine{00985\ \ \ \textcolor{comment}{//\ \ \ wchar\_t*}}
\DoxyCodeLine{00986\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CharType>}
\DoxyCodeLine{00987\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(CharType*\ s,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00988\ \ \ \ \ \textcolor{keywordflow}{return}\ s\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ MatchAndExplain(StringType(s),\ listener);}
\DoxyCodeLine{00989\ \ \ \}}
\DoxyCodeLine{00990\ }
\DoxyCodeLine{00991\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ StringType.}}
\DoxyCodeLine{00992\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{00993\ \ \ \textcolor{comment}{//\ This\ is\ a\ template,\ not\ just\ a\ plain\ function\ with\ const\ StringType\&,}}
\DoxyCodeLine{00994\ \ \ \textcolor{comment}{//\ because\ StringView\ has\ some\ interfering\ non-\/explicit\ constructors.}}
\DoxyCodeLine{00995\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{00996\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{00997\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00998\ \ \ \ \ \textcolor{keywordflow}{return}\ StringType(s).find(substring\_)\ !=\ StringType::npos;}
\DoxyCodeLine{00999\ \ \ \}}
\DoxyCodeLine{01000\ }
\DoxyCodeLine{01001\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ matches.}}
\DoxyCodeLine{01002\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01003\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ substring\ "{}};}
\DoxyCodeLine{01004\ \ \ \ \ UniversalPrint(substring\_,\ os);}
\DoxyCodeLine{01005\ \ \ \}}
\DoxyCodeLine{01006\ }
\DoxyCodeLine{01007\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01008\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ no\ substring\ "{}};}
\DoxyCodeLine{01009\ \ \ \ \ UniversalPrint(substring\_,\ os);}
\DoxyCodeLine{01010\ \ \ \}}
\DoxyCodeLine{01011\ }
\DoxyCodeLine{01012\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01013\ \ \ \textcolor{keyword}{const}\ StringType\ substring\_;}
\DoxyCodeLine{01014\ \};}
\DoxyCodeLine{01015\ }
\DoxyCodeLine{01016\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ StartsWith(substring)\ matcher,\ which}}
\DoxyCodeLine{01017\ \textcolor{comment}{//\ can\ be\ used\ as\ a\ Matcher<T>\ as\ long\ as\ T\ can\ be\ converted\ to\ a}}
\DoxyCodeLine{01018\ \textcolor{comment}{//\ string.}}
\DoxyCodeLine{01019\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{01020\ \textcolor{keyword}{class\ }StartsWithMatcher\ \{}
\DoxyCodeLine{01021\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01022\ \ \ \textcolor{keyword}{explicit}\ StartsWithMatcher(\textcolor{keyword}{const}\ StringType\&\ prefix)\ :\ prefix\_(prefix)\ \{}
\DoxyCodeLine{01023\ \ \ \}}
\DoxyCodeLine{01024\ }
\DoxyCodeLine{01025\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01026\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ internal::StringView\&\ s,}
\DoxyCodeLine{01027\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01028\ \ \ \ \ \textcolor{comment}{//\ This\ should\ fail\ to\ compile\ if\ StringView\ is\ used\ with\ wide}}
\DoxyCodeLine{01029\ \ \ \ \ \textcolor{comment}{//\ strings.}}
\DoxyCodeLine{01030\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ str\ =\ std::string(s);}
\DoxyCodeLine{01031\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(str,\ listener);}
\DoxyCodeLine{01032\ \ \ \}}
\DoxyCodeLine{01033\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01034\ }
\DoxyCodeLine{01035\ \ \ \textcolor{comment}{//\ Accepts\ pointer\ types,\ particularly:}}
\DoxyCodeLine{01036\ \ \ \textcolor{comment}{//\ \ \ const\ char*}}
\DoxyCodeLine{01037\ \ \ \textcolor{comment}{//\ \ \ char*}}
\DoxyCodeLine{01038\ \ \ \textcolor{comment}{//\ \ \ const\ wchar\_t*}}
\DoxyCodeLine{01039\ \ \ \textcolor{comment}{//\ \ \ wchar\_t*}}
\DoxyCodeLine{01040\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CharType>}
\DoxyCodeLine{01041\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(CharType*\ s,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01042\ \ \ \ \ \textcolor{keywordflow}{return}\ s\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ MatchAndExplain(StringType(s),\ listener);}
\DoxyCodeLine{01043\ \ \ \}}
\DoxyCodeLine{01044\ }
\DoxyCodeLine{01045\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ StringType.}}
\DoxyCodeLine{01046\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01047\ \ \ \textcolor{comment}{//\ This\ is\ a\ template,\ not\ just\ a\ plain\ function\ with\ const\ StringType\&,}}
\DoxyCodeLine{01048\ \ \ \textcolor{comment}{//\ because\ StringView\ has\ some\ interfering\ non-\/explicit\ constructors.}}
\DoxyCodeLine{01049\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{01050\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{01051\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01052\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ s2(s);}
\DoxyCodeLine{01053\ \ \ \ \ \textcolor{keywordflow}{return}\ s2.length()\ >=\ prefix\_.length()\ \&\&}
\DoxyCodeLine{01054\ \ \ \ \ \ \ \ \ s2.substr(0,\ prefix\_.length())\ ==\ prefix\_;}
\DoxyCodeLine{01055\ \ \ \}}
\DoxyCodeLine{01056\ }
\DoxyCodeLine{01057\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01058\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}starts\ with\ "{}};}
\DoxyCodeLine{01059\ \ \ \ \ UniversalPrint(prefix\_,\ os);}
\DoxyCodeLine{01060\ \ \ \}}
\DoxyCodeLine{01061\ }
\DoxyCodeLine{01062\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01063\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ start\ with\ "{}};}
\DoxyCodeLine{01064\ \ \ \ \ UniversalPrint(prefix\_,\ os);}
\DoxyCodeLine{01065\ \ \ \}}
\DoxyCodeLine{01066\ }
\DoxyCodeLine{01067\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01068\ \ \ \textcolor{keyword}{const}\ StringType\ prefix\_;}
\DoxyCodeLine{01069\ \};}
\DoxyCodeLine{01070\ }
\DoxyCodeLine{01071\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ EndsWith(substring)\ matcher,\ which}}
\DoxyCodeLine{01072\ \textcolor{comment}{//\ can\ be\ used\ as\ a\ Matcher<T>\ as\ long\ as\ T\ can\ be\ converted\ to\ a}}
\DoxyCodeLine{01073\ \textcolor{comment}{//\ string.}}
\DoxyCodeLine{01074\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ StringType>}
\DoxyCodeLine{01075\ \textcolor{keyword}{class\ }EndsWithMatcher\ \{}
\DoxyCodeLine{01076\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01077\ \ \ \textcolor{keyword}{explicit}\ EndsWithMatcher(\textcolor{keyword}{const}\ StringType\&\ suffix)\ :\ suffix\_(suffix)\ \{\}}
\DoxyCodeLine{01078\ }
\DoxyCodeLine{01079\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01080\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ internal::StringView\&\ s,}
\DoxyCodeLine{01081\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01082\ \ \ \ \ \textcolor{comment}{//\ This\ should\ fail\ to\ compile\ if\ StringView\ is\ used\ with\ wide}}
\DoxyCodeLine{01083\ \ \ \ \ \textcolor{comment}{//\ strings.}}
\DoxyCodeLine{01084\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ str\ =\ std::string(s);}
\DoxyCodeLine{01085\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplain(str,\ listener);}
\DoxyCodeLine{01086\ \ \ \}}
\DoxyCodeLine{01087\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01088\ }
\DoxyCodeLine{01089\ \ \ \textcolor{comment}{//\ Accepts\ pointer\ types,\ particularly:}}
\DoxyCodeLine{01090\ \ \ \textcolor{comment}{//\ \ \ const\ char*}}
\DoxyCodeLine{01091\ \ \ \textcolor{comment}{//\ \ \ char*}}
\DoxyCodeLine{01092\ \ \ \textcolor{comment}{//\ \ \ const\ wchar\_t*}}
\DoxyCodeLine{01093\ \ \ \textcolor{comment}{//\ \ \ wchar\_t*}}
\DoxyCodeLine{01094\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ CharType>}
\DoxyCodeLine{01095\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(CharType*\ s,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01096\ \ \ \ \ \textcolor{keywordflow}{return}\ s\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ MatchAndExplain(StringType(s),\ listener);}
\DoxyCodeLine{01097\ \ \ \}}
\DoxyCodeLine{01098\ }
\DoxyCodeLine{01099\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ StringType.}}
\DoxyCodeLine{01100\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01101\ \ \ \textcolor{comment}{//\ This\ is\ a\ template,\ not\ just\ a\ plain\ function\ with\ const\ StringType\&,}}
\DoxyCodeLine{01102\ \ \ \textcolor{comment}{//\ because\ StringView\ has\ some\ interfering\ non-\/explicit\ constructors.}}
\DoxyCodeLine{01103\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{01104\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{01105\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01106\ \ \ \ \ \textcolor{keyword}{const}\ StringType\&\ s2(s);}
\DoxyCodeLine{01107\ \ \ \ \ \textcolor{keywordflow}{return}\ s2.length()\ >=\ suffix\_.length()\ \&\&}
\DoxyCodeLine{01108\ \ \ \ \ \ \ \ \ s2.substr(s2.length()\ -\/\ suffix\_.length())\ ==\ suffix\_;}
\DoxyCodeLine{01109\ \ \ \}}
\DoxyCodeLine{01110\ }
\DoxyCodeLine{01111\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01112\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}ends\ with\ "{}};}
\DoxyCodeLine{01113\ \ \ \ \ UniversalPrint(suffix\_,\ os);}
\DoxyCodeLine{01114\ \ \ \}}
\DoxyCodeLine{01115\ }
\DoxyCodeLine{01116\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01117\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ end\ with\ "{}};}
\DoxyCodeLine{01118\ \ \ \ \ UniversalPrint(suffix\_,\ os);}
\DoxyCodeLine{01119\ \ \ \}}
\DoxyCodeLine{01120\ }
\DoxyCodeLine{01121\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01122\ \ \ \textcolor{keyword}{const}\ StringType\ suffix\_;}
\DoxyCodeLine{01123\ \};}
\DoxyCodeLine{01124\ }
\DoxyCodeLine{01125\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ WhenBase64Unescaped(matcher)\ matcher,\ which\ can\ be}}
\DoxyCodeLine{01126\ \textcolor{comment}{//\ used\ as\ a\ Matcher<T>\ as\ long\ as\ T\ can\ be\ converted\ to\ a\ string.}}
\DoxyCodeLine{01127\ \textcolor{keyword}{class\ }WhenBase64UnescapedMatcher\ \{}
\DoxyCodeLine{01128\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01129\ \ \ \textcolor{keyword}{using\ }is\_gtest\_matcher\ =\ void;}
\DoxyCodeLine{01130\ }
\DoxyCodeLine{01131\ \ \ \textcolor{keyword}{explicit}\ WhenBase64UnescapedMatcher(}
\DoxyCodeLine{01132\ \ \ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\&\ internal\_matcher)}
\DoxyCodeLine{01133\ \ \ \ \ \ \ :\ internal\_matcher\_(internal\_matcher)\ \{\}}
\DoxyCodeLine{01134\ }
\DoxyCodeLine{01135\ \ \ \textcolor{comment}{//\ Matches\ anything\ that\ can\ convert\ to\ std::string.}}
\DoxyCodeLine{01136\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcheeStringType>}
\DoxyCodeLine{01137\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ MatcheeStringType\&\ s,}
\DoxyCodeLine{01138\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01139\ \ \ \ \ \textcolor{keyword}{const}\ std::string\ s2(s);\ \ \textcolor{comment}{//\ NOLINT\ (needed\ for\ working\ with\ string\_view).}}
\DoxyCodeLine{01140\ \ \ \ \ std::string\ unescaped;}
\DoxyCodeLine{01141\ \ \ \ \ \textcolor{keywordflow}{if}\ (!internal::Base64Unescape(s2,\ \&unescaped))\ \{}
\DoxyCodeLine{01142\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{01143\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}is\ not\ a\ valid\ base64\ escaped\ string"{}};}
\DoxyCodeLine{01144\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01145\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01146\ \ \ \ \ \}}
\DoxyCodeLine{01147\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(unescaped,\ internal\_matcher\_,\ listener);}
\DoxyCodeLine{01148\ \ \ \}}
\DoxyCodeLine{01149\ }
\DoxyCodeLine{01150\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01151\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}matches\ after\ Base64Unescape\ "{}};}
\DoxyCodeLine{01152\ \ \ \ \ internal\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{01153\ \ \ \}}
\DoxyCodeLine{01154\ }
\DoxyCodeLine{01155\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01156\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ match\ after\ Base64Unescape\ "{}};}
\DoxyCodeLine{01157\ \ \ \ \ internal\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{01158\ \ \ \}}
\DoxyCodeLine{01159\ }
\DoxyCodeLine{01160\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01161\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\ internal\_matcher\_;}
\DoxyCodeLine{01162\ \};}
\DoxyCodeLine{01163\ }
\DoxyCodeLine{01164\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ compares\ the\ two\ fields\ of\ a\ 2-\/tuple}}
\DoxyCodeLine{01165\ \textcolor{comment}{//\ using\ one\ of\ the\ ==,\ <=,\ <,\ etc,\ operators.\ \ The\ two\ fields\ being}}
\DoxyCodeLine{01166\ \textcolor{comment}{//\ compared\ don't\ have\ to\ have\ the\ same\ type.}}
\DoxyCodeLine{01167\ \textcolor{comment}{//}}
\DoxyCodeLine{01168\ \textcolor{comment}{//\ The\ matcher\ defined\ here\ is\ polymorphic\ (for\ example,\ Eq()\ can\ be}}
\DoxyCodeLine{01169\ \textcolor{comment}{//\ used\ to\ match\ a\ std::tuple<int,\ short>,\ a\ std::tuple<const\ long\&,\ double>,}}
\DoxyCodeLine{01170\ \textcolor{comment}{//\ etc).\ \ Therefore\ we\ use\ a\ template\ type\ conversion\ operator\ in\ the}}
\DoxyCodeLine{01171\ \textcolor{comment}{//\ implementation.}}
\DoxyCodeLine{01172\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ D,\ \textcolor{keyword}{typename}\ Op>}
\DoxyCodeLine{01173\ \textcolor{keyword}{class\ }PairMatchBase\ \{}
\DoxyCodeLine{01174\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01175\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{01176\ \ \ \textcolor{keyword}{operator}\ Matcher<::std::tuple<T1,\ T2>>()\ \textcolor{keyword}{const}\ \{}
\DoxyCodeLine{01177\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<::std::tuple<T1,\ T2>>(\textcolor{keyword}{new}\ Impl<const\ ::std::tuple<T1,\ T2>\&>);}
\DoxyCodeLine{01178\ \ \ \}}
\DoxyCodeLine{01179\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{01180\ \ \ \textcolor{keyword}{operator}\ Matcher<const\ ::std::tuple<T1,\ T2>\&>()\ \textcolor{keyword}{const}\ \{}
\DoxyCodeLine{01181\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ Impl<const\ ::std::tuple<T1,\ T2>\&>);}
\DoxyCodeLine{01182\ \ \ \}}
\DoxyCodeLine{01183\ }
\DoxyCodeLine{01184\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01185\ \ \ static\ ::std::ostream\&\ GetDesc(::std::ostream\&\ os)\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01186\ \ \ \ \ \textcolor{keywordflow}{return}\ os\ <<\ D::Desc();}
\DoxyCodeLine{01187\ \ \ \}}
\DoxyCodeLine{01188\ }
\DoxyCodeLine{01189\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple>}
\DoxyCodeLine{01190\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Tuple>\ \{}
\DoxyCodeLine{01191\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01192\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Tuple\ args,}
\DoxyCodeLine{01193\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01194\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ Op()(::std::get<0>(args),\ ::std::get<1>(args));}
\DoxyCodeLine{01195\ \ \ \ \ \}}
\DoxyCodeLine{01196\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01197\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ "{}}\ <<\ GetDesc;}
\DoxyCodeLine{01198\ \ \ \ \ \}}
\DoxyCodeLine{01199\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01200\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}aren't\ "{}}\ <<\ GetDesc;}
\DoxyCodeLine{01201\ \ \ \ \ \}}
\DoxyCodeLine{01202\ \ \ \};}
\DoxyCodeLine{01203\ \};}
\DoxyCodeLine{01204\ }
\DoxyCodeLine{01205\ \textcolor{keyword}{class\ }Eq2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Eq2Matcher,\ AnyEq>\ \{}
\DoxyCodeLine{01206\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01207\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}an\ equal\ pair"{}};\ \}}
\DoxyCodeLine{01208\ \};}
\DoxyCodeLine{01209\ \textcolor{keyword}{class\ }Ne2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Ne2Matcher,\ AnyNe>\ \{}
\DoxyCodeLine{01210\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01211\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}an\ unequal\ pair"{}};\ \}}
\DoxyCodeLine{01212\ \};}
\DoxyCodeLine{01213\ \textcolor{keyword}{class\ }Lt2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Lt2Matcher,\ AnyLt>\ \{}
\DoxyCodeLine{01214\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01215\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a\ pair\ where\ the\ first\ <\ the\ second"{}};\ \}}
\DoxyCodeLine{01216\ \};}
\DoxyCodeLine{01217\ \textcolor{keyword}{class\ }Gt2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Gt2Matcher,\ AnyGt>\ \{}
\DoxyCodeLine{01218\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01219\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a\ pair\ where\ the\ first\ >\ the\ second"{}};\ \}}
\DoxyCodeLine{01220\ \};}
\DoxyCodeLine{01221\ \textcolor{keyword}{class\ }Le2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Le2Matcher,\ AnyLe>\ \{}
\DoxyCodeLine{01222\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01223\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a\ pair\ where\ the\ first\ <=\ the\ second"{}};\ \}}
\DoxyCodeLine{01224\ \};}
\DoxyCodeLine{01225\ \textcolor{keyword}{class\ }Ge2Matcher\ :\ \textcolor{keyword}{public}\ PairMatchBase<Ge2Matcher,\ AnyGe>\ \{}
\DoxyCodeLine{01226\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01227\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ Desc()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a\ pair\ where\ the\ first\ >=\ the\ second"{}};\ \}}
\DoxyCodeLine{01228\ \};}
\DoxyCodeLine{01229\ }
\DoxyCodeLine{01230\ \textcolor{comment}{//\ Implements\ the\ Not(...)\ matcher\ for\ a\ particular\ argument\ type\ T.}}
\DoxyCodeLine{01231\ \textcolor{comment}{//\ We\ do\ not\ nest\ it\ inside\ the\ NotMatcher\ class\ template,\ as\ that}}
\DoxyCodeLine{01232\ \textcolor{comment}{//\ will\ prevent\ different\ instantiations\ of\ NotMatcher\ from\ sharing}}
\DoxyCodeLine{01233\ \textcolor{comment}{//\ the\ same\ NotMatcherImpl<T>\ class.}}
\DoxyCodeLine{01234\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01235\ \textcolor{keyword}{class\ }NotMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<const\ T\&>\ \{}
\DoxyCodeLine{01236\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01237\ \ \ \textcolor{keyword}{explicit}\ NotMatcherImpl(\textcolor{keyword}{const}\ Matcher<T>\&\ matcher)}
\DoxyCodeLine{01238\ \ \ \ \ \ \ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01239\ }
\DoxyCodeLine{01240\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ x,}
\DoxyCodeLine{01241\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01242\ \ \ \ \ \textcolor{keywordflow}{return}\ !matcher\_.MatchAndExplain(x,\ listener);}
\DoxyCodeLine{01243\ \ \ \}}
\DoxyCodeLine{01244\ }
\DoxyCodeLine{01245\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01246\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{01247\ \ \ \}}
\DoxyCodeLine{01248\ }
\DoxyCodeLine{01249\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01250\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{01251\ \ \ \}}
\DoxyCodeLine{01252\ }
\DoxyCodeLine{01253\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01254\ \ \ \textcolor{keyword}{const}\ Matcher<T>\ matcher\_;}
\DoxyCodeLine{01255\ \};}
\DoxyCodeLine{01256\ }
\DoxyCodeLine{01257\ \textcolor{comment}{//\ Implements\ the\ Not(m)\ matcher,\ which\ matches\ a\ value\ that\ doesn't}}
\DoxyCodeLine{01258\ \textcolor{comment}{//\ match\ matcher\ m.}}
\DoxyCodeLine{01259\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{01260\ \textcolor{keyword}{class\ }NotMatcher\ \{}
\DoxyCodeLine{01261\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01262\ \ \ \textcolor{keyword}{explicit}\ NotMatcher(InnerMatcher\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01263\ }
\DoxyCodeLine{01264\ \ \ \textcolor{comment}{//\ This\ template\ type\ conversion\ operator\ allows\ Not(m)\ to\ be\ used}}
\DoxyCodeLine{01265\ \ \ \textcolor{comment}{//\ to\ match\ any\ type\ m\ can\ match.}}
\DoxyCodeLine{01266\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01267\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01268\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(\textcolor{keyword}{new}\ NotMatcherImpl<T>(SafeMatcherCast<T>(matcher\_)));}
\DoxyCodeLine{01269\ \ \ \}}
\DoxyCodeLine{01270\ }
\DoxyCodeLine{01271\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01272\ \ \ InnerMatcher\ matcher\_;}
\DoxyCodeLine{01273\ \};}
\DoxyCodeLine{01274\ }
\DoxyCodeLine{01275\ \textcolor{comment}{//\ Implements\ the\ AllOf(m1,\ m2)\ matcher\ for\ a\ particular\ argument\ type}}
\DoxyCodeLine{01276\ \textcolor{comment}{//\ T.\ We\ do\ not\ nest\ it\ inside\ the\ BothOfMatcher\ class\ template,\ as}}
\DoxyCodeLine{01277\ \textcolor{comment}{//\ that\ will\ prevent\ different\ instantiations\ of\ BothOfMatcher\ from}}
\DoxyCodeLine{01278\ \textcolor{comment}{//\ sharing\ the\ same\ BothOfMatcherImpl<T>\ class.}}
\DoxyCodeLine{01279\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01280\ \textcolor{keyword}{class\ }AllOfMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<const\ T\&>\ \{}
\DoxyCodeLine{01281\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01282\ \ \ \textcolor{keyword}{explicit}\ AllOfMatcherImpl(std::vector<Matcher<T>\ >\ matchers)}
\DoxyCodeLine{01283\ \ \ \ \ \ \ :\ matchers\_(std::move(matchers))\ \{\}}
\DoxyCodeLine{01284\ }
\DoxyCodeLine{01285\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01286\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{01287\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01288\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0)\ *os\ <<\ \textcolor{stringliteral}{"{})\ and\ ("{}};}
\DoxyCodeLine{01289\ \ \ \ \ \ \ matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{01290\ \ \ \ \ \}}
\DoxyCodeLine{01291\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01292\ \ \ \}}
\DoxyCodeLine{01293\ }
\DoxyCodeLine{01294\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01295\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{01296\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01297\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0)\ *os\ <<\ \textcolor{stringliteral}{"{})\ or\ ("{}};}
\DoxyCodeLine{01298\ \ \ \ \ \ \ matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{01299\ \ \ \ \ \}}
\DoxyCodeLine{01300\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01301\ \ \ \}}
\DoxyCodeLine{01302\ }
\DoxyCodeLine{01303\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ x,}
\DoxyCodeLine{01304\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01305\ \ \ \ \ \textcolor{comment}{//\ If\ either\ matcher1\_\ or\ matcher2\_\ doesn't\ match\ x,\ we\ only\ need}}
\DoxyCodeLine{01306\ \ \ \ \ \textcolor{comment}{//\ to\ explain\ why\ one\ of\ them\ fails.}}
\DoxyCodeLine{01307\ \ \ \ \ std::string\ all\_match\_result;}
\DoxyCodeLine{01308\ }
\DoxyCodeLine{01309\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01310\ \ \ \ \ \ \ StringMatchResultListener\ slistener;}
\DoxyCodeLine{01311\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matchers\_[i].MatchAndExplain(x,\ \&slistener))\ \{}
\DoxyCodeLine{01312\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (all\_match\_result.empty())\ \{}
\DoxyCodeLine{01313\ \ \ \ \ \ \ \ \ \ \ all\_match\_result\ =\ slistener.str();}
\DoxyCodeLine{01314\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01315\ \ \ \ \ \ \ \ \ \ \ std::string\ result\ =\ slistener.str();}
\DoxyCodeLine{01316\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!result.empty())\ \{}
\DoxyCodeLine{01317\ \ \ \ \ \ \ \ \ \ \ \ \ all\_match\_result\ +=\ \textcolor{stringliteral}{"{},\ and\ "{}};}
\DoxyCodeLine{01318\ \ \ \ \ \ \ \ \ \ \ \ \ all\_match\_result\ +=\ result;}
\DoxyCodeLine{01319\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01320\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01321\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01322\ \ \ \ \ \ \ \ \ *listener\ <<\ slistener.str();}
\DoxyCodeLine{01323\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01324\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01325\ \ \ \ \ \}}
\DoxyCodeLine{01326\ }
\DoxyCodeLine{01327\ \ \ \ \ \textcolor{comment}{//\ Otherwise\ we\ need\ to\ explain\ why\ *both*\ of\ them\ match.}}
\DoxyCodeLine{01328\ \ \ \ \ *listener\ <<\ all\_match\_result;}
\DoxyCodeLine{01329\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01330\ \ \ \}}
\DoxyCodeLine{01331\ }
\DoxyCodeLine{01332\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01333\ \ \ \textcolor{keyword}{const}\ std::vector<Matcher<T>\ >\ matchers\_;}
\DoxyCodeLine{01334\ \};}
\DoxyCodeLine{01335\ }
\DoxyCodeLine{01336\ \textcolor{comment}{//\ VariadicMatcher\ is\ used\ for\ the\ variadic\ implementation\ of}}
\DoxyCodeLine{01337\ \textcolor{comment}{//\ AllOf(m\_1,\ m\_2,\ ...)\ and\ AnyOf(m\_1,\ m\_2,\ ...).}}
\DoxyCodeLine{01338\ \textcolor{comment}{//\ CombiningMatcher<T>\ is\ used\ to\ recursively\ combine\ the\ provided\ matchers}}
\DoxyCodeLine{01339\ \textcolor{comment}{//\ (of\ type\ Args...).}}
\DoxyCodeLine{01340\ \textcolor{keyword}{template}\ <\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{class\ }CombiningMatcher,\ \textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{01341\ \textcolor{keyword}{class\ }VariadicMatcher\ \{}
\DoxyCodeLine{01342\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01343\ \ \ VariadicMatcher(\textcolor{keyword}{const}\ Args\&...\ matchers)\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01344\ \ \ \ \ \ \ :\ matchers\_(matchers...)\ \{}
\DoxyCodeLine{01345\ \ \ \ \ \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}...(Args)\ >\ 0,\ \textcolor{stringliteral}{"{}Must\ have\ at\ least\ one\ matcher."{}});}
\DoxyCodeLine{01346\ \ \ \}}
\DoxyCodeLine{01347\ }
\DoxyCodeLine{01348\ \ \ VariadicMatcher(\textcolor{keyword}{const}\ VariadicMatcher\&)\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{01349\ \ \ VariadicMatcher\&\ operator=(\textcolor{keyword}{const}\ VariadicMatcher\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{01350\ }
\DoxyCodeLine{01351\ \ \ \textcolor{comment}{//\ This\ template\ type\ conversion\ operator\ allows\ an}}
\DoxyCodeLine{01352\ \ \ \textcolor{comment}{//\ VariadicMatcher<Matcher1,\ Matcher2...>\ object\ to\ match\ any\ type\ that}}
\DoxyCodeLine{01353\ \ \ \textcolor{comment}{//\ all\ of\ the\ provided\ matchers\ (Matcher1,\ Matcher2,\ ...)\ can\ match.}}
\DoxyCodeLine{01354\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01355\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01356\ \ \ \ \ std::vector<Matcher<T>\ >\ values;}
\DoxyCodeLine{01357\ \ \ \ \ CreateVariadicMatcher<T>(\&values,\ std::integral\_constant<size\_t,\ 0>());}
\DoxyCodeLine{01358\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(\textcolor{keyword}{new}\ CombiningMatcher<T>(std::move(values)));}
\DoxyCodeLine{01359\ \ \ \}}
\DoxyCodeLine{01360\ }
\DoxyCodeLine{01361\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01362\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ I>}
\DoxyCodeLine{01363\ \ \ \textcolor{keywordtype}{void}\ CreateVariadicMatcher(std::vector<Matcher<T>\ >*\ values,}
\DoxyCodeLine{01364\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::integral\_constant<size\_t,\ I>)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01365\ \ \ \ \ values-\/>push\_back(SafeMatcherCast<T>(std::get<I>(matchers\_)));}
\DoxyCodeLine{01366\ \ \ \ \ CreateVariadicMatcher<T>(values,\ std::integral\_constant<size\_t,\ I\ +\ 1>());}
\DoxyCodeLine{01367\ \ \ \}}
\DoxyCodeLine{01368\ }
\DoxyCodeLine{01369\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01370\ \ \ \textcolor{keywordtype}{void}\ CreateVariadicMatcher(}
\DoxyCodeLine{01371\ \ \ \ \ \ \ std::vector<Matcher<T>\ >*,}
\DoxyCodeLine{01372\ \ \ \ \ \ \ std::integral\_constant<\textcolor{keywordtype}{size\_t},\ \textcolor{keyword}{sizeof}...(Args)>)\textcolor{keyword}{\ const\ }\{\}}
\DoxyCodeLine{01373\ }
\DoxyCodeLine{01374\ \ \ std::tuple<Args...>\ matchers\_;}
\DoxyCodeLine{01375\ \};}
\DoxyCodeLine{01376\ }
\DoxyCodeLine{01377\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{01378\ \textcolor{keyword}{using\ }AllOfMatcher\ =\ VariadicMatcher<AllOfMatcherImpl,\ Args...>;}
\DoxyCodeLine{01379\ }
\DoxyCodeLine{01380\ \textcolor{comment}{//\ Implements\ the\ AnyOf(m1,\ m2)\ matcher\ for\ a\ particular\ argument\ type}}
\DoxyCodeLine{01381\ \textcolor{comment}{//\ T.\ \ We\ do\ not\ nest\ it\ inside\ the\ AnyOfMatcher\ class\ template,\ as}}
\DoxyCodeLine{01382\ \textcolor{comment}{//\ that\ will\ prevent\ different\ instantiations\ of\ AnyOfMatcher\ from}}
\DoxyCodeLine{01383\ \textcolor{comment}{//\ sharing\ the\ same\ EitherOfMatcherImpl<T>\ class.}}
\DoxyCodeLine{01384\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01385\ \textcolor{keyword}{class\ }AnyOfMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<const\ T\&>\ \{}
\DoxyCodeLine{01386\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01387\ \ \ \textcolor{keyword}{explicit}\ AnyOfMatcherImpl(std::vector<Matcher<T>\ >\ matchers)}
\DoxyCodeLine{01388\ \ \ \ \ \ \ :\ matchers\_(std::move(matchers))\ \{\}}
\DoxyCodeLine{01389\ }
\DoxyCodeLine{01390\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01391\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{01392\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01393\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0)\ *os\ <<\ \textcolor{stringliteral}{"{})\ or\ ("{}};}
\DoxyCodeLine{01394\ \ \ \ \ \ \ matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{01395\ \ \ \ \ \}}
\DoxyCodeLine{01396\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01397\ \ \ \}}
\DoxyCodeLine{01398\ }
\DoxyCodeLine{01399\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01400\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{01401\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01402\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0)\ *os\ <<\ \textcolor{stringliteral}{"{})\ and\ ("{}};}
\DoxyCodeLine{01403\ \ \ \ \ \ \ matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{01404\ \ \ \ \ \}}
\DoxyCodeLine{01405\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01406\ \ \ \}}
\DoxyCodeLine{01407\ }
\DoxyCodeLine{01408\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ x,}
\DoxyCodeLine{01409\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01410\ \ \ \ \ std::string\ no\_match\_result;}
\DoxyCodeLine{01411\ }
\DoxyCodeLine{01412\ \ \ \ \ \textcolor{comment}{//\ If\ either\ matcher1\_\ or\ matcher2\_\ matches\ x,\ we\ just\ need\ to}}
\DoxyCodeLine{01413\ \ \ \ \ \textcolor{comment}{//\ explain\ why\ *one*\ of\ them\ matches.}}
\DoxyCodeLine{01414\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matchers\_.size();\ ++i)\ \{}
\DoxyCodeLine{01415\ \ \ \ \ \ \ StringMatchResultListener\ slistener;}
\DoxyCodeLine{01416\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matchers\_[i].MatchAndExplain(x,\ \&slistener))\ \{}
\DoxyCodeLine{01417\ \ \ \ \ \ \ \ \ *listener\ <<\ slistener.str();}
\DoxyCodeLine{01418\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01419\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01420\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (no\_match\_result.empty())\ \{}
\DoxyCodeLine{01421\ \ \ \ \ \ \ \ \ \ \ no\_match\_result\ =\ slistener.str();}
\DoxyCodeLine{01422\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01423\ \ \ \ \ \ \ \ \ \ \ std::string\ result\ =\ slistener.str();}
\DoxyCodeLine{01424\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!result.empty())\ \{}
\DoxyCodeLine{01425\ \ \ \ \ \ \ \ \ \ \ \ \ no\_match\_result\ +=\ \textcolor{stringliteral}{"{},\ and\ "{}};}
\DoxyCodeLine{01426\ \ \ \ \ \ \ \ \ \ \ \ \ no\_match\_result\ +=\ result;}
\DoxyCodeLine{01427\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01428\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01429\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01430\ \ \ \ \ \}}
\DoxyCodeLine{01431\ }
\DoxyCodeLine{01432\ \ \ \ \ \textcolor{comment}{//\ Otherwise\ we\ need\ to\ explain\ why\ *both*\ of\ them\ fail.}}
\DoxyCodeLine{01433\ \ \ \ \ *listener\ <<\ no\_match\_result;}
\DoxyCodeLine{01434\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01435\ \ \ \}}
\DoxyCodeLine{01436\ }
\DoxyCodeLine{01437\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01438\ \ \ \textcolor{keyword}{const}\ std::vector<Matcher<T>\ >\ matchers\_;}
\DoxyCodeLine{01439\ \};}
\DoxyCodeLine{01440\ }
\DoxyCodeLine{01441\ \textcolor{comment}{//\ AnyOfMatcher\ is\ used\ for\ the\ variadic\ implementation\ of\ AnyOf(m\_1,\ m\_2,\ ...).}}
\DoxyCodeLine{01442\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{01443\ \textcolor{keyword}{using\ }AnyOfMatcher\ =\ VariadicMatcher<AnyOfMatcherImpl,\ Args...>;}
\DoxyCodeLine{01444\ }
\DoxyCodeLine{01445\ \textcolor{comment}{//\ ConditionalMatcher\ is\ the\ implementation\ of\ Conditional(cond,\ m1,\ m2)}}
\DoxyCodeLine{01446\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTrue,\ \textcolor{keyword}{typename}\ MatcherFalse>}
\DoxyCodeLine{01447\ \textcolor{keyword}{class\ }ConditionalMatcher\ \{}
\DoxyCodeLine{01448\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01449\ \ \ ConditionalMatcher(\textcolor{keywordtype}{bool}\ condition,\ MatcherTrue\ matcher\_true,}
\DoxyCodeLine{01450\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatcherFalse\ matcher\_false)}
\DoxyCodeLine{01451\ \ \ \ \ \ \ :\ condition\_(condition),}
\DoxyCodeLine{01452\ \ \ \ \ \ \ \ \ matcher\_true\_(std::move(matcher\_true)),}
\DoxyCodeLine{01453\ \ \ \ \ \ \ \ \ matcher\_false\_(std::move(matcher\_false))\ \{\}}
\DoxyCodeLine{01454\ }
\DoxyCodeLine{01455\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01456\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT(runtime/explicit)}}
\DoxyCodeLine{01457\ \ \ \ \ \textcolor{keywordflow}{return}\ condition\_\ ?\ SafeMatcherCast<T>(matcher\_true\_)}
\DoxyCodeLine{01458\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ SafeMatcherCast<T>(matcher\_false\_);}
\DoxyCodeLine{01459\ \ \ \}}
\DoxyCodeLine{01460\ }
\DoxyCodeLine{01461\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01462\ \ \ \textcolor{keywordtype}{bool}\ condition\_;}
\DoxyCodeLine{01463\ \ \ MatcherTrue\ matcher\_true\_;}
\DoxyCodeLine{01464\ \ \ MatcherFalse\ matcher\_false\_;}
\DoxyCodeLine{01465\ }
\DoxyCodeLine{01466\ \ \ GTEST\_DISALLOW\_ASSIGN\_(ConditionalMatcher);}
\DoxyCodeLine{01467\ \};}
\DoxyCodeLine{01468\ }
\DoxyCodeLine{01469\ \textcolor{comment}{//\ Wrapper\ for\ implementation\ of\ Any/AllOfArray().}}
\DoxyCodeLine{01470\ \textcolor{keyword}{template}\ <\textcolor{keyword}{template}\ <\textcolor{keyword}{class}>\ \textcolor{keyword}{class\ }MatcherImpl,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01471\ \textcolor{keyword}{class\ }SomeOfArrayMatcher\ \{}
\DoxyCodeLine{01472\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01473\ \ \ \textcolor{comment}{//\ Constructs\ the\ matcher\ from\ a\ sequence\ of\ element\ values\ or}}
\DoxyCodeLine{01474\ \ \ \textcolor{comment}{//\ element\ matchers.}}
\DoxyCodeLine{01475\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{01476\ \ \ SomeOfArrayMatcher(Iter\ first,\ Iter\ last)\ :\ matchers\_(first,\ last)\ \{\}}
\DoxyCodeLine{01477\ }
\DoxyCodeLine{01478\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{01479\ \ \ \textcolor{keyword}{operator}\ Matcher<U>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01480\ \ \ \ \ \textcolor{keyword}{using\ }RawU\ =\ \textcolor{keyword}{typename}\ std::decay<U>::type;}
\DoxyCodeLine{01481\ \ \ \ \ std::vector<Matcher<RawU>>\ matchers;}
\DoxyCodeLine{01482\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ matcher\ :\ matchers\_)\ \{}
\DoxyCodeLine{01483\ \ \ \ \ \ \ matchers.push\_back(MatcherCast<RawU>(matcher));}
\DoxyCodeLine{01484\ \ \ \ \ \}}
\DoxyCodeLine{01485\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<U>(\textcolor{keyword}{new}\ MatcherImpl<RawU>(std::move(matchers)));}
\DoxyCodeLine{01486\ \ \ \}}
\DoxyCodeLine{01487\ }
\DoxyCodeLine{01488\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01489\ \ \ const\ ::std::vector<T>\ matchers\_;}
\DoxyCodeLine{01490\ \};}
\DoxyCodeLine{01491\ }
\DoxyCodeLine{01492\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01493\ \textcolor{keyword}{using\ }AllOfArrayMatcher\ =\ SomeOfArrayMatcher<AllOfMatcherImpl,\ T>;}
\DoxyCodeLine{01494\ }
\DoxyCodeLine{01495\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01496\ \textcolor{keyword}{using\ }AnyOfArrayMatcher\ =\ SomeOfArrayMatcher<AnyOfMatcherImpl,\ T>;}
\DoxyCodeLine{01497\ }
\DoxyCodeLine{01498\ \textcolor{comment}{//\ Used\ for\ implementing\ Truly(pred),\ which\ turns\ a\ predicate\ into\ a}}
\DoxyCodeLine{01499\ \textcolor{comment}{//\ matcher.}}
\DoxyCodeLine{01500\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Predicate>}
\DoxyCodeLine{01501\ \textcolor{keyword}{class\ }TrulyMatcher\ \{}
\DoxyCodeLine{01502\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01503\ \ \ \textcolor{keyword}{explicit}\ TrulyMatcher(Predicate\ pred)\ :\ predicate\_(pred)\ \{\}}
\DoxyCodeLine{01504\ }
\DoxyCodeLine{01505\ \ \ \textcolor{comment}{//\ This\ method\ template\ allows\ Truly(pred)\ to\ be\ used\ as\ a\ matcher}}
\DoxyCodeLine{01506\ \ \ \textcolor{comment}{//\ for\ type\ T\ where\ T\ is\ the\ argument\ type\ of\ predicate\ 'pred'.\ \ The}}
\DoxyCodeLine{01507\ \ \ \textcolor{comment}{//\ argument\ is\ passed\ by\ reference\ as\ the\ predicate\ may\ be}}
\DoxyCodeLine{01508\ \ \ \textcolor{comment}{//\ interested\ in\ the\ address\ of\ the\ argument.}}
\DoxyCodeLine{01509\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01510\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\&\ x,\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01511\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01512\ \ \ \ \ \textcolor{comment}{//\ Without\ the\ if-\/statement,\ MSVC\ sometimes\ warns\ about\ converting}}
\DoxyCodeLine{01513\ \ \ \ \ \textcolor{comment}{//\ a\ value\ to\ bool\ (warning\ 4800).}}
\DoxyCodeLine{01514\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01515\ \ \ \ \ \textcolor{comment}{//\ We\ cannot\ write\ 'return\ !!predicate\_(x);'\ as\ that\ doesn't\ work}}
\DoxyCodeLine{01516\ \ \ \ \ \textcolor{comment}{//\ when\ predicate\_(x)\ returns\ a\ class\ convertible\ to\ bool\ but}}
\DoxyCodeLine{01517\ \ \ \ \ \textcolor{comment}{//\ having\ no\ operator!().}}
\DoxyCodeLine{01518\ \ \ \ \ \textcolor{keywordflow}{if}\ (predicate\_(x))}
\DoxyCodeLine{01519\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01520\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}didn't\ satisfy\ the\ given\ predicate"{}};}
\DoxyCodeLine{01521\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01522\ \ \ \}}
\DoxyCodeLine{01523\ }
\DoxyCodeLine{01524\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01525\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}satisfies\ the\ given\ predicate"{}};}
\DoxyCodeLine{01526\ \ \ \}}
\DoxyCodeLine{01527\ }
\DoxyCodeLine{01528\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01529\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ satisfy\ the\ given\ predicate"{}};}
\DoxyCodeLine{01530\ \ \ \}}
\DoxyCodeLine{01531\ }
\DoxyCodeLine{01532\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01533\ \ \ Predicate\ predicate\_;}
\DoxyCodeLine{01534\ \};}
\DoxyCodeLine{01535\ }
\DoxyCodeLine{01536\ \textcolor{comment}{//\ Used\ for\ implementing\ Matches(matcher),\ which\ turns\ a\ matcher\ into}}
\DoxyCodeLine{01537\ \textcolor{comment}{//\ a\ predicate.}}
\DoxyCodeLine{01538\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{01539\ \textcolor{keyword}{class\ }MatcherAsPredicate\ \{}
\DoxyCodeLine{01540\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01541\ \ \ \textcolor{keyword}{explicit}\ MatcherAsPredicate(M\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01542\ }
\DoxyCodeLine{01543\ \ \ \textcolor{comment}{//\ This\ template\ operator()\ allows\ Matches(m)\ to\ be\ used\ as\ a}}
\DoxyCodeLine{01544\ \ \ \textcolor{comment}{//\ predicate\ on\ type\ T\ where\ m\ is\ a\ matcher\ on\ type\ T.}}
\DoxyCodeLine{01545\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01546\ \ \ \textcolor{comment}{//\ The\ argument\ x\ is\ passed\ by\ reference\ instead\ of\ by\ value,\ as}}
\DoxyCodeLine{01547\ \ \ \textcolor{comment}{//\ some\ matcher\ may\ be\ interested\ in\ its\ address\ (e.g.\ as\ in}}
\DoxyCodeLine{01548\ \ \ \textcolor{comment}{//\ Matches(Ref(n))(x)).}}
\DoxyCodeLine{01549\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01550\ \ \ \textcolor{keywordtype}{bool}\ operator()(\textcolor{keyword}{const}\ T\&\ x)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01551\ \ \ \ \ \textcolor{comment}{//\ We\ let\ matcher\_\ commit\ to\ a\ particular\ type\ here\ instead\ of}}
\DoxyCodeLine{01552\ \ \ \ \ \textcolor{comment}{//\ when\ the\ MatcherAsPredicate\ object\ was\ constructed.\ \ This}}
\DoxyCodeLine{01553\ \ \ \ \ \textcolor{comment}{//\ allows\ us\ to\ write\ Matches(m)\ where\ m\ is\ a\ polymorphic\ matcher}}
\DoxyCodeLine{01554\ \ \ \ \ \textcolor{comment}{//\ (e.g.\ Eq(5)).}}
\DoxyCodeLine{01555\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01556\ \ \ \ \ \textcolor{comment}{//\ If\ we\ write\ Matcher<T>(matcher\_).Matches(x)\ here,\ it\ won't}}
\DoxyCodeLine{01557\ \ \ \ \ \textcolor{comment}{//\ compile\ when\ matcher\_\ has\ type\ Matcher<const\ T\&>;\ if\ we\ write}}
\DoxyCodeLine{01558\ \ \ \ \ \textcolor{comment}{//\ Matcher<const\ T\&>(matcher\_).Matches(x)\ here,\ it\ won't\ compile}}
\DoxyCodeLine{01559\ \ \ \ \ \textcolor{comment}{//\ when\ matcher\_\ has\ type\ Matcher<T>;\ if\ we\ just\ write}}
\DoxyCodeLine{01560\ \ \ \ \ \textcolor{comment}{//\ matcher\_.Matches(x),\ it\ won't\ compile\ when\ matcher\_\ is}}
\DoxyCodeLine{01561\ \ \ \ \ \textcolor{comment}{//\ polymorphic,\ e.g.\ Eq(5).}}
\DoxyCodeLine{01562\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01563\ \ \ \ \ \textcolor{comment}{//\ MatcherCast<const\ T\&>()\ is\ necessary\ for\ making\ the\ code\ work}}
\DoxyCodeLine{01564\ \ \ \ \ \textcolor{comment}{//\ in\ all\ of\ the\ above\ situations.}}
\DoxyCodeLine{01565\ \ \ \ \ \textcolor{keywordflow}{return}\ MatcherCast<const\ T\&>(matcher\_).Matches(x);}
\DoxyCodeLine{01566\ \ \ \}}
\DoxyCodeLine{01567\ }
\DoxyCodeLine{01568\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01569\ \ \ M\ matcher\_;}
\DoxyCodeLine{01570\ \};}
\DoxyCodeLine{01571\ }
\DoxyCodeLine{01572\ \textcolor{comment}{//\ For\ implementing\ ASSERT\_THAT()\ and\ EXPECT\_THAT().\ \ The\ template}}
\DoxyCodeLine{01573\ \textcolor{comment}{//\ argument\ M\ must\ be\ a\ type\ that\ can\ be\ converted\ to\ a\ matcher.}}
\DoxyCodeLine{01574\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{01575\ \textcolor{keyword}{class\ }PredicateFormatterFromMatcher\ \{}
\DoxyCodeLine{01576\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01577\ \ \ \textcolor{keyword}{explicit}\ PredicateFormatterFromMatcher(M\ m)\ :\ matcher\_(std::move(m))\ \{\}}
\DoxyCodeLine{01578\ }
\DoxyCodeLine{01579\ \ \ \textcolor{comment}{//\ This\ template\ ()\ operator\ allows\ a\ PredicateFormatterFromMatcher}}
\DoxyCodeLine{01580\ \ \ \textcolor{comment}{//\ object\ to\ act\ as\ a\ predicate-\/formatter\ suitable\ for\ using\ with}}
\DoxyCodeLine{01581\ \ \ \textcolor{comment}{//\ Google\ Test's\ EXPECT\_PRED\_FORMAT1()\ macro.}}
\DoxyCodeLine{01582\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01583\ \ \ AssertionResult\ operator()(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ value\_text,\ \textcolor{keyword}{const}\ T\&\ x)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01584\ \ \ \ \ \textcolor{comment}{//\ We\ convert\ matcher\_\ to\ a\ Matcher<const\ T\&>\ *now*\ instead\ of}}
\DoxyCodeLine{01585\ \ \ \ \ \textcolor{comment}{//\ when\ the\ PredicateFormatterFromMatcher\ object\ was\ constructed,}}
\DoxyCodeLine{01586\ \ \ \ \ \textcolor{comment}{//\ as\ matcher\_\ may\ be\ polymorphic\ (e.g.\ NotNull())\ and\ we\ won't}}
\DoxyCodeLine{01587\ \ \ \ \ \textcolor{comment}{//\ know\ which\ type\ to\ instantiate\ it\ to\ until\ we\ actually\ see\ the}}
\DoxyCodeLine{01588\ \ \ \ \ \textcolor{comment}{//\ type\ of\ x\ here.}}
\DoxyCodeLine{01589\ \ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01590\ \ \ \ \ \textcolor{comment}{//\ We\ write\ SafeMatcherCast<const\ T\&>(matcher\_)\ instead\ of}}
\DoxyCodeLine{01591\ \ \ \ \ \textcolor{comment}{//\ Matcher<const\ T\&>(matcher\_),\ as\ the\ latter\ won't\ compile\ when}}
\DoxyCodeLine{01592\ \ \ \ \ \textcolor{comment}{//\ matcher\_\ has\ type\ Matcher<T>\ (e.g.\ An<int>()).}}
\DoxyCodeLine{01593\ \ \ \ \ \textcolor{comment}{//\ We\ don't\ write\ MatcherCast<const\ T\&>\ either,\ as\ that\ allows}}
\DoxyCodeLine{01594\ \ \ \ \ \textcolor{comment}{//\ potentially\ unsafe\ downcasting\ of\ the\ matcher\ argument.}}
\DoxyCodeLine{01595\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ T\&>\ matcher\ =\ SafeMatcherCast<const\ T\&>(matcher\_);}
\DoxyCodeLine{01596\ }
\DoxyCodeLine{01597\ \ \ \ \ \textcolor{comment}{//\ The\ expected\ path\ here\ is\ that\ the\ matcher\ should\ match\ (i.e.\ that\ most}}
\DoxyCodeLine{01598\ \ \ \ \ \textcolor{comment}{//\ tests\ pass)\ so\ optimize\ for\ this\ case.}}
\DoxyCodeLine{01599\ \ \ \ \ \textcolor{keywordflow}{if}\ (matcher.Matches(x))\ \{}
\DoxyCodeLine{01600\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ AssertionSuccess();}
\DoxyCodeLine{01601\ \ \ \ \ \}}
\DoxyCodeLine{01602\ }
\DoxyCodeLine{01603\ \ \ \ \ ::std::stringstream\ ss;}
\DoxyCodeLine{01604\ \ \ \ \ ss\ <<\ \textcolor{stringliteral}{"{}Value\ of:\ "{}}\ <<\ value\_text\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{01605\ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}Expected:\ "{}};}
\DoxyCodeLine{01606\ \ \ \ \ matcher.DescribeTo(\&ss);}
\DoxyCodeLine{01607\ }
\DoxyCodeLine{01608\ \ \ \ \ \textcolor{comment}{//\ Rerun\ the\ matcher\ to\ "{}PrintAndExplain"{}\ the\ failure.}}
\DoxyCodeLine{01609\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{01610\ \ \ \ \ \textcolor{keywordflow}{if}\ (MatchPrintAndExplain(x,\ matcher,\ \&listener))\ \{}
\DoxyCodeLine{01611\ \ \ \ \ \ \ ss\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\ \ The\ matcher\ failed\ on\ the\ initial\ attempt;\ but\ passed\ when\ "{}}}
\DoxyCodeLine{01612\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}rerun\ to\ generate\ the\ explanation."{}};}
\DoxyCodeLine{01613\ \ \ \ \ \}}
\DoxyCodeLine{01614\ \ \ \ \ ss\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n\ \ Actual:\ "{}}\ <<\ listener.str();}
\DoxyCodeLine{01615\ \ \ \ \ \textcolor{keywordflow}{return}\ AssertionFailure()\ <<\ ss.str();}
\DoxyCodeLine{01616\ \ \ \}}
\DoxyCodeLine{01617\ }
\DoxyCodeLine{01618\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01619\ \ \ \textcolor{keyword}{const}\ M\ matcher\_;}
\DoxyCodeLine{01620\ \};}
\DoxyCodeLine{01621\ }
\DoxyCodeLine{01622\ \textcolor{comment}{//\ A\ helper\ function\ for\ converting\ a\ matcher\ to\ a\ predicate-\/formatter}}
\DoxyCodeLine{01623\ \textcolor{comment}{//\ without\ the\ user\ needing\ to\ explicitly\ write\ the\ type.\ \ This\ is}}
\DoxyCodeLine{01624\ \textcolor{comment}{//\ used\ for\ implementing\ ASSERT\_THAT()\ and\ EXPECT\_THAT().}}
\DoxyCodeLine{01625\ \textcolor{comment}{//\ Implementation\ detail:\ 'matcher'\ is\ received\ by-\/value\ to\ force\ decaying.}}
\DoxyCodeLine{01626\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{01627\ \textcolor{keyword}{inline}\ PredicateFormatterFromMatcher<M>}
\DoxyCodeLine{01628\ MakePredicateFormatterFromMatcher(M\ matcher)\ \{}
\DoxyCodeLine{01629\ \ \ \textcolor{keywordflow}{return}\ PredicateFormatterFromMatcher<M>(std::move(matcher));}
\DoxyCodeLine{01630\ \}}
\DoxyCodeLine{01631\ }
\DoxyCodeLine{01632\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ IsNan()\ matcher,\ which\ matches\ any\ floating\ type}}
\DoxyCodeLine{01633\ \textcolor{comment}{//\ value\ that\ is\ Nan.}}
\DoxyCodeLine{01634\ \textcolor{keyword}{class\ }IsNanMatcher\ \{}
\DoxyCodeLine{01635\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01636\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FloatType>}
\DoxyCodeLine{01637\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ FloatType\&\ f,}
\DoxyCodeLine{01638\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01639\ \ \ \ \ \textcolor{keywordflow}{return}\ (::std::isnan)(f);}
\DoxyCodeLine{01640\ \ \ \}}
\DoxyCodeLine{01641\ }
\DoxyCodeLine{01642\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ NaN"{}};\ \}}
\DoxyCodeLine{01643\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01644\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ NaN"{}};}
\DoxyCodeLine{01645\ \ \ \}}
\DoxyCodeLine{01646\ \};}
\DoxyCodeLine{01647\ }
\DoxyCodeLine{01648\ \textcolor{comment}{//\ Implements\ the\ polymorphic\ floating\ point\ equality\ matcher,\ which\ matches}}
\DoxyCodeLine{01649\ \textcolor{comment}{//\ two\ float\ values\ using\ ULP-\/based\ approximation\ or,\ optionally,\ a}}
\DoxyCodeLine{01650\ \textcolor{comment}{//\ user-\/specified\ epsilon.\ \ The\ template\ is\ meant\ to\ be\ instantiated\ with}}
\DoxyCodeLine{01651\ \textcolor{comment}{//\ FloatType\ being\ either\ float\ or\ double.}}
\DoxyCodeLine{01652\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FloatType>}
\DoxyCodeLine{01653\ \textcolor{keyword}{class\ }FloatingEqMatcher\ \{}
\DoxyCodeLine{01654\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01655\ \ \ \textcolor{comment}{//\ Constructor\ for\ FloatingEqMatcher.}}
\DoxyCodeLine{01656\ \ \ \textcolor{comment}{//\ The\ matcher's\ input\ will\ be\ compared\ with\ expected.\ \ The\ matcher\ treats\ two}}
\DoxyCodeLine{01657\ \ \ \textcolor{comment}{//\ NANs\ as\ equal\ if\ nan\_eq\_nan\ is\ true.\ \ Otherwise,\ under\ IEEE\ standards,}}
\DoxyCodeLine{01658\ \ \ \textcolor{comment}{//\ equality\ comparisons\ between\ NANs\ will\ always\ return\ false.\ \ We\ specify\ a}}
\DoxyCodeLine{01659\ \ \ \textcolor{comment}{//\ negative\ max\_abs\_error\_\ term\ to\ indicate\ that\ ULP-\/based\ approximation\ will}}
\DoxyCodeLine{01660\ \ \ \textcolor{comment}{//\ be\ used\ for\ comparison.}}
\DoxyCodeLine{01661\ \ \ FloatingEqMatcher(FloatType\ expected,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan)\ :}
\DoxyCodeLine{01662\ \ \ \ \ expected\_(expected),\ nan\_eq\_nan\_(nan\_eq\_nan),\ max\_abs\_error\_(-\/1)\ \{}
\DoxyCodeLine{01663\ \ \ \}}
\DoxyCodeLine{01664\ }
\DoxyCodeLine{01665\ \ \ \textcolor{comment}{//\ Constructor\ that\ supports\ a\ user-\/specified\ max\_abs\_error\ that\ will\ be\ used}}
\DoxyCodeLine{01666\ \ \ \textcolor{comment}{//\ for\ comparison\ instead\ of\ ULP-\/based\ approximation.\ \ The\ max\ absolute}}
\DoxyCodeLine{01667\ \ \ \textcolor{comment}{//\ should\ be\ non-\/negative.}}
\DoxyCodeLine{01668\ \ \ FloatingEqMatcher(FloatType\ expected,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan,}
\DoxyCodeLine{01669\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FloatType\ max\_abs\_error)}
\DoxyCodeLine{01670\ \ \ \ \ \ \ :\ expected\_(expected),}
\DoxyCodeLine{01671\ \ \ \ \ \ \ \ \ nan\_eq\_nan\_(nan\_eq\_nan),}
\DoxyCodeLine{01672\ \ \ \ \ \ \ \ \ max\_abs\_error\_(max\_abs\_error)\ \{}
\DoxyCodeLine{01673\ \ \ \ \ GTEST\_CHECK\_(max\_abs\_error\ >=\ 0)}
\DoxyCodeLine{01674\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{},\ where\ max\_abs\_error\ is"{}}\ <<\ max\_abs\_error;}
\DoxyCodeLine{01675\ \ \ \}}
\DoxyCodeLine{01676\ }
\DoxyCodeLine{01677\ \ \ \textcolor{comment}{//\ Implements\ floating\ point\ equality\ matcher\ as\ a\ Matcher<T>.}}
\DoxyCodeLine{01678\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{01679\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<T>\ \{}
\DoxyCodeLine{01680\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01681\ \ \ \ \ Impl(FloatType\ expected,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan,\ FloatType\ max\_abs\_error)}
\DoxyCodeLine{01682\ \ \ \ \ \ \ \ \ :\ expected\_(expected),}
\DoxyCodeLine{01683\ \ \ \ \ \ \ \ \ \ \ nan\_eq\_nan\_(nan\_eq\_nan),}
\DoxyCodeLine{01684\ \ \ \ \ \ \ \ \ \ \ max\_abs\_error\_(max\_abs\_error)\ \{\}}
\DoxyCodeLine{01685\ }
\DoxyCodeLine{01686\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\ value,}
\DoxyCodeLine{01687\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01688\ \ \ \ \ \ \ \textcolor{keyword}{const}\ FloatingPoint<FloatType>\ actual(value),\ expected(expected\_);}
\DoxyCodeLine{01689\ }
\DoxyCodeLine{01690\ \ \ \ \ \ \ \textcolor{comment}{//\ Compares\ NaNs\ first,\ if\ nan\_eq\_nan\_\ is\ true.}}
\DoxyCodeLine{01691\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (actual.is\_nan()\ ||\ expected.is\_nan())\ \{}
\DoxyCodeLine{01692\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (actual.is\_nan()\ \&\&\ expected.is\_nan())\ \{}
\DoxyCodeLine{01693\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01694\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01695\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ One\ is\ nan;\ the\ other\ is\ not\ nan.}}
\DoxyCodeLine{01696\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01697\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01698\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (HasMaxAbsError())\ \{}
\DoxyCodeLine{01699\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ perform\ an\ equality\ check\ so\ that\ inf\ will\ match\ inf,\ regardless}}
\DoxyCodeLine{01700\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ of\ error\ bounds.\ \ If\ the\ result\ of\ value\ -\/\ expected\_\ would\ result\ in}}
\DoxyCodeLine{01701\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ overflow\ or\ if\ either\ value\ is\ inf,\ the\ default\ result\ is\ infinity,}}
\DoxyCodeLine{01702\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ which\ should\ only\ match\ if\ max\_abs\_error\_\ is\ also\ infinity.}}
\DoxyCodeLine{01703\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (value\ ==\ expected\_)\ \{}
\DoxyCodeLine{01704\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01705\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01706\ }
\DoxyCodeLine{01707\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ FloatType\ diff\ =\ value\ -\/\ expected\_;}
\DoxyCodeLine{01708\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (::std::fabs(diff)\ <=\ max\_abs\_error\_)\ \{}
\DoxyCodeLine{01709\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01710\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01711\ }
\DoxyCodeLine{01712\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>IsInterested())\ \{}
\DoxyCodeLine{01713\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ "{}}\ <<\ diff\ <<\ \textcolor{stringliteral}{"{}\ from\ "{}}\ <<\ expected\_;}
\DoxyCodeLine{01714\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01715\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01716\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01717\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ actual.AlmostEquals(expected);}
\DoxyCodeLine{01718\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01719\ \ \ \ \ \}}
\DoxyCodeLine{01720\ }
\DoxyCodeLine{01721\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01722\ \ \ \ \ \ \ \textcolor{comment}{//\ os-\/>precision()\ returns\ the\ previously\ set\ precision,\ which\ we}}
\DoxyCodeLine{01723\ \ \ \ \ \ \ \textcolor{comment}{//\ store\ to\ restore\ the\ ostream\ to\ its\ original\ configuration}}
\DoxyCodeLine{01724\ \ \ \ \ \ \ \textcolor{comment}{//\ after\ outputting.}}
\DoxyCodeLine{01725\ \ \ \ \ \ \ const\ ::std::streamsize\ old\_precision\ =\ os-\/>precision(}
\DoxyCodeLine{01726\ \ \ \ \ \ \ \ \ \ \ ::std::numeric\_limits<FloatType>::digits10\ +\ 2);}
\DoxyCodeLine{01727\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (FloatingPoint<FloatType>(expected\_).is\_nan())\ \{}
\DoxyCodeLine{01728\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (nan\_eq\_nan\_)\ \{}
\DoxyCodeLine{01729\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ NaN"{}};}
\DoxyCodeLine{01730\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01731\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}never\ matches"{}};}
\DoxyCodeLine{01732\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01733\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01734\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ approximately\ "{}}\ <<\ expected\_;}
\DoxyCodeLine{01735\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (HasMaxAbsError())\ \{}
\DoxyCodeLine{01736\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ (absolute\ error\ <=\ "{}}\ <<\ max\_abs\_error\_\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01737\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01738\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01739\ \ \ \ \ \ \ os-\/>precision(old\_precision);}
\DoxyCodeLine{01740\ \ \ \ \ \}}
\DoxyCodeLine{01741\ }
\DoxyCodeLine{01742\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01743\ \ \ \ \ \ \ \textcolor{comment}{//\ As\ before,\ get\ original\ precision.}}
\DoxyCodeLine{01744\ \ \ \ \ \ \ const\ ::std::streamsize\ old\_precision\ =\ os-\/>precision(}
\DoxyCodeLine{01745\ \ \ \ \ \ \ \ \ \ \ ::std::numeric\_limits<FloatType>::digits10\ +\ 2);}
\DoxyCodeLine{01746\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (FloatingPoint<FloatType>(expected\_).is\_nan())\ \{}
\DoxyCodeLine{01747\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (nan\_eq\_nan\_)\ \{}
\DoxyCodeLine{01748\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ NaN"{}};}
\DoxyCodeLine{01749\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01750\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ anything"{}};}
\DoxyCodeLine{01751\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01752\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01753\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ approximately\ "{}}\ <<\ expected\_;}
\DoxyCodeLine{01754\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (HasMaxAbsError())\ \{}
\DoxyCodeLine{01755\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ (absolute\ error\ >\ "{}}\ <<\ max\_abs\_error\_\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{01756\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01757\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01758\ \ \ \ \ \ \ \textcolor{comment}{//\ Restore\ original\ precision.}}
\DoxyCodeLine{01759\ \ \ \ \ \ \ os-\/>precision(old\_precision);}
\DoxyCodeLine{01760\ \ \ \ \ \}}
\DoxyCodeLine{01761\ }
\DoxyCodeLine{01762\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01763\ \ \ \ \ \textcolor{keywordtype}{bool}\ HasMaxAbsError()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01764\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ max\_abs\_error\_\ >=\ 0;}
\DoxyCodeLine{01765\ \ \ \ \ \}}
\DoxyCodeLine{01766\ }
\DoxyCodeLine{01767\ \ \ \ \ \textcolor{keyword}{const}\ FloatType\ expected\_;}
\DoxyCodeLine{01768\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01769\ \ \ \ \ \textcolor{comment}{//\ max\_abs\_error\ will\ be\ used\ for\ value\ comparison\ when\ >=\ 0.}}
\DoxyCodeLine{01770\ \ \ \ \ \textcolor{keyword}{const}\ FloatType\ max\_abs\_error\_;}
\DoxyCodeLine{01771\ \ \ \};}
\DoxyCodeLine{01772\ }
\DoxyCodeLine{01773\ \ \ \textcolor{comment}{//\ The\ following\ 3\ type\ conversion\ operators\ allow\ FloatEq(expected)\ and}}
\DoxyCodeLine{01774\ \ \ \textcolor{comment}{//\ NanSensitiveFloatEq(expected)\ to\ be\ used\ as\ a\ Matcher<float>,\ a}}
\DoxyCodeLine{01775\ \ \ \textcolor{comment}{//\ Matcher<const\ float\&>,\ or\ a\ Matcher<float\&>,\ but\ nothing\ else.}}
\DoxyCodeLine{01776\ \ \ \textcolor{keyword}{operator}\ Matcher<FloatType>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01777\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01778\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<FloatType>(expected\_,\ nan\_eq\_nan\_,\ max\_abs\_error\_));}
\DoxyCodeLine{01779\ \ \ \}}
\DoxyCodeLine{01780\ }
\DoxyCodeLine{01781\ \ \ \textcolor{keyword}{operator}\ Matcher<const\ FloatType\&>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01782\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01783\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<const\ FloatType\&>(expected\_,\ nan\_eq\_nan\_,\ max\_abs\_error\_));}
\DoxyCodeLine{01784\ \ \ \}}
\DoxyCodeLine{01785\ }
\DoxyCodeLine{01786\ \ \ \textcolor{keyword}{operator}\ Matcher<FloatType\&>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01787\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01788\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<FloatType\&>(expected\_,\ nan\_eq\_nan\_,\ max\_abs\_error\_));}
\DoxyCodeLine{01789\ \ \ \}}
\DoxyCodeLine{01790\ }
\DoxyCodeLine{01791\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01792\ \ \ \textcolor{keyword}{const}\ FloatType\ expected\_;}
\DoxyCodeLine{01793\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01794\ \ \ \textcolor{comment}{//\ max\_abs\_error\ will\ be\ used\ for\ value\ comparison\ when\ >=\ 0.}}
\DoxyCodeLine{01795\ \ \ \textcolor{keyword}{const}\ FloatType\ max\_abs\_error\_;}
\DoxyCodeLine{01796\ \};}
\DoxyCodeLine{01797\ }
\DoxyCodeLine{01798\ \textcolor{comment}{//\ A\ 2-\/tuple\ ("{}binary"{})\ wrapper\ around\ FloatingEqMatcher:}}
\DoxyCodeLine{01799\ \textcolor{comment}{//\ FloatingEq2Matcher()\ matches\ (x,\ y)\ by\ matching\ FloatingEqMatcher(x,\ false)}}
\DoxyCodeLine{01800\ \textcolor{comment}{//\ against\ y,\ and\ FloatingEq2Matcher(e)\ matches\ FloatingEqMatcher(x,\ false,\ e)}}
\DoxyCodeLine{01801\ \textcolor{comment}{//\ against\ y.\ The\ former\ implements\ "{}Eq"{},\ the\ latter\ "{}Near"{}.\ At\ present,\ there}}
\DoxyCodeLine{01802\ \textcolor{comment}{//\ is\ no\ version\ that\ compares\ NaNs\ as\ equal.}}
\DoxyCodeLine{01803\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FloatType>}
\DoxyCodeLine{01804\ \textcolor{keyword}{class\ }FloatingEq2Matcher\ \{}
\DoxyCodeLine{01805\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01806\ \ \ FloatingEq2Matcher()\ \{\ Init(-\/1,\ \textcolor{keyword}{false});\ \}}
\DoxyCodeLine{01807\ }
\DoxyCodeLine{01808\ \ \ \textcolor{keyword}{explicit}\ FloatingEq2Matcher(\textcolor{keywordtype}{bool}\ nan\_eq\_nan)\ \{\ Init(-\/1,\ nan\_eq\_nan);\ \}}
\DoxyCodeLine{01809\ }
\DoxyCodeLine{01810\ \ \ \textcolor{keyword}{explicit}\ FloatingEq2Matcher(FloatType\ max\_abs\_error)\ \{}
\DoxyCodeLine{01811\ \ \ \ \ Init(max\_abs\_error,\ \textcolor{keyword}{false});}
\DoxyCodeLine{01812\ \ \ \}}
\DoxyCodeLine{01813\ }
\DoxyCodeLine{01814\ \ \ FloatingEq2Matcher(FloatType\ max\_abs\_error,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan)\ \{}
\DoxyCodeLine{01815\ \ \ \ \ Init(max\_abs\_error,\ nan\_eq\_nan);}
\DoxyCodeLine{01816\ \ \ \}}
\DoxyCodeLine{01817\ }
\DoxyCodeLine{01818\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{01819\ \ \ \textcolor{keyword}{operator}\ Matcher<::std::tuple<T1,\ T2>>()\ \textcolor{keyword}{const}\ \{}
\DoxyCodeLine{01820\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01821\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<::std::tuple<T1,\ T2>>(max\_abs\_error\_,\ nan\_eq\_nan\_));}
\DoxyCodeLine{01822\ \ \ \}}
\DoxyCodeLine{01823\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{01824\ \ \ \textcolor{keyword}{operator}\ Matcher<const\ ::std::tuple<T1,\ T2>\&>()\ \textcolor{keyword}{const}\ \{}
\DoxyCodeLine{01825\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(}
\DoxyCodeLine{01826\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<const\ ::std::tuple<T1,\ T2>\&>(max\_abs\_error\_,\ nan\_eq\_nan\_));}
\DoxyCodeLine{01827\ \ \ \}}
\DoxyCodeLine{01828\ }
\DoxyCodeLine{01829\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01830\ \ \ static\ ::std::ostream\&\ GetDesc(::std::ostream\&\ os)\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01831\ \ \ \ \ \textcolor{keywordflow}{return}\ os\ <<\ \textcolor{stringliteral}{"{}an\ almost-\/equal\ pair"{}};}
\DoxyCodeLine{01832\ \ \ \}}
\DoxyCodeLine{01833\ }
\DoxyCodeLine{01834\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple>}
\DoxyCodeLine{01835\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Tuple>\ \{}
\DoxyCodeLine{01836\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01837\ \ \ \ \ Impl(FloatType\ max\_abs\_error,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan)\ :}
\DoxyCodeLine{01838\ \ \ \ \ \ \ \ \ max\_abs\_error\_(max\_abs\_error),}
\DoxyCodeLine{01839\ \ \ \ \ \ \ \ \ nan\_eq\_nan\_(nan\_eq\_nan)\ \{\}}
\DoxyCodeLine{01840\ }
\DoxyCodeLine{01841\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Tuple\ args,}
\DoxyCodeLine{01842\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01843\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (max\_abs\_error\_\ ==\ -\/1)\ \{}
\DoxyCodeLine{01844\ \ \ \ \ \ \ \ \ FloatingEqMatcher<FloatType>\ fm(::std::get<0>(args),\ nan\_eq\_nan\_);}
\DoxyCodeLine{01845\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}Matcher<FloatType>\textcolor{keyword}{>}(fm).MatchAndExplain(}
\DoxyCodeLine{01846\ \ \ \ \ \ \ \ \ \ \ \ \ ::std::get<1>(args),\ listener);}
\DoxyCodeLine{01847\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01848\ \ \ \ \ \ \ \ \ FloatingEqMatcher<FloatType>\ fm(::std::get<0>(args),\ nan\_eq\_nan\_,}
\DoxyCodeLine{01849\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ max\_abs\_error\_);}
\DoxyCodeLine{01850\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}Matcher<FloatType>\textcolor{keyword}{>}(fm).MatchAndExplain(}
\DoxyCodeLine{01851\ \ \ \ \ \ \ \ \ \ \ \ \ ::std::get<1>(args),\ listener);}
\DoxyCodeLine{01852\ \ \ \ \ \ \ \}}
\DoxyCodeLine{01853\ \ \ \ \ \}}
\DoxyCodeLine{01854\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01855\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ "{}}\ <<\ GetDesc;}
\DoxyCodeLine{01856\ \ \ \ \ \}}
\DoxyCodeLine{01857\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01858\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}aren't\ "{}}\ <<\ GetDesc;}
\DoxyCodeLine{01859\ \ \ \ \ \}}
\DoxyCodeLine{01860\ }
\DoxyCodeLine{01861\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01862\ \ \ \ \ FloatType\ max\_abs\_error\_;}
\DoxyCodeLine{01863\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01864\ \ \ \};}
\DoxyCodeLine{01865\ }
\DoxyCodeLine{01866\ \ \ \textcolor{keywordtype}{void}\ Init(FloatType\ max\_abs\_error\_val,\ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_val)\ \{}
\DoxyCodeLine{01867\ \ \ \ \ max\_abs\_error\_\ =\ max\_abs\_error\_val;}
\DoxyCodeLine{01868\ \ \ \ \ nan\_eq\_nan\_\ =\ nan\_eq\_nan\_val;}
\DoxyCodeLine{01869\ \ \ \}}
\DoxyCodeLine{01870\ \ \ FloatType\ max\_abs\_error\_;}
\DoxyCodeLine{01871\ \ \ \textcolor{keywordtype}{bool}\ nan\_eq\_nan\_;}
\DoxyCodeLine{01872\ \};}
\DoxyCodeLine{01873\ }
\DoxyCodeLine{01874\ \textcolor{comment}{//\ Implements\ the\ Pointee(m)\ matcher\ for\ matching\ a\ pointer\ whose}}
\DoxyCodeLine{01875\ \textcolor{comment}{//\ pointee\ matches\ matcher\ m.\ \ The\ pointer\ can\ be\ either\ raw\ or\ smart.}}
\DoxyCodeLine{01876\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{01877\ \textcolor{keyword}{class\ }PointeeMatcher\ \{}
\DoxyCodeLine{01878\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01879\ \ \ \textcolor{keyword}{explicit}\ PointeeMatcher(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01880\ }
\DoxyCodeLine{01881\ \ \ \textcolor{comment}{//\ This\ type\ conversion\ operator\ template\ allows\ Pointee(m)\ to\ be}}
\DoxyCodeLine{01882\ \ \ \textcolor{comment}{//\ used\ as\ a\ matcher\ for\ any\ pointer\ type\ whose\ pointee\ type\ is}}
\DoxyCodeLine{01883\ \ \ \textcolor{comment}{//\ compatible\ with\ the\ inner\ matcher,\ where\ type\ Pointer\ can\ be}}
\DoxyCodeLine{01884\ \ \ \textcolor{comment}{//\ either\ a\ raw\ pointer\ or\ a\ smart\ pointer.}}
\DoxyCodeLine{01885\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01886\ \ \ \textcolor{comment}{//\ The\ reason\ we\ do\ this\ instead\ of\ relying\ on}}
\DoxyCodeLine{01887\ \ \ \textcolor{comment}{//\ MakePolymorphicMatcher()\ is\ that\ the\ latter\ is\ not\ flexible}}
\DoxyCodeLine{01888\ \ \ \textcolor{comment}{//\ enough\ for\ implementing\ the\ DescribeTo()\ method\ of\ Pointee().}}
\DoxyCodeLine{01889\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{01890\ \ \ \textcolor{keyword}{operator}\ Matcher<Pointer>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01891\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Pointer>(\textcolor{keyword}{new}\ Impl<const\ Pointer\&>(matcher\_));}
\DoxyCodeLine{01892\ \ \ \}}
\DoxyCodeLine{01893\ }
\DoxyCodeLine{01894\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01895\ \ \ \textcolor{comment}{//\ The\ monomorphic\ implementation\ that\ works\ for\ a\ particular\ pointer\ type.}}
\DoxyCodeLine{01896\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{01897\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Pointer>\ \{}
\DoxyCodeLine{01898\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01899\ \ \ \ \ \textcolor{keyword}{using\ }Pointee\ =}
\DoxyCodeLine{01900\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::pointer\_traits<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{01901\ \ \ \ \ \ \ \ \ \ \ \ \ Pointer)>::element\_type;}
\DoxyCodeLine{01902\ }
\DoxyCodeLine{01903\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)}
\DoxyCodeLine{01904\ \ \ \ \ \ \ \ \ :\ matcher\_(MatcherCast<const\ Pointee\&>(matcher))\ \{\}}
\DoxyCodeLine{01905\ }
\DoxyCodeLine{01906\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01907\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}points\ to\ a\ value\ that\ "{}};}
\DoxyCodeLine{01908\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{01909\ \ \ \ \ \}}
\DoxyCodeLine{01910\ }
\DoxyCodeLine{01911\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01912\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ point\ to\ a\ value\ that\ "{}};}
\DoxyCodeLine{01913\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{01914\ \ \ \ \ \}}
\DoxyCodeLine{01915\ }
\DoxyCodeLine{01916\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Pointer\ pointer,}
\DoxyCodeLine{01917\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01918\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (GetRawPointer(pointer)\ ==\ \textcolor{keyword}{nullptr})\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01919\ }
\DoxyCodeLine{01920\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ points\ to\ "{}};}
\DoxyCodeLine{01921\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(*pointer,\ matcher\_,\ listener);}
\DoxyCodeLine{01922\ \ \ \ \ \}}
\DoxyCodeLine{01923\ }
\DoxyCodeLine{01924\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01925\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ Pointee\&>\ matcher\_;}
\DoxyCodeLine{01926\ \ \ \};}
\DoxyCodeLine{01927\ }
\DoxyCodeLine{01928\ \ \ \textcolor{keyword}{const}\ InnerMatcher\ matcher\_;}
\DoxyCodeLine{01929\ \};}
\DoxyCodeLine{01930\ }
\DoxyCodeLine{01931\ \textcolor{comment}{//\ Implements\ the\ Pointer(m)\ matcher}}
\DoxyCodeLine{01932\ \textcolor{comment}{//\ Implements\ the\ Pointer(m)\ matcher\ for\ matching\ a\ pointer\ that\ matches\ matcher}}
\DoxyCodeLine{01933\ \textcolor{comment}{//\ m.\ \ The\ pointer\ can\ be\ either\ raw\ or\ smart,\ and\ will\ match\ \`{}m`\ against\ the}}
\DoxyCodeLine{01934\ \textcolor{comment}{//\ raw\ pointer.}}
\DoxyCodeLine{01935\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{01936\ \textcolor{keyword}{class\ }PointerMatcher\ \{}
\DoxyCodeLine{01937\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01938\ \ \ \textcolor{keyword}{explicit}\ PointerMatcher(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)\ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{01939\ }
\DoxyCodeLine{01940\ \ \ \textcolor{comment}{//\ This\ type\ conversion\ operator\ template\ allows\ Pointer(m)\ to\ be}}
\DoxyCodeLine{01941\ \ \ \textcolor{comment}{//\ used\ as\ a\ matcher\ for\ any\ pointer\ type\ whose\ pointer\ type\ is}}
\DoxyCodeLine{01942\ \ \ \textcolor{comment}{//\ compatible\ with\ the\ inner\ matcher,\ where\ type\ PointerType\ can\ be}}
\DoxyCodeLine{01943\ \ \ \textcolor{comment}{//\ either\ a\ raw\ pointer\ or\ a\ smart\ pointer.}}
\DoxyCodeLine{01944\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{01945\ \ \ \textcolor{comment}{//\ The\ reason\ we\ do\ this\ instead\ of\ relying\ on}}
\DoxyCodeLine{01946\ \ \ \textcolor{comment}{//\ MakePolymorphicMatcher()\ is\ that\ the\ latter\ is\ not\ flexible}}
\DoxyCodeLine{01947\ \ \ \textcolor{comment}{//\ enough\ for\ implementing\ the\ DescribeTo()\ method\ of\ Pointer().}}
\DoxyCodeLine{01948\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}erType>}
\DoxyCodeLine{01949\ \ \ \textcolor{keyword}{operator}\ Matcher<PointerType>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{01950\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<PointerType>(\textcolor{keyword}{new}\ Impl<const\ PointerType\&>(matcher\_));}
\DoxyCodeLine{01951\ \ \ \}}
\DoxyCodeLine{01952\ }
\DoxyCodeLine{01953\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01954\ \ \ \textcolor{comment}{//\ The\ monomorphic\ implementation\ that\ works\ for\ a\ particular\ pointer\ type.}}
\DoxyCodeLine{01955\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Po\textcolor{keywordtype}{int}erType>}
\DoxyCodeLine{01956\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<PointerType>\ \{}
\DoxyCodeLine{01957\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01958\ \ \ \ \ \textcolor{keyword}{using\ }Pointer\ =}
\DoxyCodeLine{01959\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{typename}\ std::pointer\_traits<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(}
\DoxyCodeLine{01960\ \ \ \ \ \ \ \ \ \ \ \ \ PointerType)>::element\_type*;}
\DoxyCodeLine{01961\ }
\DoxyCodeLine{01962\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)}
\DoxyCodeLine{01963\ \ \ \ \ \ \ \ \ :\ matcher\_(MatcherCast<Pointer>(matcher))\ \{\}}
\DoxyCodeLine{01964\ }
\DoxyCodeLine{01965\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01966\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ a\ pointer\ that\ "{}};}
\DoxyCodeLine{01967\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{01968\ \ \ \ \ \}}
\DoxyCodeLine{01969\ }
\DoxyCodeLine{01970\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01971\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ not\ a\ pointer\ that\ "{}};}
\DoxyCodeLine{01972\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{01973\ \ \ \ \ \}}
\DoxyCodeLine{01974\ }
\DoxyCodeLine{01975\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(PointerType\ pointer,}
\DoxyCodeLine{01976\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{01977\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ a\ pointer\ that\ "{}};}
\DoxyCodeLine{01978\ \ \ \ \ \ \ Pointer\ p\ =\ GetRawPointer(pointer);}
\DoxyCodeLine{01979\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(p,\ matcher\_,\ listener);}
\DoxyCodeLine{01980\ \ \ \ \ \}}
\DoxyCodeLine{01981\ }
\DoxyCodeLine{01982\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01983\ \ \ \ \ Matcher<Pointer>\ matcher\_;}
\DoxyCodeLine{01984\ \ \ \};}
\DoxyCodeLine{01985\ }
\DoxyCodeLine{01986\ \ \ \textcolor{keyword}{const}\ InnerMatcher\ matcher\_;}
\DoxyCodeLine{01987\ \};}
\DoxyCodeLine{01988\ }
\DoxyCodeLine{01989\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{01990\ \textcolor{comment}{//\ Implements\ the\ WhenDynamicCastTo<T>(m)\ matcher\ that\ matches\ a\ pointer\ or}}
\DoxyCodeLine{01991\ \textcolor{comment}{//\ reference\ that\ matches\ inner\_matcher\ when\ dynamic\_cast<T>\ is\ applied.}}
\DoxyCodeLine{01992\ \textcolor{comment}{//\ The\ result\ of\ dynamic\_cast<To>\ is\ forwarded\ to\ the\ inner\ matcher.}}
\DoxyCodeLine{01993\ \textcolor{comment}{//\ If\ To\ is\ a\ pointer\ and\ the\ cast\ fails,\ the\ inner\ matcher\ will\ receive\ NULL.}}
\DoxyCodeLine{01994\ \textcolor{comment}{//\ If\ To\ is\ a\ reference\ and\ the\ cast\ fails,\ this\ matcher\ returns\ false}}
\DoxyCodeLine{01995\ \textcolor{comment}{//\ immediately.}}
\DoxyCodeLine{01996\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ To>}
\DoxyCodeLine{01997\ \textcolor{keyword}{class\ }WhenDynamicCastToMatcherBase\ \{}
\DoxyCodeLine{01998\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01999\ \ \ \textcolor{keyword}{explicit}\ WhenDynamicCastToMatcherBase(\textcolor{keyword}{const}\ Matcher<To>\&\ matcher)}
\DoxyCodeLine{02000\ \ \ \ \ \ \ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{02001\ }
\DoxyCodeLine{02002\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02003\ \ \ \ \ GetCastTypeDescription(os);}
\DoxyCodeLine{02004\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02005\ \ \ \}}
\DoxyCodeLine{02006\ }
\DoxyCodeLine{02007\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02008\ \ \ \ \ GetCastTypeDescription(os);}
\DoxyCodeLine{02009\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02010\ \ \ \}}
\DoxyCodeLine{02011\ }
\DoxyCodeLine{02012\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{02013\ \ \ \textcolor{keyword}{const}\ Matcher<To>\ matcher\_;}
\DoxyCodeLine{02014\ }
\DoxyCodeLine{02015\ \ \ \textcolor{keyword}{static}\ std::string\ GetToName()\ \{}
\DoxyCodeLine{02016\ \ \ \ \ \textcolor{keywordflow}{return}\ GetTypeName<To>();}
\DoxyCodeLine{02017\ \ \ \}}
\DoxyCodeLine{02018\ }
\DoxyCodeLine{02019\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02020\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ GetCastTypeDescription(::std::ostream*\ os)\ \{}
\DoxyCodeLine{02021\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}when\ dynamic\_cast\ to\ "{}}\ <<\ GetToName()\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02022\ \ \ \}}
\DoxyCodeLine{02023\ \};}
\DoxyCodeLine{02024\ }
\DoxyCodeLine{02025\ \textcolor{comment}{//\ Primary\ template.}}
\DoxyCodeLine{02026\ \textcolor{comment}{//\ To\ is\ a\ pointer.\ Cast\ and\ forward\ the\ result.}}
\DoxyCodeLine{02027\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ To>}
\DoxyCodeLine{02028\ \textcolor{keyword}{class\ }WhenDynamicCastToMatcher\ :\ \textcolor{keyword}{public}\ WhenDynamicCastToMatcherBase<To>\ \{}
\DoxyCodeLine{02029\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02030\ \ \ \textcolor{keyword}{explicit}\ WhenDynamicCastToMatcher(\textcolor{keyword}{const}\ Matcher<To>\&\ matcher)}
\DoxyCodeLine{02031\ \ \ \ \ \ \ :\ WhenDynamicCastToMatcherBase<To>(matcher)\ \{\}}
\DoxyCodeLine{02032\ }
\DoxyCodeLine{02033\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ From>}
\DoxyCodeLine{02034\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(From\ from,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02035\ \ \ \ \ To\ to\ =\ \textcolor{keyword}{dynamic\_cast<}To\textcolor{keyword}{>}(from);}
\DoxyCodeLine{02036\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(to,\ this-\/>matcher\_,\ listener);}
\DoxyCodeLine{02037\ \ \ \}}
\DoxyCodeLine{02038\ \};}
\DoxyCodeLine{02039\ }
\DoxyCodeLine{02040\ \textcolor{comment}{//\ Specialize\ for\ references.}}
\DoxyCodeLine{02041\ \textcolor{comment}{//\ In\ this\ case\ we\ return\ false\ if\ the\ dynamic\_cast\ fails.}}
\DoxyCodeLine{02042\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ To>}
\DoxyCodeLine{02043\ \textcolor{keyword}{class\ }WhenDynamicCastToMatcher<To\&>\ :\ \textcolor{keyword}{public}\ WhenDynamicCastToMatcherBase<To\&>\ \{}
\DoxyCodeLine{02044\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02045\ \ \ \textcolor{keyword}{explicit}\ WhenDynamicCastToMatcher(\textcolor{keyword}{const}\ Matcher<To\&>\&\ matcher)}
\DoxyCodeLine{02046\ \ \ \ \ \ \ :\ WhenDynamicCastToMatcherBase<To\&>(matcher)\ \{\}}
\DoxyCodeLine{02047\ }
\DoxyCodeLine{02048\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ From>}
\DoxyCodeLine{02049\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(From\&\ from,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02050\ \ \ \ \ \textcolor{comment}{//\ We\ don't\ want\ an\ std::bad\_cast\ here,\ so\ do\ the\ cast\ with\ pointers.}}
\DoxyCodeLine{02051\ \ \ \ \ To*\ to\ =\ \textcolor{keyword}{dynamic\_cast<}To*\textcolor{keyword}{>}(\&from);}
\DoxyCodeLine{02052\ \ \ \ \ \textcolor{keywordflow}{if}\ (to\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02053\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ cannot\ be\ dynamic\_cast\ to\ "{}}\ <<\ this-\/>GetToName();}
\DoxyCodeLine{02054\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02055\ \ \ \ \ \}}
\DoxyCodeLine{02056\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(*to,\ this-\/>matcher\_,\ listener);}
\DoxyCodeLine{02057\ \ \ \}}
\DoxyCodeLine{02058\ \};}
\DoxyCodeLine{02059\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{02060\ }
\DoxyCodeLine{02061\ \textcolor{comment}{//\ Implements\ the\ Field()\ matcher\ for\ matching\ a\ field\ (i.e.\ member}}
\DoxyCodeLine{02062\ \textcolor{comment}{//\ variable)\ of\ an\ object.}}
\DoxyCodeLine{02063\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ FieldType>}
\DoxyCodeLine{02064\ \textcolor{keyword}{class\ }FieldMatcher\ \{}
\DoxyCodeLine{02065\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02066\ \ \ FieldMatcher(FieldType\ Class::*field,}
\DoxyCodeLine{02067\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ Matcher<const\ FieldType\&>\&\ matcher)}
\DoxyCodeLine{02068\ \ \ \ \ \ \ :\ field\_(field),\ matcher\_(matcher),\ whose\_field\_(\textcolor{stringliteral}{"{}whose\ given\ field\ "{}})\ \{\}}
\DoxyCodeLine{02069\ }
\DoxyCodeLine{02070\ \ \ FieldMatcher(\textcolor{keyword}{const}\ std::string\&\ field\_name,\ FieldType\ Class::*field,}
\DoxyCodeLine{02071\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ Matcher<const\ FieldType\&>\&\ matcher)}
\DoxyCodeLine{02072\ \ \ \ \ \ \ :\ field\_(field),}
\DoxyCodeLine{02073\ \ \ \ \ \ \ \ \ matcher\_(matcher),}
\DoxyCodeLine{02074\ \ \ \ \ \ \ \ \ whose\_field\_(\textcolor{stringliteral}{"{}whose\ field\ \`{}"{}}\ +\ field\_name\ +\ \textcolor{stringliteral}{"{}\`{}\ "{}})\ \{\}}
\DoxyCodeLine{02075\ }
\DoxyCodeLine{02076\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02077\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ object\ "{}}\ <<\ whose\_field\_;}
\DoxyCodeLine{02078\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02079\ \ \ \}}
\DoxyCodeLine{02080\ }
\DoxyCodeLine{02081\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02082\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ object\ "{}}\ <<\ whose\_field\_;}
\DoxyCodeLine{02083\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02084\ \ \ \}}
\DoxyCodeLine{02085\ }
\DoxyCodeLine{02086\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02087\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ value,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02088\ \ \ \ \ \textcolor{comment}{//\ FIXME:\ The\ dispatch\ on\ std::is\_pointer\ was\ introduced\ as\ a\ workaround\ for}}
\DoxyCodeLine{02089\ \ \ \ \ \textcolor{comment}{//\ a\ compiler\ bug,\ and\ can\ now\ be\ removed.}}
\DoxyCodeLine{02090\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplainImpl(}
\DoxyCodeLine{02091\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::is\_pointer<\textcolor{keyword}{typename}\ std::remove\_const<T>::type>::type(),}
\DoxyCodeLine{02092\ \ \ \ \ \ \ \ \ value,\ listener);}
\DoxyCodeLine{02093\ \ \ \}}
\DoxyCodeLine{02094\ }
\DoxyCodeLine{02095\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02096\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(std::false\_type\ \textcolor{comment}{/*\ is\_not\_pointer\ */},}
\DoxyCodeLine{02097\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Class\&\ obj,}
\DoxyCodeLine{02098\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02099\ \ \ \ \ *listener\ <<\ whose\_field\_\ <<\ \textcolor{stringliteral}{"{}is\ "{}};}
\DoxyCodeLine{02100\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(obj.*field\_,\ matcher\_,\ listener);}
\DoxyCodeLine{02101\ \ \ \}}
\DoxyCodeLine{02102\ }
\DoxyCodeLine{02103\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(std::true\_type\ \textcolor{comment}{/*\ is\_pointer\ */},\ \textcolor{keyword}{const}\ Class*\ p,}
\DoxyCodeLine{02104\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02105\ \ \ \ \ \textcolor{keywordflow}{if}\ (p\ ==\ \textcolor{keyword}{nullptr})\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02106\ }
\DoxyCodeLine{02107\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ "{}};}
\DoxyCodeLine{02108\ \ \ \ \ \textcolor{comment}{//\ Since\ *p\ has\ a\ field,\ it\ must\ be\ a\ class/struct/union\ type\ and}}
\DoxyCodeLine{02109\ \ \ \ \ \textcolor{comment}{//\ thus\ cannot\ be\ a\ pointer.\ \ Therefore\ we\ pass\ false\_type()\ as}}
\DoxyCodeLine{02110\ \ \ \ \ \textcolor{comment}{//\ the\ first\ argument.}}
\DoxyCodeLine{02111\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplainImpl(std::false\_type(),\ *p,\ listener);}
\DoxyCodeLine{02112\ \ \ \}}
\DoxyCodeLine{02113\ }
\DoxyCodeLine{02114\ \ \ \textcolor{keyword}{const}\ FieldType\ Class::*field\_;}
\DoxyCodeLine{02115\ \ \ \textcolor{keyword}{const}\ Matcher<const\ FieldType\&>\ matcher\_;}
\DoxyCodeLine{02116\ }
\DoxyCodeLine{02117\ \ \ \textcolor{comment}{//\ Contains\ either\ "{}whose\ given\ field\ "{}\ if\ the\ name\ of\ the\ field\ is\ unknown}}
\DoxyCodeLine{02118\ \ \ \textcolor{comment}{//\ or\ "{}whose\ field\ \`{}name\_of\_field`\ "{}\ if\ the\ name\ is\ known.}}
\DoxyCodeLine{02119\ \ \ \textcolor{keyword}{const}\ std::string\ whose\_field\_;}
\DoxyCodeLine{02120\ \};}
\DoxyCodeLine{02121\ }
\DoxyCodeLine{02122\ \textcolor{comment}{//\ Implements\ the\ Property()\ matcher\ for\ matching\ a\ property}}
\DoxyCodeLine{02123\ \textcolor{comment}{//\ (i.e.\ return\ value\ of\ a\ getter\ method)\ of\ an\ object.}}
\DoxyCodeLine{02124\ \textcolor{comment}{//}}
\DoxyCodeLine{02125\ \textcolor{comment}{//\ Property\ is\ a\ const-\/qualified\ member\ function\ of\ Class\ returning}}
\DoxyCodeLine{02126\ \textcolor{comment}{//\ PropertyType.}}
\DoxyCodeLine{02127\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ Property>}
\DoxyCodeLine{02128\ \textcolor{keyword}{class\ }PropertyMatcher\ \{}
\DoxyCodeLine{02129\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02130\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{const}\ PropertyType\&\ RefToConstProperty;}
\DoxyCodeLine{02131\ }
\DoxyCodeLine{02132\ \ \ PropertyMatcher(Property\ property,\ \textcolor{keyword}{const}\ Matcher<RefToConstProperty>\&\ matcher)}
\DoxyCodeLine{02133\ \ \ \ \ \ \ :\ property\_(property),}
\DoxyCodeLine{02134\ \ \ \ \ \ \ \ \ matcher\_(matcher),}
\DoxyCodeLine{02135\ \ \ \ \ \ \ \ \ whose\_property\_(\textcolor{stringliteral}{"{}whose\ given\ property\ "{}})\ \{\}}
\DoxyCodeLine{02136\ }
\DoxyCodeLine{02137\ \ \ PropertyMatcher(\textcolor{keyword}{const}\ std::string\&\ property\_name,\ Property\ property,}
\DoxyCodeLine{02138\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Matcher<RefToConstProperty>\&\ matcher)}
\DoxyCodeLine{02139\ \ \ \ \ \ \ :\ property\_(property),}
\DoxyCodeLine{02140\ \ \ \ \ \ \ \ \ matcher\_(matcher),}
\DoxyCodeLine{02141\ \ \ \ \ \ \ \ \ whose\_property\_(\textcolor{stringliteral}{"{}whose\ property\ \`{}"{}}\ +\ property\_name\ +\ \textcolor{stringliteral}{"{}\`{}\ "{}})\ \{\}}
\DoxyCodeLine{02142\ }
\DoxyCodeLine{02143\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02144\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ object\ "{}}\ <<\ whose\_property\_;}
\DoxyCodeLine{02145\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02146\ \ \ \}}
\DoxyCodeLine{02147\ }
\DoxyCodeLine{02148\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02149\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ object\ "{}}\ <<\ whose\_property\_;}
\DoxyCodeLine{02150\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02151\ \ \ \}}
\DoxyCodeLine{02152\ }
\DoxyCodeLine{02153\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02154\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&value,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02155\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplainImpl(}
\DoxyCodeLine{02156\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::is\_pointer<\textcolor{keyword}{typename}\ std::remove\_const<T>::type>::type(),}
\DoxyCodeLine{02157\ \ \ \ \ \ \ \ \ value,\ listener);}
\DoxyCodeLine{02158\ \ \ \}}
\DoxyCodeLine{02159\ }
\DoxyCodeLine{02160\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02161\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(std::false\_type\ \textcolor{comment}{/*\ is\_not\_pointer\ */},}
\DoxyCodeLine{02162\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Class\&\ obj,}
\DoxyCodeLine{02163\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02164\ \ \ \ \ *listener\ <<\ whose\_property\_\ <<\ \textcolor{stringliteral}{"{}is\ "{}};}
\DoxyCodeLine{02165\ \ \ \ \ \textcolor{comment}{//\ Cannot\ pass\ the\ return\ value\ (for\ example,\ int)\ to\ MatchPrintAndExplain,}}
\DoxyCodeLine{02166\ \ \ \ \ \textcolor{comment}{//\ which\ takes\ a\ non-\/const\ reference\ as\ argument.}}
\DoxyCodeLine{02167\ \ \ \ \ RefToConstProperty\ result\ =\ (obj.*property\_)();}
\DoxyCodeLine{02168\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(result,\ matcher\_,\ listener);}
\DoxyCodeLine{02169\ \ \ \}}
\DoxyCodeLine{02170\ }
\DoxyCodeLine{02171\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(std::true\_type\ \textcolor{comment}{/*\ is\_pointer\ */},\ \textcolor{keyword}{const}\ Class*\ p,}
\DoxyCodeLine{02172\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02173\ \ \ \ \ \textcolor{keywordflow}{if}\ (p\ ==\ \textcolor{keyword}{nullptr})\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02174\ }
\DoxyCodeLine{02175\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ "{}};}
\DoxyCodeLine{02176\ \ \ \ \ \textcolor{comment}{//\ Since\ *p\ has\ a\ property\ method,\ it\ must\ be\ a\ class/struct/union}}
\DoxyCodeLine{02177\ \ \ \ \ \textcolor{comment}{//\ type\ and\ thus\ cannot\ be\ a\ pointer.\ \ Therefore\ we\ pass}}
\DoxyCodeLine{02178\ \ \ \ \ \textcolor{comment}{//\ false\_type()\ as\ the\ first\ argument.}}
\DoxyCodeLine{02179\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchAndExplainImpl(std::false\_type(),\ *p,\ listener);}
\DoxyCodeLine{02180\ \ \ \}}
\DoxyCodeLine{02181\ }
\DoxyCodeLine{02182\ \ \ Property\ property\_;}
\DoxyCodeLine{02183\ \ \ \textcolor{keyword}{const}\ Matcher<RefToConstProperty>\ matcher\_;}
\DoxyCodeLine{02184\ }
\DoxyCodeLine{02185\ \ \ \textcolor{comment}{//\ Contains\ either\ "{}whose\ given\ property\ "{}\ if\ the\ name\ of\ the\ property\ is}}
\DoxyCodeLine{02186\ \ \ \textcolor{comment}{//\ unknown\ or\ "{}whose\ property\ \`{}name\_of\_property`\ "{}\ if\ the\ name\ is\ known.}}
\DoxyCodeLine{02187\ \ \ \textcolor{keyword}{const}\ std::string\ whose\_property\_;}
\DoxyCodeLine{02188\ \};}
\DoxyCodeLine{02189\ }
\DoxyCodeLine{02190\ \textcolor{comment}{//\ Type\ traits\ specifying\ various\ features\ of\ different\ functors\ for\ ResultOf.}}
\DoxyCodeLine{02191\ \textcolor{comment}{//\ The\ default\ template\ specifies\ features\ for\ functor\ objects.}}
\DoxyCodeLine{02192\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Functor>}
\DoxyCodeLine{02193\ \textcolor{keyword}{struct\ }CallableTraits\ \{}
\DoxyCodeLine{02194\ \ \ \textcolor{keyword}{typedef}\ Functor\ StorageType;}
\DoxyCodeLine{02195\ }
\DoxyCodeLine{02196\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ CheckIsValid(Functor\ \textcolor{comment}{/*\ functor\ */})\ \{\}}
\DoxyCodeLine{02197\ }
\DoxyCodeLine{02198\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02199\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{auto}\ Invoke(Functor\ f,\ \textcolor{keyword}{const}\ T\&\ arg)\ -\/>\ \textcolor{keyword}{decltype}(f(arg))\ \{}
\DoxyCodeLine{02200\ \ \ \ \ \textcolor{keywordflow}{return}\ f(arg);}
\DoxyCodeLine{02201\ \ \ \}}
\DoxyCodeLine{02202\ \};}
\DoxyCodeLine{02203\ }
\DoxyCodeLine{02204\ \textcolor{comment}{//\ Specialization\ for\ function\ pointers.}}
\DoxyCodeLine{02205\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ArgType,\ \textcolor{keyword}{typename}\ ResType>}
\DoxyCodeLine{02206\ \textcolor{keyword}{struct\ }CallableTraits<ResType(*)(ArgType)>\ \{}
\DoxyCodeLine{02207\ \ \ \textcolor{keyword}{typedef}\ ResType\ ResultType;}
\DoxyCodeLine{02208\ \ \ \textcolor{keyword}{typedef}\ ResType(*StorageType)(ArgType);}
\DoxyCodeLine{02209\ }
\DoxyCodeLine{02210\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ CheckIsValid(ResType(*f)(ArgType))\ \{}
\DoxyCodeLine{02211\ \ \ \ \ GTEST\_CHECK\_(f\ !=\ \textcolor{keyword}{nullptr})}
\DoxyCodeLine{02212\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}NULL\ function\ pointer\ is\ passed\ into\ ResultOf()."{}};}
\DoxyCodeLine{02213\ \ \ \}}
\DoxyCodeLine{02214\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02215\ \ \ \textcolor{keyword}{static}\ ResType\ Invoke(ResType(*f)(ArgType),\ T\ arg)\ \{}
\DoxyCodeLine{02216\ \ \ \ \ \textcolor{keywordflow}{return}\ (*f)(arg);}
\DoxyCodeLine{02217\ \ \ \}}
\DoxyCodeLine{02218\ \};}
\DoxyCodeLine{02219\ }
\DoxyCodeLine{02220\ \textcolor{comment}{//\ Implements\ the\ ResultOf()\ matcher\ for\ matching\ a\ return\ value\ of\ a}}
\DoxyCodeLine{02221\ \textcolor{comment}{//\ unary\ function\ of\ an\ object.}}
\DoxyCodeLine{02222\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Callable,\ \textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02223\ \textcolor{keyword}{class\ }ResultOfMatcher\ \{}
\DoxyCodeLine{02224\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02225\ \ \ ResultOfMatcher(Callable\ callable,\ InnerMatcher\ matcher)}
\DoxyCodeLine{02226\ \ \ \ \ \ \ :\ callable\_(std::move(callable)),\ matcher\_(std::move(matcher))\ \{}
\DoxyCodeLine{02227\ \ \ \ \ CallableTraits<Callable>::CheckIsValid(callable\_);}
\DoxyCodeLine{02228\ \ \ \}}
\DoxyCodeLine{02229\ }
\DoxyCodeLine{02230\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02231\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02232\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<T>(\textcolor{keyword}{new}\ Impl<const\ T\&>(callable\_,\ matcher\_));}
\DoxyCodeLine{02233\ \ \ \}}
\DoxyCodeLine{02234\ }
\DoxyCodeLine{02235\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02236\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ CallableTraits<Callable>::StorageType\ CallableStorageType;}
\DoxyCodeLine{02237\ }
\DoxyCodeLine{02238\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02239\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<T>\ \{}
\DoxyCodeLine{02240\ \ \ \ \ \textcolor{keyword}{using\ }ResultType\ =\ \textcolor{keyword}{decltype}(CallableTraits<Callable>::template\ Invoke<T>(}
\DoxyCodeLine{02241\ \ \ \ \ \ \ \ \ std::declval<CallableStorageType>(),\ std::declval<T>()));}
\DoxyCodeLine{02242\ }
\DoxyCodeLine{02243\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02244\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{02245\ \ \ \ \ Impl(\textcolor{keyword}{const}\ CallableStorageType\&\ callable,\ \textcolor{keyword}{const}\ M\&\ matcher)}
\DoxyCodeLine{02246\ \ \ \ \ \ \ \ \ :\ callable\_(callable),\ matcher\_(MatcherCast<ResultType>(matcher))\ \{\}}
\DoxyCodeLine{02247\ }
\DoxyCodeLine{02248\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02249\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ mapped\ by\ the\ given\ callable\ to\ a\ value\ that\ "{}};}
\DoxyCodeLine{02250\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02251\ \ \ \ \ \}}
\DoxyCodeLine{02252\ }
\DoxyCodeLine{02253\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02254\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ mapped\ by\ the\ given\ callable\ to\ a\ value\ that\ "{}};}
\DoxyCodeLine{02255\ \ \ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02256\ \ \ \ \ \}}
\DoxyCodeLine{02257\ }
\DoxyCodeLine{02258\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\ obj,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02259\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ mapped\ by\ the\ given\ callable\ to\ "{}};}
\DoxyCodeLine{02260\ \ \ \ \ \ \ \textcolor{comment}{//\ Cannot\ pass\ the\ return\ value\ directly\ to\ MatchPrintAndExplain,\ which}}
\DoxyCodeLine{02261\ \ \ \ \ \ \ \textcolor{comment}{//\ takes\ a\ non-\/const\ reference\ as\ argument.}}
\DoxyCodeLine{02262\ \ \ \ \ \ \ \textcolor{comment}{//\ Also,\ specifying\ template\ argument\ explicitly\ is\ needed\ because\ T\ could}}
\DoxyCodeLine{02263\ \ \ \ \ \ \ \textcolor{comment}{//\ be\ a\ non-\/const\ reference\ (e.g.\ Matcher<Uncopyable\&>).}}
\DoxyCodeLine{02264\ \ \ \ \ \ \ ResultType\ result\ =}
\DoxyCodeLine{02265\ \ \ \ \ \ \ \ \ \ \ CallableTraits<Callable>::template\ Invoke<T>(callable\_,\ obj);}
\DoxyCodeLine{02266\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(result,\ matcher\_,\ listener);}
\DoxyCodeLine{02267\ \ \ \ \ \}}
\DoxyCodeLine{02268\ }
\DoxyCodeLine{02269\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02270\ \ \ \ \ \textcolor{comment}{//\ Functors\ often\ define\ operator()\ as\ non-\/const\ method\ even\ though}}
\DoxyCodeLine{02271\ \ \ \ \ \textcolor{comment}{//\ they\ are\ actually\ stateless.\ But\ we\ need\ to\ use\ them\ even\ when}}
\DoxyCodeLine{02272\ \ \ \ \ \textcolor{comment}{//\ 'this'\ is\ a\ const\ pointer.\ It's\ the\ user's\ responsibility\ not\ to}}
\DoxyCodeLine{02273\ \ \ \ \ \textcolor{comment}{//\ use\ stateful\ callables\ with\ ResultOf(),\ which\ doesn't\ guarantee}}
\DoxyCodeLine{02274\ \ \ \ \ \textcolor{comment}{//\ how\ many\ times\ the\ callable\ will\ be\ invoked.}}
\DoxyCodeLine{02275\ \ \ \ \ \textcolor{keyword}{mutable}\ CallableStorageType\ callable\_;}
\DoxyCodeLine{02276\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<ResultType>\ matcher\_;}
\DoxyCodeLine{02277\ \ \ \};\ \ \textcolor{comment}{//\ class\ Impl}}
\DoxyCodeLine{02278\ }
\DoxyCodeLine{02279\ \ \ \textcolor{keyword}{const}\ CallableStorageType\ callable\_;}
\DoxyCodeLine{02280\ \ \ \textcolor{keyword}{const}\ InnerMatcher\ matcher\_;}
\DoxyCodeLine{02281\ \};}
\DoxyCodeLine{02282\ }
\DoxyCodeLine{02283\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ checks\ the\ size\ of\ an\ STL-\/style\ container.}}
\DoxyCodeLine{02284\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ SizeMatcher>}
\DoxyCodeLine{02285\ \textcolor{keyword}{class\ }SizeIsMatcher\ \{}
\DoxyCodeLine{02286\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02287\ \ \ \textcolor{keyword}{explicit}\ SizeIsMatcher(\textcolor{keyword}{const}\ SizeMatcher\&\ size\_matcher)}
\DoxyCodeLine{02288\ \ \ \ \ \ \ \ :\ size\_matcher\_(size\_matcher)\ \{}
\DoxyCodeLine{02289\ \ \ \}}
\DoxyCodeLine{02290\ }
\DoxyCodeLine{02291\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02292\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02293\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ Impl<const\ Container\&>(size\_matcher\_));}
\DoxyCodeLine{02294\ \ \ \}}
\DoxyCodeLine{02295\ }
\DoxyCodeLine{02296\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02297\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>\ \{}
\DoxyCodeLine{02298\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02299\ \ \ \ \ \textcolor{keyword}{using\ }SizeType\ =\ \textcolor{keyword}{decltype}(std::declval<Container>().size());}
\DoxyCodeLine{02300\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ SizeMatcher\&\ size\_matcher)}
\DoxyCodeLine{02301\ \ \ \ \ \ \ \ \ :\ size\_matcher\_(MatcherCast<SizeType>(size\_matcher))\ \{\}}
\DoxyCodeLine{02302\ }
\DoxyCodeLine{02303\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02304\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}size\ "{}};}
\DoxyCodeLine{02305\ \ \ \ \ \ \ size\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02306\ \ \ \ \ \}}
\DoxyCodeLine{02307\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02308\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}size\ "{}};}
\DoxyCodeLine{02309\ \ \ \ \ \ \ size\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02310\ \ \ \ \ \}}
\DoxyCodeLine{02311\ }
\DoxyCodeLine{02312\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02313\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02314\ \ \ \ \ \ \ SizeType\ size\ =\ container.size();}
\DoxyCodeLine{02315\ \ \ \ \ \ \ StringMatchResultListener\ size\_listener;}
\DoxyCodeLine{02316\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ result\ =\ size\_matcher\_.MatchAndExplain(size,\ \&size\_listener);}
\DoxyCodeLine{02317\ \ \ \ \ \ \ *listener}
\DoxyCodeLine{02318\ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}whose\ size\ "{}}\ <<\ size\ <<\ (result\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{02319\ \ \ \ \ \ \ PrintIfNotEmpty(size\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02320\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{02321\ \ \ \ \ \}}
\DoxyCodeLine{02322\ }
\DoxyCodeLine{02323\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02324\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<SizeType>\ size\_matcher\_;}
\DoxyCodeLine{02325\ \ \ \};}
\DoxyCodeLine{02326\ }
\DoxyCodeLine{02327\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02328\ \ \ \textcolor{keyword}{const}\ SizeMatcher\ size\_matcher\_;}
\DoxyCodeLine{02329\ \};}
\DoxyCodeLine{02330\ }
\DoxyCodeLine{02331\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ checks\ the\ begin()..end()\ distance\ of\ an\ STL-\/style}}
\DoxyCodeLine{02332\ \textcolor{comment}{//\ container.}}
\DoxyCodeLine{02333\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ DistanceMatcher>}
\DoxyCodeLine{02334\ \textcolor{keyword}{class\ }BeginEndDistanceIsMatcher\ \{}
\DoxyCodeLine{02335\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02336\ \ \ \textcolor{keyword}{explicit}\ BeginEndDistanceIsMatcher(\textcolor{keyword}{const}\ DistanceMatcher\&\ distance\_matcher)}
\DoxyCodeLine{02337\ \ \ \ \ \ \ :\ distance\_matcher\_(distance\_matcher)\ \{\}}
\DoxyCodeLine{02338\ }
\DoxyCodeLine{02339\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02340\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02341\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ Impl<const\ Container\&>(distance\_matcher\_));}
\DoxyCodeLine{02342\ \ \ \}}
\DoxyCodeLine{02343\ }
\DoxyCodeLine{02344\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02345\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>\ \{}
\DoxyCodeLine{02346\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02347\ \ \ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<}
\DoxyCodeLine{02348\ \ \ \ \ \ \ \ \ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)>\ ContainerView;}
\DoxyCodeLine{02349\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ std::iterator\_traits<}
\DoxyCodeLine{02350\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ ContainerView::type::const\_iterator>::difference\_type}
\DoxyCodeLine{02351\ \ \ \ \ \ \ \ \ DistanceType;}
\DoxyCodeLine{02352\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ DistanceMatcher\&\ distance\_matcher)}
\DoxyCodeLine{02353\ \ \ \ \ \ \ \ \ :\ distance\_matcher\_(MatcherCast<DistanceType>(distance\_matcher))\ \{\}}
\DoxyCodeLine{02354\ }
\DoxyCodeLine{02355\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02356\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}distance\ between\ begin()\ and\ end()\ "{}};}
\DoxyCodeLine{02357\ \ \ \ \ \ \ distance\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02358\ \ \ \ \ \}}
\DoxyCodeLine{02359\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02360\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}distance\ between\ begin()\ and\ end()\ "{}};}
\DoxyCodeLine{02361\ \ \ \ \ \ \ distance\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02362\ \ \ \ \ \}}
\DoxyCodeLine{02363\ }
\DoxyCodeLine{02364\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02365\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02366\ \ \ \ \ \ \ \textcolor{keyword}{using\ }std::begin;}
\DoxyCodeLine{02367\ \ \ \ \ \ \ \textcolor{keyword}{using\ }std::end;}
\DoxyCodeLine{02368\ \ \ \ \ \ \ DistanceType\ distance\ =\ std::distance(begin(container),\ end(container));}
\DoxyCodeLine{02369\ \ \ \ \ \ \ StringMatchResultListener\ distance\_listener;}
\DoxyCodeLine{02370\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ result\ =}
\DoxyCodeLine{02371\ \ \ \ \ \ \ \ \ \ \ distance\_matcher\_.MatchAndExplain(distance,\ \&distance\_listener);}
\DoxyCodeLine{02372\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ "{}}\ <<\ distance}
\DoxyCodeLine{02373\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (result\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{02374\ \ \ \ \ \ \ PrintIfNotEmpty(distance\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02375\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{02376\ \ \ \ \ \}}
\DoxyCodeLine{02377\ }
\DoxyCodeLine{02378\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02379\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<DistanceType>\ distance\_matcher\_;}
\DoxyCodeLine{02380\ \ \ \};}
\DoxyCodeLine{02381\ }
\DoxyCodeLine{02382\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02383\ \ \ \textcolor{keyword}{const}\ DistanceMatcher\ distance\_matcher\_;}
\DoxyCodeLine{02384\ \};}
\DoxyCodeLine{02385\ }
\DoxyCodeLine{02386\ \textcolor{comment}{//\ Implements\ an\ equality\ matcher\ for\ any\ STL-\/style\ container\ whose\ elements}}
\DoxyCodeLine{02387\ \textcolor{comment}{//\ support\ ==.\ This\ matcher\ is\ like\ Eq(),\ but\ its\ failure\ explanations\ provide}}
\DoxyCodeLine{02388\ \textcolor{comment}{//\ more\ detailed\ information\ that\ is\ useful\ when\ the\ container\ is\ used\ as\ a\ set.}}
\DoxyCodeLine{02389\ \textcolor{comment}{//\ The\ failure\ message\ reports\ elements\ that\ are\ in\ one\ of\ the\ operands\ but\ not}}
\DoxyCodeLine{02390\ \textcolor{comment}{//\ the\ other.\ The\ failure\ messages\ do\ not\ report\ duplicate\ or\ out-\/of-\/order}}
\DoxyCodeLine{02391\ \textcolor{comment}{//\ elements\ in\ the\ containers\ (which\ don't\ properly\ matter\ to\ sets,\ but\ can}}
\DoxyCodeLine{02392\ \textcolor{comment}{//\ occur\ if\ the\ containers\ are\ vectors\ or\ lists,\ for\ example).}}
\DoxyCodeLine{02393\ \textcolor{comment}{//}}
\DoxyCodeLine{02394\ \textcolor{comment}{//\ Uses\ the\ container's\ const\_iterator,\ value\_type,\ operator\ ==,}}
\DoxyCodeLine{02395\ \textcolor{comment}{//\ begin(),\ and\ end().}}
\DoxyCodeLine{02396\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02397\ \textcolor{keyword}{class\ }ContainerEqMatcher\ \{}
\DoxyCodeLine{02398\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02399\ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<Container>\ View;}
\DoxyCodeLine{02400\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::type\ StlContainer;}
\DoxyCodeLine{02401\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::const\_reference\ StlContainerReference;}
\DoxyCodeLine{02402\ }
\DoxyCodeLine{02403\ \ \ \textcolor{keyword}{static\_assert}(!std::is\_const<Container>::value,}
\DoxyCodeLine{02404\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Container\ type\ must\ not\ be\ const"{}});}
\DoxyCodeLine{02405\ \ \ \textcolor{keyword}{static\_assert}(!std::is\_reference<Container>::value,}
\DoxyCodeLine{02406\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Container\ type\ must\ not\ be\ a\ reference"{}});}
\DoxyCodeLine{02407\ }
\DoxyCodeLine{02408\ \ \ \textcolor{comment}{//\ We\ make\ a\ copy\ of\ expected\ in\ case\ the\ elements\ in\ it\ are\ modified}}
\DoxyCodeLine{02409\ \ \ \textcolor{comment}{//\ after\ this\ matcher\ is\ created.}}
\DoxyCodeLine{02410\ \ \ \textcolor{keyword}{explicit}\ ContainerEqMatcher(\textcolor{keyword}{const}\ Container\&\ expected)}
\DoxyCodeLine{02411\ \ \ \ \ \ \ :\ expected\_(View::Copy(expected))\ \{\}}
\DoxyCodeLine{02412\ }
\DoxyCodeLine{02413\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02414\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}equals\ "{}};}
\DoxyCodeLine{02415\ \ \ \ \ UniversalPrint(expected\_,\ os);}
\DoxyCodeLine{02416\ \ \ \}}
\DoxyCodeLine{02417\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02418\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ equal\ "{}};}
\DoxyCodeLine{02419\ \ \ \ \ UniversalPrint(expected\_,\ os);}
\DoxyCodeLine{02420\ \ \ \}}
\DoxyCodeLine{02421\ }
\DoxyCodeLine{02422\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02423\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ LhsContainer\&\ lhs,}
\DoxyCodeLine{02424\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02425\ \ \ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<}
\DoxyCodeLine{02426\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_const<LhsContainer>::type>}
\DoxyCodeLine{02427\ \ \ \ \ \ \ \ \ LhsView;}
\DoxyCodeLine{02428\ \ \ \ \ StlContainerReference\ lhs\_stl\_container\ =\ LhsView::ConstReference(lhs);}
\DoxyCodeLine{02429\ \ \ \ \ \textcolor{keywordflow}{if}\ (lhs\_stl\_container\ ==\ expected\_)}
\DoxyCodeLine{02430\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02431\ }
\DoxyCodeLine{02432\ \ \ \ \ ::std::ostream*\ \textcolor{keyword}{const}\ os\ =\ listener-\/>stream();}
\DoxyCodeLine{02433\ \ \ \ \ \textcolor{keywordflow}{if}\ (os\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{02434\ \ \ \ \ \ \ \textcolor{comment}{//\ Something\ is\ different.\ Check\ for\ extra\ values\ first.}}
\DoxyCodeLine{02435\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ printed\_header\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{02436\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ lhs\_stl\_container.begin();}
\DoxyCodeLine{02437\ \ \ \ \ \ \ \ \ \ \ \ it\ !=\ lhs\_stl\_container.end();\ ++it)\ \{}
\DoxyCodeLine{02438\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (internal::ArrayAwareFind(expected\_.begin(),\ expected\_.end(),\ *it)\ ==}
\DoxyCodeLine{02439\ \ \ \ \ \ \ \ \ \ \ \ \ expected\_.end())\ \{}
\DoxyCodeLine{02440\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (printed\_header)\ \{}
\DoxyCodeLine{02441\ \ \ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02442\ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02443\ \ \ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}which\ has\ these\ unexpected\ elements:\ "{}};}
\DoxyCodeLine{02444\ \ \ \ \ \ \ \ \ \ \ \ \ printed\_header\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{02445\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02446\ \ \ \ \ \ \ \ \ \ \ UniversalPrint(*it,\ os);}
\DoxyCodeLine{02447\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02448\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02449\ }
\DoxyCodeLine{02450\ \ \ \ \ \ \ \textcolor{comment}{//\ Now\ check\ for\ missing\ values.}}
\DoxyCodeLine{02451\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ printed\_header2\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{02452\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ expected\_.begin();}
\DoxyCodeLine{02453\ \ \ \ \ \ \ \ \ \ \ \ it\ !=\ expected\_.end();\ ++it)\ \{}
\DoxyCodeLine{02454\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (internal::ArrayAwareFind(}
\DoxyCodeLine{02455\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lhs\_stl\_container.begin(),\ lhs\_stl\_container.end(),\ *it)\ ==}
\DoxyCodeLine{02456\ \ \ \ \ \ \ \ \ \ \ \ \ lhs\_stl\_container.end())\ \{}
\DoxyCodeLine{02457\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (printed\_header2)\ \{}
\DoxyCodeLine{02458\ \ \ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02459\ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02460\ \ \ \ \ \ \ \ \ \ \ \ \ *os\ <<\ (printed\_header\ ?\ \textcolor{stringliteral}{"{},\(\backslash\)nand"{}}\ :\ \textcolor{stringliteral}{"{}which"{}})}
\DoxyCodeLine{02461\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ doesn't\ have\ these\ expected\ elements:\ "{}};}
\DoxyCodeLine{02462\ \ \ \ \ \ \ \ \ \ \ \ \ printed\_header2\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{02463\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02464\ \ \ \ \ \ \ \ \ \ \ UniversalPrint(*it,\ os);}
\DoxyCodeLine{02465\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02466\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02467\ \ \ \ \ \}}
\DoxyCodeLine{02468\ }
\DoxyCodeLine{02469\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02470\ \ \ \}}
\DoxyCodeLine{02471\ }
\DoxyCodeLine{02472\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02473\ \ \ \textcolor{keyword}{const}\ StlContainer\ expected\_;}
\DoxyCodeLine{02474\ \};}
\DoxyCodeLine{02475\ }
\DoxyCodeLine{02476\ \textcolor{comment}{//\ A\ comparator\ functor\ that\ uses\ the\ <\ operator\ to\ compare\ two\ values.}}
\DoxyCodeLine{02477\ \textcolor{keyword}{struct\ }LessComparator\ \{}
\DoxyCodeLine{02478\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{02479\ \ \ \textcolor{keywordtype}{bool}\ operator()(\textcolor{keyword}{const}\ T\&\ lhs,\ \textcolor{keyword}{const}\ U\&\ rhs)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ lhs\ <\ rhs;\ \}}
\DoxyCodeLine{02480\ \};}
\DoxyCodeLine{02481\ }
\DoxyCodeLine{02482\ \textcolor{comment}{//\ Implements\ WhenSortedBy(comparator,\ container\_matcher).}}
\DoxyCodeLine{02483\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Comparator,\ \textcolor{keyword}{typename}\ ContainerMatcher>}
\DoxyCodeLine{02484\ \textcolor{keyword}{class\ }WhenSortedByMatcher\ \{}
\DoxyCodeLine{02485\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02486\ \ \ WhenSortedByMatcher(\textcolor{keyword}{const}\ Comparator\&\ comparator,}
\DoxyCodeLine{02487\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ContainerMatcher\&\ matcher)}
\DoxyCodeLine{02488\ \ \ \ \ \ \ :\ comparator\_(comparator),\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{02489\ }
\DoxyCodeLine{02490\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02491\ \ \ \textcolor{keyword}{operator}\ Matcher<LhsContainer>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02492\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ Impl<LhsContainer>(comparator\_,\ matcher\_));}
\DoxyCodeLine{02493\ \ \ \}}
\DoxyCodeLine{02494\ }
\DoxyCodeLine{02495\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02496\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<LhsContainer>\ \{}
\DoxyCodeLine{02497\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02498\ \ \ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<}
\DoxyCodeLine{02499\ \ \ \ \ \ \ \ \ \ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(LhsContainer)>\ LhsView;}
\DoxyCodeLine{02500\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsView::type\ LhsStlContainer;}
\DoxyCodeLine{02501\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsView::const\_reference\ LhsStlContainerReference;}
\DoxyCodeLine{02502\ \ \ \ \ \textcolor{comment}{//\ Transforms\ std::pair<const\ Key,\ Value>\ into\ std::pair<Key,\ Value>}}
\DoxyCodeLine{02503\ \ \ \ \ \textcolor{comment}{//\ so\ that\ we\ can\ match\ associative\ containers.}}
\DoxyCodeLine{02504\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RemoveConstFromKey<}
\DoxyCodeLine{02505\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ LhsStlContainer::value\_type>::type\ LhsValue;}
\DoxyCodeLine{02506\ }
\DoxyCodeLine{02507\ \ \ \ \ Impl(\textcolor{keyword}{const}\ Comparator\&\ comparator,\ \textcolor{keyword}{const}\ ContainerMatcher\&\ matcher)}
\DoxyCodeLine{02508\ \ \ \ \ \ \ \ \ :\ comparator\_(comparator),\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{02509\ }
\DoxyCodeLine{02510\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02511\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}(when\ sorted)\ "{}};}
\DoxyCodeLine{02512\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{02513\ \ \ \ \ \}}
\DoxyCodeLine{02514\ }
\DoxyCodeLine{02515\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02516\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}(when\ sorted)\ "{}};}
\DoxyCodeLine{02517\ \ \ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02518\ \ \ \ \ \}}
\DoxyCodeLine{02519\ }
\DoxyCodeLine{02520\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(LhsContainer\ lhs,}
\DoxyCodeLine{02521\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02522\ \ \ \ \ \ \ LhsStlContainerReference\ lhs\_stl\_container\ =\ LhsView::ConstReference(lhs);}
\DoxyCodeLine{02523\ \ \ \ \ \ \ ::std::vector<LhsValue>\ sorted\_container(lhs\_stl\_container.begin(),}
\DoxyCodeLine{02524\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lhs\_stl\_container.end());}
\DoxyCodeLine{02525\ \ \ \ \ \ \ ::std::sort(}
\DoxyCodeLine{02526\ \ \ \ \ \ \ \ \ \ \ \ sorted\_container.begin(),\ sorted\_container.end(),\ comparator\_);}
\DoxyCodeLine{02527\ }
\DoxyCodeLine{02528\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{02529\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ listener\ is\ not\ interested,\ we\ do\ not\ need\ to}}
\DoxyCodeLine{02530\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ construct\ the\ inner\ explanation.}}
\DoxyCodeLine{02531\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ matcher\_.Matches(sorted\_container);}
\DoxyCodeLine{02532\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02533\ }
\DoxyCodeLine{02534\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ "{}};}
\DoxyCodeLine{02535\ \ \ \ \ \ \ UniversalPrint(sorted\_container,\ listener-\/>stream());}
\DoxyCodeLine{02536\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ when\ sorted"{}};}
\DoxyCodeLine{02537\ }
\DoxyCodeLine{02538\ \ \ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02539\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ matcher\_.MatchAndExplain(sorted\_container,}
\DoxyCodeLine{02540\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&inner\_listener);}
\DoxyCodeLine{02541\ \ \ \ \ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02542\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{02543\ \ \ \ \ \}}
\DoxyCodeLine{02544\ }
\DoxyCodeLine{02545\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02546\ \ \ \ \ \textcolor{keyword}{const}\ Comparator\ comparator\_;}
\DoxyCodeLine{02547\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ ::std::vector<LhsValue>\&>\ matcher\_;}
\DoxyCodeLine{02548\ }
\DoxyCodeLine{02549\ \ \ \ \ GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(Impl);}
\DoxyCodeLine{02550\ \ \ \};}
\DoxyCodeLine{02551\ }
\DoxyCodeLine{02552\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02553\ \ \ \textcolor{keyword}{const}\ Comparator\ comparator\_;}
\DoxyCodeLine{02554\ \ \ \textcolor{keyword}{const}\ ContainerMatcher\ matcher\_;}
\DoxyCodeLine{02555\ \};}
\DoxyCodeLine{02556\ }
\DoxyCodeLine{02557\ \textcolor{comment}{//\ Implements\ Pointwise(tuple\_matcher,\ rhs\_container).\ \ tuple\_matcher}}
\DoxyCodeLine{02558\ \textcolor{comment}{//\ must\ be\ able\ to\ be\ safely\ cast\ to\ Matcher<std::tuple<const\ T1\&,\ const}}
\DoxyCodeLine{02559\ \textcolor{comment}{//\ T2\&>\ >,\ where\ T1\ and\ T2\ are\ the\ types\ of\ elements\ in\ the\ LHS}}
\DoxyCodeLine{02560\ \textcolor{comment}{//\ container\ and\ the\ RHS\ container\ respectively.}}
\DoxyCodeLine{02561\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ TupleMatcher,\ \textcolor{keyword}{typename}\ RhsContainer>}
\DoxyCodeLine{02562\ \textcolor{keyword}{class\ }PointwiseMatcher\ \{}
\DoxyCodeLine{02563\ \ \ GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{02564\ \ \ \ \ \ \ !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(RhsContainer)>::value,}
\DoxyCodeLine{02565\ \ \ \ \ \ \ use\_UnorderedPointwise\_with\_hash\_tables);}
\DoxyCodeLine{02566\ }
\DoxyCodeLine{02567\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02568\ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<RhsContainer>\ RhsView;}
\DoxyCodeLine{02569\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RhsView::type\ RhsStlContainer;}
\DoxyCodeLine{02570\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RhsStlContainer::value\_type\ RhsValue;}
\DoxyCodeLine{02571\ }
\DoxyCodeLine{02572\ \ \ \textcolor{keyword}{static\_assert}(!std::is\_const<RhsContainer>::value,}
\DoxyCodeLine{02573\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}RhsContainer\ type\ must\ not\ be\ const"{}});}
\DoxyCodeLine{02574\ \ \ \textcolor{keyword}{static\_assert}(!std::is\_reference<RhsContainer>::value,}
\DoxyCodeLine{02575\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}RhsContainer\ type\ must\ not\ be\ a\ reference"{}});}
\DoxyCodeLine{02576\ }
\DoxyCodeLine{02577\ \ \ \textcolor{comment}{//\ Like\ ContainerEq,\ we\ make\ a\ copy\ of\ rhs\ in\ case\ the\ elements\ in}}
\DoxyCodeLine{02578\ \ \ \textcolor{comment}{//\ it\ are\ modified\ after\ this\ matcher\ is\ created.}}
\DoxyCodeLine{02579\ \ \ PointwiseMatcher(\textcolor{keyword}{const}\ TupleMatcher\&\ tuple\_matcher,\ \textcolor{keyword}{const}\ RhsContainer\&\ rhs)}
\DoxyCodeLine{02580\ \ \ \ \ \ \ :\ tuple\_matcher\_(tuple\_matcher),\ rhs\_(RhsView::Copy(rhs))\ \{\}}
\DoxyCodeLine{02581\ }
\DoxyCodeLine{02582\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02583\ \ \ \textcolor{keyword}{operator}\ Matcher<LhsContainer>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02584\ \ \ \ \ GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{02585\ \ \ \ \ \ \ \ \ !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(LhsContainer)>::value,}
\DoxyCodeLine{02586\ \ \ \ \ \ \ \ \ use\_UnorderedPointwise\_with\_hash\_tables);}
\DoxyCodeLine{02587\ }
\DoxyCodeLine{02588\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<LhsContainer>(}
\DoxyCodeLine{02589\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ Impl<const\ LhsContainer\&>(tuple\_matcher\_,\ rhs\_));}
\DoxyCodeLine{02590\ \ \ \}}
\DoxyCodeLine{02591\ }
\DoxyCodeLine{02592\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ LhsContainer>}
\DoxyCodeLine{02593\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<LhsContainer>\ \{}
\DoxyCodeLine{02594\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02595\ \ \ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<}
\DoxyCodeLine{02596\ \ \ \ \ \ \ \ \ \ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(LhsContainer)>\ LhsView;}
\DoxyCodeLine{02597\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsView::type\ LhsStlContainer;}
\DoxyCodeLine{02598\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsView::const\_reference\ LhsStlContainerReference;}
\DoxyCodeLine{02599\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ LhsStlContainer::value\_type\ LhsValue;}
\DoxyCodeLine{02600\ \ \ \ \ \textcolor{comment}{//\ We\ pass\ the\ LHS\ value\ and\ the\ RHS\ value\ to\ the\ inner\ matcher\ by}}
\DoxyCodeLine{02601\ \ \ \ \ \textcolor{comment}{//\ reference,\ as\ they\ may\ be\ expensive\ to\ copy.\ \ We\ must\ use\ tuple}}
\DoxyCodeLine{02602\ \ \ \ \ \textcolor{comment}{//\ instead\ of\ pair\ here,\ as\ a\ pair\ cannot\ hold\ references\ (C++\ 98,}}
\DoxyCodeLine{02603\ \ \ \ \ \textcolor{comment}{//\ 20.2.2\ [lib.pairs]).}}
\DoxyCodeLine{02604\ \ \ \ \ typedef\ ::std::tuple<const\ LhsValue\&,\ const\ RhsValue\&>\ InnerMatcherArg;}
\DoxyCodeLine{02605\ }
\DoxyCodeLine{02606\ \ \ \ \ Impl(\textcolor{keyword}{const}\ TupleMatcher\&\ tuple\_matcher,\ \textcolor{keyword}{const}\ RhsStlContainer\&\ rhs)}
\DoxyCodeLine{02607\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ mono\_tuple\_matcher\_\ holds\ a\ monomorphic\ version\ of\ the\ tuple\ matcher.}}
\DoxyCodeLine{02608\ \ \ \ \ \ \ \ \ :\ mono\_tuple\_matcher\_(SafeMatcherCast<InnerMatcherArg>(tuple\_matcher)),}
\DoxyCodeLine{02609\ \ \ \ \ \ \ \ \ \ \ rhs\_(rhs)\ \{\}}
\DoxyCodeLine{02610\ }
\DoxyCodeLine{02611\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02612\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ "{}}\ <<\ rhs\_.size()}
\DoxyCodeLine{02613\ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ values,\ where\ each\ value\ and\ its\ corresponding\ value\ in\ "{}};}
\DoxyCodeLine{02614\ \ \ \ \ \ \ UniversalPrinter<RhsStlContainer>::Print(rhs\_,\ os);}
\DoxyCodeLine{02615\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02616\ \ \ \ \ \ \ mono\_tuple\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02617\ \ \ \ \ \}}
\DoxyCodeLine{02618\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02619\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ contain\ exactly\ "{}}\ <<\ rhs\_.size()}
\DoxyCodeLine{02620\ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ values,\ or\ contains\ a\ value\ x\ at\ some\ index\ i"{}}}
\DoxyCodeLine{02621\ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ where\ x\ and\ the\ i-\/th\ value\ of\ "{}};}
\DoxyCodeLine{02622\ \ \ \ \ \ \ UniversalPrint(rhs\_,\ os);}
\DoxyCodeLine{02623\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02624\ \ \ \ \ \ \ mono\_tuple\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02625\ \ \ \ \ \}}
\DoxyCodeLine{02626\ }
\DoxyCodeLine{02627\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(LhsContainer\ lhs,}
\DoxyCodeLine{02628\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02629\ \ \ \ \ \ \ LhsStlContainerReference\ lhs\_stl\_container\ =\ LhsView::ConstReference(lhs);}
\DoxyCodeLine{02630\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ actual\_size\ =\ lhs\_stl\_container.size();}
\DoxyCodeLine{02631\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (actual\_size\ !=\ rhs\_.size())\ \{}
\DoxyCodeLine{02632\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ contains\ "{}}\ <<\ actual\_size\ <<\ \textcolor{stringliteral}{"{}\ values"{}};}
\DoxyCodeLine{02633\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02634\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02635\ }
\DoxyCodeLine{02636\ \ \ \ \ \ \ \textcolor{keyword}{auto}\ left\ =\ lhs\_stl\_container.begin();}
\DoxyCodeLine{02637\ \ \ \ \ \ \ \textcolor{keyword}{auto}\ right\ =\ rhs\_.begin();}
\DoxyCodeLine{02638\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ actual\_size;\ ++i,\ ++left,\ ++right)\ \{}
\DoxyCodeLine{02639\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>IsInterested())\ \{}
\DoxyCodeLine{02640\ \ \ \ \ \ \ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02641\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Create\ InnerMatcherArg\ as\ a\ temporarily\ object\ to\ avoid\ it\ outlives}}
\DoxyCodeLine{02642\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ *left\ and\ *right.\ Dereference\ or\ the\ conversion\ to\ \`{}const\ T\&`\ may}}
\DoxyCodeLine{02643\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ return\ temp\ objects,\ e.g.\ for\ vector<bool>.}}
\DoxyCodeLine{02644\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!mono\_tuple\_matcher\_.MatchAndExplain(}
\DoxyCodeLine{02645\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InnerMatcherArg(ImplicitCast\_<const\ LhsValue\&>(*left),}
\DoxyCodeLine{02646\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ImplicitCast\_<const\ RhsValue\&>(*right)),}
\DoxyCodeLine{02647\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&inner\_listener))\ \{}
\DoxyCodeLine{02648\ \ \ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}where\ the\ value\ pair\ ("{}};}
\DoxyCodeLine{02649\ \ \ \ \ \ \ \ \ \ \ \ \ UniversalPrint(*left,\ listener-\/>stream());}
\DoxyCodeLine{02650\ \ \ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02651\ \ \ \ \ \ \ \ \ \ \ \ \ UniversalPrint(*right,\ listener-\/>stream());}
\DoxyCodeLine{02652\ \ \ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{})\ at\ index\ \#"{}}\ <<\ i\ <<\ \textcolor{stringliteral}{"{}\ don't\ match"{}};}
\DoxyCodeLine{02653\ \ \ \ \ \ \ \ \ \ \ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02654\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02655\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02656\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02657\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!mono\_tuple\_matcher\_.Matches(}
\DoxyCodeLine{02658\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InnerMatcherArg(ImplicitCast\_<const\ LhsValue\&>(*left),}
\DoxyCodeLine{02659\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ImplicitCast\_<const\ RhsValue\&>(*right))))}
\DoxyCodeLine{02660\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02661\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02662\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02663\ }
\DoxyCodeLine{02664\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02665\ \ \ \ \ \}}
\DoxyCodeLine{02666\ }
\DoxyCodeLine{02667\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02668\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<InnerMatcherArg>\ mono\_tuple\_matcher\_;}
\DoxyCodeLine{02669\ \ \ \ \ \textcolor{keyword}{const}\ RhsStlContainer\ rhs\_;}
\DoxyCodeLine{02670\ \ \ \};}
\DoxyCodeLine{02671\ }
\DoxyCodeLine{02672\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02673\ \ \ \textcolor{keyword}{const}\ TupleMatcher\ tuple\_matcher\_;}
\DoxyCodeLine{02674\ \ \ \textcolor{keyword}{const}\ RhsStlContainer\ rhs\_;}
\DoxyCodeLine{02675\ \};}
\DoxyCodeLine{02676\ }
\DoxyCodeLine{02677\ \textcolor{comment}{//\ Holds\ the\ logic\ common\ to\ ContainsMatcherImpl\ and\ EachMatcherImpl.}}
\DoxyCodeLine{02678\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02679\ \textcolor{keyword}{class\ }QuantifierMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>\ \{}
\DoxyCodeLine{02680\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02681\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{02682\ \ \ \textcolor{keyword}{typedef}\ StlContainerView<RawContainer>\ View;}
\DoxyCodeLine{02683\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::type\ StlContainer;}
\DoxyCodeLine{02684\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::const\_reference\ StlContainerReference;}
\DoxyCodeLine{02685\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ StlContainer::value\_type\ Element;}
\DoxyCodeLine{02686\ }
\DoxyCodeLine{02687\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02688\ \ \ \textcolor{keyword}{explicit}\ QuantifierMatcherImpl(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{02689\ \ \ \ \ \ \ :\ inner\_matcher\_(}
\DoxyCodeLine{02690\ \ \ \ \ \ \ \ \ \ \ \ testing::SafeMatcherCast<const\ Element\&>(inner\_matcher))\ \{\}}
\DoxyCodeLine{02691\ }
\DoxyCodeLine{02692\ \ \ \textcolor{comment}{//\ Checks\ whether:}}
\DoxyCodeLine{02693\ \ \ \textcolor{comment}{//\ *\ All\ elements\ in\ the\ container\ match,\ if\ all\_elements\_should\_match.}}
\DoxyCodeLine{02694\ \ \ \textcolor{comment}{//\ *\ Any\ element\ in\ the\ container\ matches,\ if\ !all\_elements\_should\_match.}}
\DoxyCodeLine{02695\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(\textcolor{keywordtype}{bool}\ all\_elements\_should\_match,}
\DoxyCodeLine{02696\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Container\ container,}
\DoxyCodeLine{02697\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02698\ \ \ \ \ StlContainerReference\ stl\_container\ =\ View::ConstReference(container);}
\DoxyCodeLine{02699\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ i\ =\ 0;}
\DoxyCodeLine{02700\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ stl\_container.begin();}
\DoxyCodeLine{02701\ \ \ \ \ \ \ \ \ \ it\ !=\ stl\_container.end();\ ++it,\ ++i)\ \{}
\DoxyCodeLine{02702\ \ \ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02703\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ matches\ =\ inner\_matcher\_.MatchAndExplain(*it,\ \&inner\_listener);}
\DoxyCodeLine{02704\ }
\DoxyCodeLine{02705\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matches\ !=\ all\_elements\_should\_match)\ \{}
\DoxyCodeLine{02706\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ element\ \#"{}}\ <<\ i}
\DoxyCodeLine{02707\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (matches\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{02708\ \ \ \ \ \ \ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02709\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ !all\_elements\_should\_match;}
\DoxyCodeLine{02710\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02711\ \ \ \ \ \}}
\DoxyCodeLine{02712\ \ \ \ \ \textcolor{keywordflow}{return}\ all\_elements\_should\_match;}
\DoxyCodeLine{02713\ \ \ \}}
\DoxyCodeLine{02714\ }
\DoxyCodeLine{02715\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplainImpl(\textcolor{keyword}{const}\ Matcher<size\_t>\&\ count\_matcher,}
\DoxyCodeLine{02716\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Container\ container,}
\DoxyCodeLine{02717\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02718\ \ \ \ \ StlContainerReference\ stl\_container\ =\ View::ConstReference(container);}
\DoxyCodeLine{02719\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ i\ =\ 0;}
\DoxyCodeLine{02720\ \ \ \ \ std::vector<size\_t>\ match\_elements;}
\DoxyCodeLine{02721\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ stl\_container.begin();\ it\ !=\ stl\_container.end();}
\DoxyCodeLine{02722\ \ \ \ \ \ \ \ \ \ ++it,\ ++i)\ \{}
\DoxyCodeLine{02723\ \ \ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02724\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ matches\ =\ inner\_matcher\_.MatchAndExplain(*it,\ \&inner\_listener);}
\DoxyCodeLine{02725\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matches)\ \{}
\DoxyCodeLine{02726\ \ \ \ \ \ \ \ \ match\_elements.push\_back(i);}
\DoxyCodeLine{02727\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02728\ \ \ \ \ \}}
\DoxyCodeLine{02729\ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>IsInterested())\ \{}
\DoxyCodeLine{02730\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (match\_elements.empty())\ \{}
\DoxyCodeLine{02731\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}has\ no\ element\ that\ matches"{}};}
\DoxyCodeLine{02732\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (match\_elements.size()\ ==\ 1)\ \{}
\DoxyCodeLine{02733\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ element\ \#"{}}\ <<\ match\_elements[0]\ <<\ \textcolor{stringliteral}{"{}\ matches"{}};}
\DoxyCodeLine{02734\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02735\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ elements\ ("{}};}
\DoxyCodeLine{02736\ \ \ \ \ \ \ \ \ std::string\ sep\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{02737\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ e\ :\ match\_elements)\ \{}
\DoxyCodeLine{02738\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ sep\ <<\ e;}
\DoxyCodeLine{02739\ \ \ \ \ \ \ \ \ \ \ sep\ =\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{02740\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02741\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{})\ match"{}};}
\DoxyCodeLine{02742\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02743\ \ \ \ \ \}}
\DoxyCodeLine{02744\ \ \ \ \ StringMatchResultListener\ count\_listener;}
\DoxyCodeLine{02745\ \ \ \ \ \textcolor{keywordflow}{if}\ (count\_matcher.MatchAndExplain(match\_elements.size(),\ \&count\_listener))\ \{}
\DoxyCodeLine{02746\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ and\ whose\ match\ quantity\ of\ "{}}\ <<\ match\_elements.size()}
\DoxyCodeLine{02747\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ matches"{}};}
\DoxyCodeLine{02748\ \ \ \ \ \ \ PrintIfNotEmpty(count\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02749\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{02750\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02751\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (match\_elements.empty())\ \{}
\DoxyCodeLine{02752\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ and"{}};}
\DoxyCodeLine{02753\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02754\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ but"{}};}
\DoxyCodeLine{02755\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02756\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ whose\ match\ quantity\ of\ "{}}\ <<\ match\_elements.size()}
\DoxyCodeLine{02757\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ does\ not\ match"{}};}
\DoxyCodeLine{02758\ \ \ \ \ \ \ PrintIfNotEmpty(count\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{02759\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{02760\ \ \ \ \ \}}
\DoxyCodeLine{02761\ \ \ \}}
\DoxyCodeLine{02762\ }
\DoxyCodeLine{02763\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{02764\ \ \ \textcolor{keyword}{const}\ Matcher<const\ Element\&>\ inner\_matcher\_;}
\DoxyCodeLine{02765\ \};}
\DoxyCodeLine{02766\ }
\DoxyCodeLine{02767\ \textcolor{comment}{//\ Implements\ Contains(element\_matcher)\ for\ the\ given\ argument\ type\ Container.}}
\DoxyCodeLine{02768\ \textcolor{comment}{//\ Symmetric\ to\ EachMatcherImpl.}}
\DoxyCodeLine{02769\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02770\ \textcolor{keyword}{class\ }ContainsMatcherImpl\ :\ \textcolor{keyword}{public}\ QuantifierMatcherImpl<Container>\ \{}
\DoxyCodeLine{02771\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02772\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02773\ \ \ \textcolor{keyword}{explicit}\ ContainsMatcherImpl(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{02774\ \ \ \ \ \ \ :\ QuantifierMatcherImpl<Container>(inner\_matcher)\ \{\}}
\DoxyCodeLine{02775\ }
\DoxyCodeLine{02776\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{02777\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02778\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ at\ least\ one\ element\ that\ "{}};}
\DoxyCodeLine{02779\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02780\ \ \ \}}
\DoxyCodeLine{02781\ }
\DoxyCodeLine{02782\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02783\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ contain\ any\ element\ that\ "{}};}
\DoxyCodeLine{02784\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02785\ \ \ \}}
\DoxyCodeLine{02786\ }
\DoxyCodeLine{02787\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02788\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02789\ \ \ \ \ \textcolor{keywordflow}{return}\ this-\/>MatchAndExplainImpl(\textcolor{keyword}{false},\ container,\ listener);}
\DoxyCodeLine{02790\ \ \ \}}
\DoxyCodeLine{02791\ \};}
\DoxyCodeLine{02792\ }
\DoxyCodeLine{02793\ \textcolor{comment}{//\ Implements\ Each(element\_matcher)\ for\ the\ given\ argument\ type\ Container.}}
\DoxyCodeLine{02794\ \textcolor{comment}{//\ Symmetric\ to\ ContainsMatcherImpl.}}
\DoxyCodeLine{02795\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02796\ \textcolor{keyword}{class\ }EachMatcherImpl\ :\ \textcolor{keyword}{public}\ QuantifierMatcherImpl<Container>\ \{}
\DoxyCodeLine{02797\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02798\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02799\ \ \ \textcolor{keyword}{explicit}\ EachMatcherImpl(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{02800\ \ \ \ \ \ \ :\ QuantifierMatcherImpl<Container>(inner\_matcher)\ \{\}}
\DoxyCodeLine{02801\ }
\DoxyCodeLine{02802\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{02803\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02804\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}only\ contains\ elements\ that\ "{}};}
\DoxyCodeLine{02805\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02806\ \ \ \}}
\DoxyCodeLine{02807\ }
\DoxyCodeLine{02808\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02809\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ some\ element\ that\ "{}};}
\DoxyCodeLine{02810\ \ \ \ \ this-\/>inner\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02811\ \ \ \}}
\DoxyCodeLine{02812\ }
\DoxyCodeLine{02813\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02814\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02815\ \ \ \ \ \textcolor{keywordflow}{return}\ this-\/>MatchAndExplainImpl(\textcolor{keyword}{true},\ container,\ listener);}
\DoxyCodeLine{02816\ \ \ \}}
\DoxyCodeLine{02817\ \};}
\DoxyCodeLine{02818\ }
\DoxyCodeLine{02819\ \textcolor{comment}{//\ Implements\ Contains(element\_matcher).Times(n)\ for\ the\ given\ argument\ type}}
\DoxyCodeLine{02820\ \textcolor{comment}{//\ Container.}}
\DoxyCodeLine{02821\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02822\ \textcolor{keyword}{class\ }ContainsTimesMatcherImpl\ :\ \textcolor{keyword}{public}\ QuantifierMatcherImpl<Container>\ \{}
\DoxyCodeLine{02823\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02824\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02825\ \ \ \textcolor{keyword}{explicit}\ ContainsTimesMatcherImpl(InnerMatcher\ inner\_matcher,}
\DoxyCodeLine{02826\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Matcher<size\_t>\ count\_matcher)}
\DoxyCodeLine{02827\ \ \ \ \ \ \ :\ QuantifierMatcherImpl<Container>(inner\_matcher),}
\DoxyCodeLine{02828\ \ \ \ \ \ \ \ \ count\_matcher\_(std::move(count\_matcher))\ \{\}}
\DoxyCodeLine{02829\ }
\DoxyCodeLine{02830\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02831\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}quantity\ of\ elements\ that\ match\ "{}};}
\DoxyCodeLine{02832\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02833\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02834\ \ \ \ \ count\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02835\ \ \ \}}
\DoxyCodeLine{02836\ }
\DoxyCodeLine{02837\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02838\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}quantity\ of\ elements\ that\ match\ "{}};}
\DoxyCodeLine{02839\ \ \ \ \ this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02840\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{02841\ \ \ \ \ count\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{02842\ \ \ \}}
\DoxyCodeLine{02843\ }
\DoxyCodeLine{02844\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{02845\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02846\ \ \ \ \ \textcolor{keywordflow}{return}\ this-\/>MatchAndExplainImpl(count\_matcher\_,\ container,\ listener);}
\DoxyCodeLine{02847\ \ \ \}}
\DoxyCodeLine{02848\ }
\DoxyCodeLine{02849\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02850\ \ \ \textcolor{keyword}{const}\ Matcher<size\_t>\ count\_matcher\_;}
\DoxyCodeLine{02851\ \};}
\DoxyCodeLine{02852\ }
\DoxyCodeLine{02853\ \textcolor{comment}{//\ Implements\ polymorphic\ Contains(element\_matcher).Times(n).}}
\DoxyCodeLine{02854\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{02855\ \textcolor{keyword}{class\ }ContainsTimesMatcher\ \{}
\DoxyCodeLine{02856\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02857\ \ \ \textcolor{keyword}{explicit}\ ContainsTimesMatcher(M\ m,\ Matcher<size\_t>\ count\_matcher)}
\DoxyCodeLine{02858\ \ \ \ \ \ \ :\ inner\_matcher\_(m),\ count\_matcher\_(std::move(count\_matcher))\ \{\}}
\DoxyCodeLine{02859\ }
\DoxyCodeLine{02860\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02861\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02862\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ ContainsTimesMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{02863\ \ \ \ \ \ \ \ \ inner\_matcher\_,\ count\_matcher\_));}
\DoxyCodeLine{02864\ \ \ \}}
\DoxyCodeLine{02865\ }
\DoxyCodeLine{02866\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02867\ \ \ \textcolor{keyword}{const}\ M\ inner\_matcher\_;}
\DoxyCodeLine{02868\ \ \ \textcolor{keyword}{const}\ Matcher<size\_t>\ count\_matcher\_;}
\DoxyCodeLine{02869\ \};}
\DoxyCodeLine{02870\ }
\DoxyCodeLine{02871\ \textcolor{comment}{//\ Implements\ polymorphic\ Contains(element\_matcher).}}
\DoxyCodeLine{02872\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{02873\ \textcolor{keyword}{class\ }ContainsMatcher\ \{}
\DoxyCodeLine{02874\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02875\ \ \ \textcolor{keyword}{explicit}\ ContainsMatcher(M\ m)\ :\ inner\_matcher\_(m)\ \{\}}
\DoxyCodeLine{02876\ }
\DoxyCodeLine{02877\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02878\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02879\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(}
\DoxyCodeLine{02880\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ ContainsMatcherImpl<const\ Container\&>(inner\_matcher\_));}
\DoxyCodeLine{02881\ \ \ \}}
\DoxyCodeLine{02882\ }
\DoxyCodeLine{02883\ \ \ ContainsTimesMatcher<M>\ Times(Matcher<size\_t>\ count\_matcher)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02884\ \ \ \ \ \textcolor{keywordflow}{return}\ ContainsTimesMatcher<M>(inner\_matcher\_,\ std::move(count\_matcher));}
\DoxyCodeLine{02885\ \ \ \}}
\DoxyCodeLine{02886\ }
\DoxyCodeLine{02887\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02888\ \ \ \textcolor{keyword}{const}\ M\ inner\_matcher\_;}
\DoxyCodeLine{02889\ \};}
\DoxyCodeLine{02890\ }
\DoxyCodeLine{02891\ \textcolor{comment}{//\ Implements\ polymorphic\ Each(element\_matcher).}}
\DoxyCodeLine{02892\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{02893\ \textcolor{keyword}{class\ }EachMatcher\ \{}
\DoxyCodeLine{02894\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02895\ \ \ \textcolor{keyword}{explicit}\ EachMatcher(M\ m)\ :\ inner\_matcher\_(m)\ \{\}}
\DoxyCodeLine{02896\ }
\DoxyCodeLine{02897\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{02898\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02899\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(}
\DoxyCodeLine{02900\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ EachMatcherImpl<const\ Container\&>(inner\_matcher\_));}
\DoxyCodeLine{02901\ \ \ \}}
\DoxyCodeLine{02902\ }
\DoxyCodeLine{02903\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02904\ \ \ \textcolor{keyword}{const}\ M\ inner\_matcher\_;}
\DoxyCodeLine{02905\ \};}
\DoxyCodeLine{02906\ }
\DoxyCodeLine{02907\ \textcolor{keyword}{struct\ }Rank1\ \{\};}
\DoxyCodeLine{02908\ \textcolor{keyword}{struct\ }Rank0\ :\ Rank1\ \{\};}
\DoxyCodeLine{02909\ }
\DoxyCodeLine{02910\ \textcolor{keyword}{namespace\ }pair\_getters\ \{}
\DoxyCodeLine{02911\ \textcolor{keyword}{using\ }std::get;}
\DoxyCodeLine{02912\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02913\ \textcolor{keyword}{auto}\ First(T\&\ x,\ Rank1)\ -\/>\ \textcolor{keyword}{decltype}(get<0>(x))\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02914\ \ \ \textcolor{keywordflow}{return}\ get<0>(x);}
\DoxyCodeLine{02915\ \}}
\DoxyCodeLine{02916\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02917\ \textcolor{keyword}{auto}\ First(T\&\ x,\ Rank0)\ -\/>\ \textcolor{keyword}{decltype}((x.first))\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02918\ \ \ \textcolor{keywordflow}{return}\ x.first;}
\DoxyCodeLine{02919\ \}}
\DoxyCodeLine{02920\ }
\DoxyCodeLine{02921\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02922\ \textcolor{keyword}{auto}\ Second(T\&\ x,\ Rank1)\ -\/>\ \textcolor{keyword}{decltype}(get<1>(x))\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02923\ \ \ \textcolor{keywordflow}{return}\ get<1>(x);}
\DoxyCodeLine{02924\ \}}
\DoxyCodeLine{02925\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{02926\ \textcolor{keyword}{auto}\ Second(T\&\ x,\ Rank0)\ -\/>\ \textcolor{keyword}{decltype}((x.second))\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02927\ \ \ \textcolor{keywordflow}{return}\ x.second;}
\DoxyCodeLine{02928\ \}}
\DoxyCodeLine{02929\ \}\ \ \textcolor{comment}{//\ namespace\ pair\_getters}}
\DoxyCodeLine{02930\ }
\DoxyCodeLine{02931\ \textcolor{comment}{//\ Implements\ Key(inner\_matcher)\ for\ the\ given\ argument\ pair\ type.}}
\DoxyCodeLine{02932\ \textcolor{comment}{//\ Key(inner\_matcher)\ matches\ an\ std::pair\ whose\ 'first'\ field\ matches}}
\DoxyCodeLine{02933\ \textcolor{comment}{//\ inner\_matcher.\ \ For\ example,\ Contains(Key(Ge(5)))\ can\ be\ used\ to\ match\ an}}
\DoxyCodeLine{02934\ \textcolor{comment}{//\ std::map\ that\ contains\ at\ least\ one\ element\ whose\ key\ is\ >=\ 5.}}
\DoxyCodeLine{02935\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PairType>}
\DoxyCodeLine{02936\ \textcolor{keyword}{class\ }KeyMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<PairType>\ \{}
\DoxyCodeLine{02937\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02938\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(PairType)\ RawPairType;}
\DoxyCodeLine{02939\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RawPairType::first\_type\ KeyType;}
\DoxyCodeLine{02940\ }
\DoxyCodeLine{02941\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02942\ \ \ \textcolor{keyword}{explicit}\ KeyMatcherImpl(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{02943\ \ \ \ \ \ \ :\ inner\_matcher\_(}
\DoxyCodeLine{02944\ \ \ \ \ \ \ \ \ \ \ testing::SafeMatcherCast<const\ KeyType\&>(inner\_matcher))\ \{}
\DoxyCodeLine{02945\ \ \ \}}
\DoxyCodeLine{02946\ }
\DoxyCodeLine{02947\ \ \ \textcolor{comment}{//\ Returns\ true\ if\ and\ only\ if\ 'key\_value.first'\ (the\ key)\ matches\ the\ inner}}
\DoxyCodeLine{02948\ \ \ \textcolor{comment}{//\ matcher.}}
\DoxyCodeLine{02949\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(PairType\ key\_value,}
\DoxyCodeLine{02950\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02951\ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{02952\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ inner\_matcher\_.MatchAndExplain(}
\DoxyCodeLine{02953\ \ \ \ \ \ \ \ \ pair\_getters::First(key\_value,\ Rank0()),\ \&inner\_listener);}
\DoxyCodeLine{02954\ \ \ \ \ \textcolor{keyword}{const}\ std::string\ explanation\ =\ inner\_listener.str();}
\DoxyCodeLine{02955\ \ \ \ \ \textcolor{keywordflow}{if}\ (explanation\ !=\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{02956\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ first\ field\ is\ a\ value\ "{}}\ <<\ explanation;}
\DoxyCodeLine{02957\ \ \ \ \ \}}
\DoxyCodeLine{02958\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{02959\ \ \ \}}
\DoxyCodeLine{02960\ }
\DoxyCodeLine{02961\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{02962\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02963\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ a\ key\ that\ "{}};}
\DoxyCodeLine{02964\ \ \ \ \ inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02965\ \ \ \}}
\DoxyCodeLine{02966\ }
\DoxyCodeLine{02967\ \ \ \textcolor{comment}{//\ Describes\ what\ the\ negation\ of\ this\ matcher\ does.}}
\DoxyCodeLine{02968\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{02969\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ have\ a\ key\ that\ "{}};}
\DoxyCodeLine{02970\ \ \ \ \ inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{02971\ \ \ \}}
\DoxyCodeLine{02972\ }
\DoxyCodeLine{02973\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02974\ \ \ \textcolor{keyword}{const}\ Matcher<const\ KeyType\&>\ inner\_matcher\_;}
\DoxyCodeLine{02975\ \};}
\DoxyCodeLine{02976\ }
\DoxyCodeLine{02977\ \textcolor{comment}{//\ Implements\ polymorphic\ Key(matcher\_for\_key).}}
\DoxyCodeLine{02978\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{02979\ \textcolor{keyword}{class\ }KeyMatcher\ \{}
\DoxyCodeLine{02980\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02981\ \ \ \textcolor{keyword}{explicit}\ KeyMatcher(M\ m)\ :\ matcher\_for\_key\_(m)\ \{\}}
\DoxyCodeLine{02982\ }
\DoxyCodeLine{02983\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PairType>}
\DoxyCodeLine{02984\ \ \ \textcolor{keyword}{operator}\ Matcher<PairType>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02985\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<PairType>(}
\DoxyCodeLine{02986\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ KeyMatcherImpl<const\ PairType\&>(matcher\_for\_key\_));}
\DoxyCodeLine{02987\ \ \ \}}
\DoxyCodeLine{02988\ }
\DoxyCodeLine{02989\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02990\ \ \ \textcolor{keyword}{const}\ M\ matcher\_for\_key\_;}
\DoxyCodeLine{02991\ \};}
\DoxyCodeLine{02992\ }
\DoxyCodeLine{02993\ \textcolor{comment}{//\ Implements\ polymorphic\ Address(matcher\_for\_address).}}
\DoxyCodeLine{02994\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{02995\ \textcolor{keyword}{class\ }AddressMatcher\ \{}
\DoxyCodeLine{02996\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02997\ \ \ \textcolor{keyword}{explicit}\ AddressMatcher(InnerMatcher\ m)\ :\ matcher\_(m)\ \{\}}
\DoxyCodeLine{02998\ }
\DoxyCodeLine{02999\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Type>}
\DoxyCodeLine{03000\ \ \ \textcolor{keyword}{operator}\ Matcher<Type>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03001\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Type>(\textcolor{keyword}{new}\ Impl<const\ Type\&>(matcher\_));}
\DoxyCodeLine{03002\ \ \ \}}
\DoxyCodeLine{03003\ }
\DoxyCodeLine{03004\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03005\ \ \ \textcolor{comment}{//\ The\ monomorphic\ implementation\ that\ works\ for\ a\ particular\ object\ type.}}
\DoxyCodeLine{03006\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Type>}
\DoxyCodeLine{03007\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Type>\ \{}
\DoxyCodeLine{03008\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03009\ \ \ \ \ \textcolor{keyword}{using\ }Address\ =\ \textcolor{keyword}{const}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Type)\ *;}
\DoxyCodeLine{03010\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)}
\DoxyCodeLine{03011\ \ \ \ \ \ \ \ \ :\ matcher\_(MatcherCast<Address>(matcher))\ \{\}}
\DoxyCodeLine{03012\ }
\DoxyCodeLine{03013\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03014\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ address\ that\ "{}};}
\DoxyCodeLine{03015\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{03016\ \ \ \ \ \}}
\DoxyCodeLine{03017\ }
\DoxyCodeLine{03018\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03019\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}does\ not\ have\ address\ that\ "{}};}
\DoxyCodeLine{03020\ \ \ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{03021\ \ \ \ \ \}}
\DoxyCodeLine{03022\ }
\DoxyCodeLine{03023\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Type\ \textcolor{keywordtype}{object},}
\DoxyCodeLine{03024\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03025\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ has\ address\ "{}};}
\DoxyCodeLine{03026\ \ \ \ \ \ \ Address\ address\ =\ std::addressof(\textcolor{keywordtype}{object});}
\DoxyCodeLine{03027\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ MatchPrintAndExplain(address,\ matcher\_,\ listener);}
\DoxyCodeLine{03028\ \ \ \ \ \}}
\DoxyCodeLine{03029\ }
\DoxyCodeLine{03030\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03031\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<Address>\ matcher\_;}
\DoxyCodeLine{03032\ \ \ \};}
\DoxyCodeLine{03033\ \ \ \textcolor{keyword}{const}\ InnerMatcher\ matcher\_;}
\DoxyCodeLine{03034\ \};}
\DoxyCodeLine{03035\ }
\DoxyCodeLine{03036\ \textcolor{comment}{//\ Implements\ Pair(first\_matcher,\ second\_matcher)\ for\ the\ given\ argument\ pair}}
\DoxyCodeLine{03037\ \textcolor{comment}{//\ type\ with\ its\ two\ matchers.\ See\ Pair()\ function\ below.}}
\DoxyCodeLine{03038\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PairType>}
\DoxyCodeLine{03039\ \textcolor{keyword}{class\ }PairMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<PairType>\ \{}
\DoxyCodeLine{03040\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03041\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(PairType)\ RawPairType;}
\DoxyCodeLine{03042\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RawPairType::first\_type\ FirstType;}
\DoxyCodeLine{03043\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RawPairType::second\_type\ SecondType;}
\DoxyCodeLine{03044\ }
\DoxyCodeLine{03045\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FirstMatcher,\ \textcolor{keyword}{typename}\ SecondMatcher>}
\DoxyCodeLine{03046\ \ \ PairMatcherImpl(FirstMatcher\ first\_matcher,\ SecondMatcher\ second\_matcher)}
\DoxyCodeLine{03047\ \ \ \ \ \ \ :\ first\_matcher\_(}
\DoxyCodeLine{03048\ \ \ \ \ \ \ \ \ \ \ \ \ testing::SafeMatcherCast<const\ FirstType\&>(first\_matcher)),}
\DoxyCodeLine{03049\ \ \ \ \ \ \ \ \ second\_matcher\_(}
\DoxyCodeLine{03050\ \ \ \ \ \ \ \ \ \ \ \ \ testing::SafeMatcherCast<const\ SecondType\&>(second\_matcher))\ \{}
\DoxyCodeLine{03051\ \ \ \}}
\DoxyCodeLine{03052\ }
\DoxyCodeLine{03053\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{03054\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03055\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ a\ first\ field\ that\ "{}};}
\DoxyCodeLine{03056\ \ \ \ \ first\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{03057\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ and\ has\ a\ second\ field\ that\ "{}};}
\DoxyCodeLine{03058\ \ \ \ \ second\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{03059\ \ \ \}}
\DoxyCodeLine{03060\ }
\DoxyCodeLine{03061\ \ \ \textcolor{comment}{//\ Describes\ what\ the\ negation\ of\ this\ matcher\ does.}}
\DoxyCodeLine{03062\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03063\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ a\ first\ field\ that\ "{}};}
\DoxyCodeLine{03064\ \ \ \ \ first\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{03065\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ or\ has\ a\ second\ field\ that\ "{}};}
\DoxyCodeLine{03066\ \ \ \ \ second\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{03067\ \ \ \}}
\DoxyCodeLine{03068\ }
\DoxyCodeLine{03069\ \ \ \textcolor{comment}{//\ Returns\ true\ if\ and\ only\ if\ 'a\_pair.first'\ matches\ first\_matcher\ and}}
\DoxyCodeLine{03070\ \ \ \textcolor{comment}{//\ 'a\_pair.second'\ matches\ second\_matcher.}}
\DoxyCodeLine{03071\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(PairType\ a\_pair,}
\DoxyCodeLine{03072\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03073\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{03074\ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ listener\ is\ not\ interested,\ we\ don't\ need\ to\ construct\ the}}
\DoxyCodeLine{03075\ \ \ \ \ \ \ \textcolor{comment}{//\ explanation.}}
\DoxyCodeLine{03076\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ first\_matcher\_.Matches(pair\_getters::First(a\_pair,\ Rank0()))\ \&\&}
\DoxyCodeLine{03077\ \ \ \ \ \ \ \ \ \ \ \ \ \ second\_matcher\_.Matches(pair\_getters::Second(a\_pair,\ Rank0()));}
\DoxyCodeLine{03078\ \ \ \ \ \}}
\DoxyCodeLine{03079\ \ \ \ \ StringMatchResultListener\ first\_inner\_listener;}
\DoxyCodeLine{03080\ \ \ \ \ \textcolor{keywordflow}{if}\ (!first\_matcher\_.MatchAndExplain(pair\_getters::First(a\_pair,\ Rank0()),}
\DoxyCodeLine{03081\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&first\_inner\_listener))\ \{}
\DoxyCodeLine{03082\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ first\ field\ does\ not\ match"{}};}
\DoxyCodeLine{03083\ \ \ \ \ \ \ PrintIfNotEmpty(first\_inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{03084\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03085\ \ \ \ \ \}}
\DoxyCodeLine{03086\ \ \ \ \ StringMatchResultListener\ second\_inner\_listener;}
\DoxyCodeLine{03087\ \ \ \ \ \textcolor{keywordflow}{if}\ (!second\_matcher\_.MatchAndExplain(pair\_getters::Second(a\_pair,\ Rank0()),}
\DoxyCodeLine{03088\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&second\_inner\_listener))\ \{}
\DoxyCodeLine{03089\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ second\ field\ does\ not\ match"{}};}
\DoxyCodeLine{03090\ \ \ \ \ \ \ PrintIfNotEmpty(second\_inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{03091\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03092\ \ \ \ \ \}}
\DoxyCodeLine{03093\ \ \ \ \ ExplainSuccess(first\_inner\_listener.str(),\ second\_inner\_listener.str(),}
\DoxyCodeLine{03094\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ listener);}
\DoxyCodeLine{03095\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{03096\ \ \ \}}
\DoxyCodeLine{03097\ }
\DoxyCodeLine{03098\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03099\ \ \ \textcolor{keywordtype}{void}\ ExplainSuccess(\textcolor{keyword}{const}\ std::string\&\ first\_explanation,}
\DoxyCodeLine{03100\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::string\&\ second\_explanation,}
\DoxyCodeLine{03101\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03102\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ both\ fields\ match"{}};}
\DoxyCodeLine{03103\ \ \ \ \ \textcolor{keywordflow}{if}\ (first\_explanation\ !=\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{03104\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{},\ where\ the\ first\ field\ is\ a\ value\ "{}}\ <<\ first\_explanation;}
\DoxyCodeLine{03105\ \ \ \ \ \}}
\DoxyCodeLine{03106\ \ \ \ \ \textcolor{keywordflow}{if}\ (second\_explanation\ !=\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{03107\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{03108\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (first\_explanation\ !=\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{03109\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}and\ "{}};}
\DoxyCodeLine{03110\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03111\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}where\ "{}};}
\DoxyCodeLine{03112\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03113\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}the\ second\ field\ is\ a\ value\ "{}}\ <<\ second\_explanation;}
\DoxyCodeLine{03114\ \ \ \ \ \}}
\DoxyCodeLine{03115\ \ \ \}}
\DoxyCodeLine{03116\ }
\DoxyCodeLine{03117\ \ \ \textcolor{keyword}{const}\ Matcher<const\ FirstType\&>\ first\_matcher\_;}
\DoxyCodeLine{03118\ \ \ \textcolor{keyword}{const}\ Matcher<const\ SecondType\&>\ second\_matcher\_;}
\DoxyCodeLine{03119\ \};}
\DoxyCodeLine{03120\ }
\DoxyCodeLine{03121\ \textcolor{comment}{//\ Implements\ polymorphic\ Pair(first\_matcher,\ second\_matcher).}}
\DoxyCodeLine{03122\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FirstMatcher,\ \textcolor{keyword}{typename}\ SecondMatcher>}
\DoxyCodeLine{03123\ \textcolor{keyword}{class\ }PairMatcher\ \{}
\DoxyCodeLine{03124\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03125\ \ \ PairMatcher(FirstMatcher\ first\_matcher,\ SecondMatcher\ second\_matcher)}
\DoxyCodeLine{03126\ \ \ \ \ \ \ :\ first\_matcher\_(first\_matcher),\ second\_matcher\_(second\_matcher)\ \{\}}
\DoxyCodeLine{03127\ }
\DoxyCodeLine{03128\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ PairType>}
\DoxyCodeLine{03129\ \ \ \textcolor{keyword}{operator}\ Matcher<PairType>\ ()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03130\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<PairType>(}
\DoxyCodeLine{03131\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ PairMatcherImpl<const\ PairType\&>(first\_matcher\_,\ second\_matcher\_));}
\DoxyCodeLine{03132\ \ \ \}}
\DoxyCodeLine{03133\ }
\DoxyCodeLine{03134\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03135\ \ \ \textcolor{keyword}{const}\ FirstMatcher\ first\_matcher\_;}
\DoxyCodeLine{03136\ \ \ \textcolor{keyword}{const}\ SecondMatcher\ second\_matcher\_;}
\DoxyCodeLine{03137\ \};}
\DoxyCodeLine{03138\ }
\DoxyCodeLine{03139\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}...\ I>}
\DoxyCodeLine{03140\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ IndexSequence<I...>,\ \textcolor{keywordtype}{int})}
\DoxyCodeLine{03141\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(std::tie(get<I>(t)...))\ \{}
\DoxyCodeLine{03142\ \ \ \textcolor{keyword}{static\_assert}(std::tuple\_size<T>::value\ ==\ \textcolor{keyword}{sizeof}...(I),}
\DoxyCodeLine{03143\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Number\ of\ arguments\ doesn't\ match\ the\ number\ of\ fields."{}});}
\DoxyCodeLine{03144\ \ \ \textcolor{keywordflow}{return}\ std::tie(get<I>(t)...);}
\DoxyCodeLine{03145\ \}}
\DoxyCodeLine{03146\ }
\DoxyCodeLine{03147\ \textcolor{preprocessor}{\#if\ defined(\_\_cpp\_structured\_bindings)\ \&\&\ \_\_cpp\_structured\_bindings\ >=\ 201606}}
\DoxyCodeLine{03148\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03149\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<1>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03150\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a]\ =\ t;}
\DoxyCodeLine{03151\ \ \ \textcolor{keywordflow}{return}\ std::tie(a);}
\DoxyCodeLine{03152\ \}}
\DoxyCodeLine{03153\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03154\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<2>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03155\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b]\ =\ t;}
\DoxyCodeLine{03156\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b);}
\DoxyCodeLine{03157\ \}}
\DoxyCodeLine{03158\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03159\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<3>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03160\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c]\ =\ t;}
\DoxyCodeLine{03161\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c);}
\DoxyCodeLine{03162\ \}}
\DoxyCodeLine{03163\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03164\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<4>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03165\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d]\ =\ t;}
\DoxyCodeLine{03166\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d);}
\DoxyCodeLine{03167\ \}}
\DoxyCodeLine{03168\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03169\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<5>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03170\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e]\ =\ t;}
\DoxyCodeLine{03171\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e);}
\DoxyCodeLine{03172\ \}}
\DoxyCodeLine{03173\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03174\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<6>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03175\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f]\ =\ t;}
\DoxyCodeLine{03176\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f);}
\DoxyCodeLine{03177\ \}}
\DoxyCodeLine{03178\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03179\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<7>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03180\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g]\ =\ t;}
\DoxyCodeLine{03181\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g);}
\DoxyCodeLine{03182\ \}}
\DoxyCodeLine{03183\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03184\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<8>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03185\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h]\ =\ t;}
\DoxyCodeLine{03186\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h);}
\DoxyCodeLine{03187\ \}}
\DoxyCodeLine{03188\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03189\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<9>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03190\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i]\ =\ t;}
\DoxyCodeLine{03191\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i);}
\DoxyCodeLine{03192\ \}}
\DoxyCodeLine{03193\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03194\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<10>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03195\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j]\ =\ t;}
\DoxyCodeLine{03196\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j);}
\DoxyCodeLine{03197\ \}}
\DoxyCodeLine{03198\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03199\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<11>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03200\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k]\ =\ t;}
\DoxyCodeLine{03201\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k);}
\DoxyCodeLine{03202\ \}}
\DoxyCodeLine{03203\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03204\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<12>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03205\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l]\ =\ t;}
\DoxyCodeLine{03206\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l);}
\DoxyCodeLine{03207\ \}}
\DoxyCodeLine{03208\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03209\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<13>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03210\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m]\ =\ t;}
\DoxyCodeLine{03211\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m);}
\DoxyCodeLine{03212\ \}}
\DoxyCodeLine{03213\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03214\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<14>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03215\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n]\ =\ t;}
\DoxyCodeLine{03216\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n);}
\DoxyCodeLine{03217\ \}}
\DoxyCodeLine{03218\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03219\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<15>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03220\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o]\ =\ t;}
\DoxyCodeLine{03221\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o);}
\DoxyCodeLine{03222\ \}}
\DoxyCodeLine{03223\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03224\ \textcolor{keyword}{auto}\ UnpackStructImpl(\textcolor{keyword}{const}\ T\&\ t,\ MakeIndexSequence<16>,\ \textcolor{keywordtype}{char})\ \{}
\DoxyCodeLine{03225\ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p]\ =\ t;}
\DoxyCodeLine{03226\ \ \ \textcolor{keywordflow}{return}\ std::tie(a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p);}
\DoxyCodeLine{03227\ \}}
\DoxyCodeLine{03228\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ defined(\_\_cpp\_structured\_bindings)}}
\DoxyCodeLine{03229\ }
\DoxyCodeLine{03230\ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}\ I,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03231\ \textcolor{keyword}{auto}\ UnpackStruct(\textcolor{keyword}{const}\ T\&\ t)}
\DoxyCodeLine{03232\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}((UnpackStructImpl)(t,\ MakeIndexSequence<I>\{\},\ 0))\ \{}
\DoxyCodeLine{03233\ \ \ \textcolor{keywordflow}{return}\ (UnpackStructImpl)(t,\ MakeIndexSequence<I>\{\},\ 0);}
\DoxyCodeLine{03234\ \}}
\DoxyCodeLine{03235\ }
\DoxyCodeLine{03236\ \textcolor{comment}{//\ Helper\ function\ to\ do\ comma\ folding\ in\ C++11.}}
\DoxyCodeLine{03237\ \textcolor{comment}{//\ The\ array\ ensures\ left-\/to-\/right\ order\ of\ evaluation.}}
\DoxyCodeLine{03238\ \textcolor{comment}{//\ Usage:\ VariadicExpand(\{expr...\});}}
\DoxyCodeLine{03239\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{03240\ \textcolor{keywordtype}{void}\ VariadicExpand(\textcolor{keyword}{const}\ T\ (\&)[N])\ \{\}}
\DoxyCodeLine{03241\ }
\DoxyCodeLine{03242\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Struct,\ \textcolor{keyword}{typename}\ StructSize>}
\DoxyCodeLine{03243\ \textcolor{keyword}{class\ }FieldsAreMatcherImpl;}
\DoxyCodeLine{03244\ }
\DoxyCodeLine{03245\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Struct,\ \textcolor{keywordtype}{size\_t}...\ I>}
\DoxyCodeLine{03246\ \textcolor{keyword}{class\ }FieldsAreMatcherImpl<Struct,\ IndexSequence<I...>>}
\DoxyCodeLine{03247\ \ \ \ \ :\ \textcolor{keyword}{public}\ MatcherInterface<Struct>\ \{}
\DoxyCodeLine{03248\ \ \ \textcolor{keyword}{using\ }UnpackedType\ =}
\DoxyCodeLine{03249\ \ \ \ \ \ \ \textcolor{keyword}{decltype}(UnpackStruct<\textcolor{keyword}{sizeof}...(I)>(std::declval<const\ Struct\&>()));}
\DoxyCodeLine{03250\ \ \ \textcolor{keyword}{using\ }MatchersType\ =\ std::tuple<}
\DoxyCodeLine{03251\ \ \ \ \ \ \ Matcher<const\ typename\ std::tuple\_element<I,\ UnpackedType>::type\&>...>;}
\DoxyCodeLine{03252\ }
\DoxyCodeLine{03253\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03254\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Inner>}
\DoxyCodeLine{03255\ \ \ \textcolor{keyword}{explicit}\ FieldsAreMatcherImpl(\textcolor{keyword}{const}\ Inner\&\ matchers)}
\DoxyCodeLine{03256\ \ \ \ \ \ \ :\ matchers\_(testing::SafeMatcherCast<}
\DoxyCodeLine{03257\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ typename\ std::tuple\_element<I,\ UnpackedType>::type\&>(}
\DoxyCodeLine{03258\ \ \ \ \ \ \ \ \ \ \ \ \ std::get<I>(matchers))...)\ \{\}}
\DoxyCodeLine{03259\ }
\DoxyCodeLine{03260\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03261\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ separator\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{03262\ \ \ \ \ VariadicExpand(}
\DoxyCodeLine{03263\ \ \ \ \ \ \ \ \ \{(*os\ <<\ separator\ <<\ \textcolor{stringliteral}{"{}has\ field\ \#"{}}\ <<\ I\ <<\ \textcolor{stringliteral}{"{}\ that\ "{}},}
\DoxyCodeLine{03264\ \ \ \ \ \ \ \ \ \ \ std::get<I>(matchers\_).DescribeTo(os),\ separator\ =\ \textcolor{stringliteral}{"{},\ and\ "{}})...\});}
\DoxyCodeLine{03265\ \ \ \}}
\DoxyCodeLine{03266\ }
\DoxyCodeLine{03267\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03268\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ separator\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{03269\ \ \ \ \ VariadicExpand(\{(*os\ <<\ separator\ <<\ \textcolor{stringliteral}{"{}has\ field\ \#"{}}\ <<\ I\ <<\ \textcolor{stringliteral}{"{}\ that\ "{}},}
\DoxyCodeLine{03270\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::get<I>(matchers\_).DescribeNegationTo(os),}
\DoxyCodeLine{03271\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ separator\ =\ \textcolor{stringliteral}{"{},\ or\ "{}})...\});}
\DoxyCodeLine{03272\ \ \ \}}
\DoxyCodeLine{03273\ }
\DoxyCodeLine{03274\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Struct\ t,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03275\ \ \ \ \ \textcolor{keywordflow}{return}\ MatchInternal((UnpackStruct<\textcolor{keyword}{sizeof}...(I)>)(t),\ listener);}
\DoxyCodeLine{03276\ \ \ \}}
\DoxyCodeLine{03277\ }
\DoxyCodeLine{03278\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03279\ \ \ \textcolor{keywordtype}{bool}\ MatchInternal(UnpackedType\ tuple,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03280\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{03281\ \ \ \ \ \ \ \textcolor{comment}{//\ If\ the\ listener\ is\ not\ interested,\ we\ don't\ need\ to\ construct\ the}}
\DoxyCodeLine{03282\ \ \ \ \ \ \ \textcolor{comment}{//\ explanation.}}
\DoxyCodeLine{03283\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ good\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{03284\ \ \ \ \ \ \ VariadicExpand(\{good\ =\ good\ \&\&\ std::get<I>(matchers\_).Matches(}
\DoxyCodeLine{03285\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::get<I>(tuple))...\});}
\DoxyCodeLine{03286\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ good;}
\DoxyCodeLine{03287\ \ \ \ \ \}}
\DoxyCodeLine{03288\ }
\DoxyCodeLine{03289\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ failed\_pos\ =\ \string~size\_t\{\};}
\DoxyCodeLine{03290\ }
\DoxyCodeLine{03291\ \ \ \ \ std::vector<StringMatchResultListener>\ inner\_listener(\textcolor{keyword}{sizeof}...(I));}
\DoxyCodeLine{03292\ }
\DoxyCodeLine{03293\ \ \ \ \ VariadicExpand(}
\DoxyCodeLine{03294\ \ \ \ \ \ \ \ \ \{failed\_pos\ ==\ \string~size\_t\{\}\ \&\&\ !std::get<I>(matchers\_).MatchAndExplain(}
\DoxyCodeLine{03295\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::get<I>(tuple),\ \&inner\_listener[I])}
\DoxyCodeLine{03296\ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ failed\_pos\ =\ I}
\DoxyCodeLine{03297\ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ 0\ ...\});}
\DoxyCodeLine{03298\ \ \ \ \ \textcolor{keywordflow}{if}\ (failed\_pos\ !=\ \string~\textcolor{keywordtype}{size\_t}\{\})\ \{}
\DoxyCodeLine{03299\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ field\ \#"{}}\ <<\ failed\_pos\ <<\ \textcolor{stringliteral}{"{}\ does\ not\ match"{}};}
\DoxyCodeLine{03300\ \ \ \ \ \ \ PrintIfNotEmpty(inner\_listener[failed\_pos].str(),\ listener-\/>stream());}
\DoxyCodeLine{03301\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03302\ \ \ \ \ \}}
\DoxyCodeLine{03303\ }
\DoxyCodeLine{03304\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ all\ elements\ match"{}};}
\DoxyCodeLine{03305\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ separator\ =\ \textcolor{stringliteral}{"{},\ where"{}};}
\DoxyCodeLine{03306\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ index\ =\ 0;\ index\ <\ \textcolor{keyword}{sizeof}...(I);\ ++index)\ \{}
\DoxyCodeLine{03307\ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::string\ str\ =\ inner\_listener[index].str();}
\DoxyCodeLine{03308\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!str.empty())\ \{}
\DoxyCodeLine{03309\ \ \ \ \ \ \ \ \ *listener\ <<\ separator\ <<\ \textcolor{stringliteral}{"{}\ field\ \#"{}}\ <<\ index\ <<\ \textcolor{stringliteral}{"{}\ is\ a\ value\ "{}}\ <<\ str;}
\DoxyCodeLine{03310\ \ \ \ \ \ \ \ \ separator\ =\ \textcolor{stringliteral}{"{},\ and"{}};}
\DoxyCodeLine{03311\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03312\ \ \ \ \ \}}
\DoxyCodeLine{03313\ }
\DoxyCodeLine{03314\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{03315\ \ \ \}}
\DoxyCodeLine{03316\ }
\DoxyCodeLine{03317\ \ \ MatchersType\ matchers\_;}
\DoxyCodeLine{03318\ \};}
\DoxyCodeLine{03319\ }
\DoxyCodeLine{03320\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Inner>}
\DoxyCodeLine{03321\ \textcolor{keyword}{class\ }FieldsAreMatcher\ \{}
\DoxyCodeLine{03322\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03323\ \ \ \textcolor{keyword}{explicit}\ FieldsAreMatcher(Inner...\ inner)\ :\ matchers\_(std::move(inner)...)\ \{\}}
\DoxyCodeLine{03324\ }
\DoxyCodeLine{03325\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Struct>}
\DoxyCodeLine{03326\ \ \ \textcolor{keyword}{operator}\ Matcher<Struct>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03327\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Struct>(}
\DoxyCodeLine{03328\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ FieldsAreMatcherImpl<\textcolor{keyword}{const}\ Struct\&,\ IndexSequenceFor<Inner...>>(}
\DoxyCodeLine{03329\ \ \ \ \ \ \ \ \ \ \ \ \ matchers\_));}
\DoxyCodeLine{03330\ \ \ \}}
\DoxyCodeLine{03331\ }
\DoxyCodeLine{03332\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03333\ \ \ std::tuple<Inner...>\ matchers\_;}
\DoxyCodeLine{03334\ \};}
\DoxyCodeLine{03335\ }
\DoxyCodeLine{03336\ \textcolor{comment}{//\ Implements\ ElementsAre()\ and\ ElementsAreArray().}}
\DoxyCodeLine{03337\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03338\ \textcolor{keyword}{class\ }ElementsAreMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>\ \{}
\DoxyCodeLine{03339\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03340\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{03341\ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<RawContainer>\ View;}
\DoxyCodeLine{03342\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::type\ StlContainer;}
\DoxyCodeLine{03343\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::const\_reference\ StlContainerReference;}
\DoxyCodeLine{03344\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ StlContainer::value\_type\ Element;}
\DoxyCodeLine{03345\ }
\DoxyCodeLine{03346\ \ \ \textcolor{comment}{//\ Constructs\ the\ matcher\ from\ a\ sequence\ of\ element\ values\ or}}
\DoxyCodeLine{03347\ \ \ \textcolor{comment}{//\ element\ matchers.}}
\DoxyCodeLine{03348\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIter>}
\DoxyCodeLine{03349\ \ \ ElementsAreMatcherImpl(InputIter\ first,\ InputIter\ last)\ \{}
\DoxyCodeLine{03350\ \ \ \ \ \textcolor{keywordflow}{while}\ (first\ !=\ last)\ \{}
\DoxyCodeLine{03351\ \ \ \ \ \ \ matchers\_.push\_back(MatcherCast<const\ Element\&>(*first++));}
\DoxyCodeLine{03352\ \ \ \ \ \}}
\DoxyCodeLine{03353\ \ \ \}}
\DoxyCodeLine{03354\ }
\DoxyCodeLine{03355\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{03356\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03357\ \ \ \ \ \textcolor{keywordflow}{if}\ (count()\ ==\ 0)\ \{}
\DoxyCodeLine{03358\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ empty"{}};}
\DoxyCodeLine{03359\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (count()\ ==\ 1)\ \{}
\DoxyCodeLine{03360\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ 1\ element\ that\ "{}};}
\DoxyCodeLine{03361\ \ \ \ \ \ \ matchers\_[0].DescribeTo(os);}
\DoxyCodeLine{03362\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03363\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}has\ "{}}\ <<\ Elements(count())\ <<\ \textcolor{stringliteral}{"{}\ where\(\backslash\)n"{}};}
\DoxyCodeLine{03364\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ count();\ ++i)\ \{}
\DoxyCodeLine{03365\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}element\ \#"{}}\ <<\ i\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{03366\ \ \ \ \ \ \ \ \ matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{03367\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ +\ 1\ <\ count())\ \{}
\DoxyCodeLine{03368\ \ \ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\(\backslash\)n"{}};}
\DoxyCodeLine{03369\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03370\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03371\ \ \ \ \ \}}
\DoxyCodeLine{03372\ \ \ \}}
\DoxyCodeLine{03373\ }
\DoxyCodeLine{03374\ \ \ \textcolor{comment}{//\ Describes\ what\ the\ negation\ of\ this\ matcher\ does.}}
\DoxyCodeLine{03375\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03376\ \ \ \ \ \textcolor{keywordflow}{if}\ (count()\ ==\ 0)\ \{}
\DoxyCodeLine{03377\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}isn't\ empty"{}};}
\DoxyCodeLine{03378\ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{03379\ \ \ \ \ \}}
\DoxyCodeLine{03380\ }
\DoxyCodeLine{03381\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ have\ "{}}\ <<\ Elements(count())\ <<\ \textcolor{stringliteral}{"{},\ or\(\backslash\)n"{}};}
\DoxyCodeLine{03382\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ count();\ ++i)\ \{}
\DoxyCodeLine{03383\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}element\ \#"{}}\ <<\ i\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{03384\ \ \ \ \ \ \ matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{03385\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ +\ 1\ <\ count())\ \{}
\DoxyCodeLine{03386\ \ \ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{},\ or\(\backslash\)n"{}};}
\DoxyCodeLine{03387\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03388\ \ \ \ \ \}}
\DoxyCodeLine{03389\ \ \ \}}
\DoxyCodeLine{03390\ }
\DoxyCodeLine{03391\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{03392\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03393\ \ \ \ \ \textcolor{comment}{//\ To\ work\ with\ stream-\/like\ "{}containers"{},\ we\ must\ only\ walk}}
\DoxyCodeLine{03394\ \ \ \ \ \textcolor{comment}{//\ through\ the\ elements\ in\ one\ pass.}}
\DoxyCodeLine{03395\ }
\DoxyCodeLine{03396\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ listener\_interested\ =\ listener-\/>IsInterested();}
\DoxyCodeLine{03397\ }
\DoxyCodeLine{03398\ \ \ \ \ \textcolor{comment}{//\ explanations[i]\ is\ the\ explanation\ of\ the\ element\ at\ index\ i.}}
\DoxyCodeLine{03399\ \ \ \ \ ::std::vector<std::string>\ explanations(count());}
\DoxyCodeLine{03400\ \ \ \ \ StlContainerReference\ stl\_container\ =\ View::ConstReference(container);}
\DoxyCodeLine{03401\ \ \ \ \ \textcolor{keyword}{auto}\ it\ =\ stl\_container.begin();}
\DoxyCodeLine{03402\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ exam\_pos\ =\ 0;}
\DoxyCodeLine{03403\ \ \ \ \ \textcolor{keywordtype}{bool}\ mismatch\_found\ =\ \textcolor{keyword}{false};\ \ \textcolor{comment}{//\ Have\ we\ found\ a\ mismatched\ element\ yet?}}
\DoxyCodeLine{03404\ }
\DoxyCodeLine{03405\ \ \ \ \ \textcolor{comment}{//\ Go\ through\ the\ elements\ and\ matchers\ in\ pairs,\ until\ we\ reach}}
\DoxyCodeLine{03406\ \ \ \ \ \textcolor{comment}{//\ the\ end\ of\ either\ the\ elements\ or\ the\ matchers,\ or\ until\ we\ find\ a}}
\DoxyCodeLine{03407\ \ \ \ \ \textcolor{comment}{//\ mismatch.}}
\DoxyCodeLine{03408\ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ it\ !=\ stl\_container.end()\ \&\&\ exam\_pos\ !=\ count();\ ++it,\ ++exam\_pos)\ \{}
\DoxyCodeLine{03409\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ match;\ \ \textcolor{comment}{//\ Does\ the\ current\ element\ match\ the\ current\ matcher?}}
\DoxyCodeLine{03410\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\_interested)\ \{}
\DoxyCodeLine{03411\ \ \ \ \ \ \ \ \ StringMatchResultListener\ s;}
\DoxyCodeLine{03412\ \ \ \ \ \ \ \ \ match\ =\ matchers\_[exam\_pos].MatchAndExplain(*it,\ \&s);}
\DoxyCodeLine{03413\ \ \ \ \ \ \ \ \ explanations[exam\_pos]\ =\ s.str();}
\DoxyCodeLine{03414\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03415\ \ \ \ \ \ \ \ \ match\ =\ matchers\_[exam\_pos].Matches(*it);}
\DoxyCodeLine{03416\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03417\ }
\DoxyCodeLine{03418\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!match)\ \{}
\DoxyCodeLine{03419\ \ \ \ \ \ \ \ \ mismatch\_found\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{03420\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{03421\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03422\ \ \ \ \ \}}
\DoxyCodeLine{03423\ \ \ \ \ \textcolor{comment}{//\ If\ mismatch\_found\ is\ true,\ 'exam\_pos'\ is\ the\ index\ of\ the\ mismatch.}}
\DoxyCodeLine{03424\ }
\DoxyCodeLine{03425\ \ \ \ \ \textcolor{comment}{//\ Find\ how\ many\ elements\ the\ actual\ container\ has.\ \ We\ avoid}}
\DoxyCodeLine{03426\ \ \ \ \ \textcolor{comment}{//\ calling\ size()\ s.t.\ this\ code\ works\ for\ stream-\/like\ "{}containers"{}}}
\DoxyCodeLine{03427\ \ \ \ \ \textcolor{comment}{//\ that\ don't\ define\ size().}}
\DoxyCodeLine{03428\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ actual\_count\ =\ exam\_pos;}
\DoxyCodeLine{03429\ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ it\ !=\ stl\_container.end();\ ++it)\ \{}
\DoxyCodeLine{03430\ \ \ \ \ \ \ ++actual\_count;}
\DoxyCodeLine{03431\ \ \ \ \ \}}
\DoxyCodeLine{03432\ }
\DoxyCodeLine{03433\ \ \ \ \ \textcolor{keywordflow}{if}\ (actual\_count\ !=\ count())\ \{}
\DoxyCodeLine{03434\ \ \ \ \ \ \ \textcolor{comment}{//\ The\ element\ count\ doesn't\ match.\ \ If\ the\ container\ is\ empty,}}
\DoxyCodeLine{03435\ \ \ \ \ \ \ \textcolor{comment}{//\ there's\ no\ need\ to\ explain\ anything\ as\ Google\ Mock\ already}}
\DoxyCodeLine{03436\ \ \ \ \ \ \ \textcolor{comment}{//\ prints\ the\ empty\ container.\ \ Otherwise\ we\ just\ need\ to\ show}}
\DoxyCodeLine{03437\ \ \ \ \ \ \ \textcolor{comment}{//\ how\ many\ elements\ there\ actually\ are.}}
\DoxyCodeLine{03438\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\_interested\ \&\&\ (actual\_count\ !=\ 0))\ \{}
\DoxyCodeLine{03439\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ has\ "{}}\ <<\ Elements(actual\_count);}
\DoxyCodeLine{03440\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03441\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03442\ \ \ \ \ \}}
\DoxyCodeLine{03443\ }
\DoxyCodeLine{03444\ \ \ \ \ \textcolor{keywordflow}{if}\ (mismatch\_found)\ \{}
\DoxyCodeLine{03445\ \ \ \ \ \ \ \textcolor{comment}{//\ The\ element\ count\ matches,\ but\ the\ exam\_pos-\/th\ element\ doesn't\ match.}}
\DoxyCodeLine{03446\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\_interested)\ \{}
\DoxyCodeLine{03447\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ element\ \#"{}}\ <<\ exam\_pos\ <<\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}};}
\DoxyCodeLine{03448\ \ \ \ \ \ \ \ \ PrintIfNotEmpty(explanations[exam\_pos],\ listener-\/>stream());}
\DoxyCodeLine{03449\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03450\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03451\ \ \ \ \ \}}
\DoxyCodeLine{03452\ }
\DoxyCodeLine{03453\ \ \ \ \ \textcolor{comment}{//\ Every\ element\ matches\ its\ expectation.\ \ We\ need\ to\ explain\ why}}
\DoxyCodeLine{03454\ \ \ \ \ \textcolor{comment}{//\ (the\ obvious\ ones\ can\ be\ skipped).}}
\DoxyCodeLine{03455\ \ \ \ \ \textcolor{keywordflow}{if}\ (listener\_interested)\ \{}
\DoxyCodeLine{03456\ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ reason\_printed\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{03457\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ !=\ count();\ ++i)\ \{}
\DoxyCodeLine{03458\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::string\&\ s\ =\ explanations[i];}
\DoxyCodeLine{03459\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!s.empty())\ \{}
\DoxyCodeLine{03460\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (reason\_printed)\ \{}
\DoxyCodeLine{03461\ \ \ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{},\(\backslash\)nand\ "{}};}
\DoxyCodeLine{03462\ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03463\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ element\ \#"{}}\ <<\ i\ <<\ \textcolor{stringliteral}{"{}\ matches,\ "{}}\ <<\ s;}
\DoxyCodeLine{03464\ \ \ \ \ \ \ \ \ \ \ reason\_printed\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{03465\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03466\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03467\ \ \ \ \ \}}
\DoxyCodeLine{03468\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{03469\ \ \ \}}
\DoxyCodeLine{03470\ }
\DoxyCodeLine{03471\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03472\ \ \ \textcolor{keyword}{static}\ Message\ Elements(\textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{03473\ \ \ \ \ \textcolor{keywordflow}{return}\ Message()\ <<\ count\ <<\ (count\ ==\ 1\ ?\ \textcolor{stringliteral}{"{}\ element"{}}\ :\ \textcolor{stringliteral}{"{}\ elements"{}});}
\DoxyCodeLine{03474\ \ \ \}}
\DoxyCodeLine{03475\ }
\DoxyCodeLine{03476\ \ \ \textcolor{keywordtype}{size\_t}\ count()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ matchers\_.size();\ \}}
\DoxyCodeLine{03477\ }
\DoxyCodeLine{03478\ \ \ ::std::vector<Matcher<const\ Element\&>\ >\ matchers\_;}
\DoxyCodeLine{03479\ \};}
\DoxyCodeLine{03480\ }
\DoxyCodeLine{03481\ \textcolor{comment}{//\ Connectivity\ matrix\ of\ (elements\ X\ matchers),\ in\ element-\/major\ order.}}
\DoxyCodeLine{03482\ \textcolor{comment}{//\ Initially,\ there\ are\ no\ edges.}}
\DoxyCodeLine{03483\ \textcolor{comment}{//\ Use\ NextGraph()\ to\ iterate\ over\ all\ possible\ edge\ configurations.}}
\DoxyCodeLine{03484\ \textcolor{comment}{//\ Use\ Randomize()\ to\ generate\ a\ random\ edge\ configuration.}}
\DoxyCodeLine{03485\ \textcolor{keyword}{class\ }GTEST\_API\_\ MatchMatrix\ \{}
\DoxyCodeLine{03486\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03487\ \ \ MatchMatrix(\textcolor{keywordtype}{size\_t}\ num\_elements,\ \textcolor{keywordtype}{size\_t}\ num\_matchers)}
\DoxyCodeLine{03488\ \ \ \ \ \ \ :\ num\_elements\_(num\_elements),}
\DoxyCodeLine{03489\ \ \ \ \ \ \ \ \ num\_matchers\_(num\_matchers),}
\DoxyCodeLine{03490\ \ \ \ \ \ \ \ \ matched\_(num\_elements\_*\ num\_matchers\_,\ 0)\ \{}
\DoxyCodeLine{03491\ \ \ \}}
\DoxyCodeLine{03492\ }
\DoxyCodeLine{03493\ \ \ \textcolor{keywordtype}{size\_t}\ LhsSize()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ num\_elements\_;\ \}}
\DoxyCodeLine{03494\ \ \ \textcolor{keywordtype}{size\_t}\ RhsSize()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ num\_matchers\_;\ \}}
\DoxyCodeLine{03495\ \ \ \textcolor{keywordtype}{bool}\ HasEdge(\textcolor{keywordtype}{size\_t}\ ilhs,\ \textcolor{keywordtype}{size\_t}\ irhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03496\ \ \ \ \ \textcolor{keywordflow}{return}\ matched\_[SpaceIndex(ilhs,\ irhs)]\ ==\ 1;}
\DoxyCodeLine{03497\ \ \ \}}
\DoxyCodeLine{03498\ \ \ \textcolor{keywordtype}{void}\ SetEdge(\textcolor{keywordtype}{size\_t}\ ilhs,\ \textcolor{keywordtype}{size\_t}\ irhs,\ \textcolor{keywordtype}{bool}\ b)\ \{}
\DoxyCodeLine{03499\ \ \ \ \ matched\_[SpaceIndex(ilhs,\ irhs)]\ =\ b\ ?\ 1\ :\ 0;}
\DoxyCodeLine{03500\ \ \ \}}
\DoxyCodeLine{03501\ }
\DoxyCodeLine{03502\ \ \ \textcolor{comment}{//\ Treating\ the\ connectivity\ matrix\ as\ a\ (LhsSize()*RhsSize())-\/bit\ number,}}
\DoxyCodeLine{03503\ \ \ \textcolor{comment}{//\ adds\ 1\ to\ that\ number;\ returns\ false\ if\ incrementing\ the\ graph\ left\ it}}
\DoxyCodeLine{03504\ \ \ \textcolor{comment}{//\ empty.}}
\DoxyCodeLine{03505\ \ \ \textcolor{keywordtype}{bool}\ NextGraph();}
\DoxyCodeLine{03506\ }
\DoxyCodeLine{03507\ \ \ \textcolor{keywordtype}{void}\ Randomize();}
\DoxyCodeLine{03508\ }
\DoxyCodeLine{03509\ \ \ std::string\ DebugString()\ \textcolor{keyword}{const};}
\DoxyCodeLine{03510\ }
\DoxyCodeLine{03511\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03512\ \ \ \textcolor{keywordtype}{size\_t}\ SpaceIndex(\textcolor{keywordtype}{size\_t}\ ilhs,\ \textcolor{keywordtype}{size\_t}\ irhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03513\ \ \ \ \ \textcolor{keywordflow}{return}\ ilhs\ *\ num\_matchers\_\ +\ irhs;}
\DoxyCodeLine{03514\ \ \ \}}
\DoxyCodeLine{03515\ }
\DoxyCodeLine{03516\ \ \ \textcolor{keywordtype}{size\_t}\ num\_elements\_;}
\DoxyCodeLine{03517\ \ \ \textcolor{keywordtype}{size\_t}\ num\_matchers\_;}
\DoxyCodeLine{03518\ }
\DoxyCodeLine{03519\ \ \ \textcolor{comment}{//\ Each\ element\ is\ a\ char\ interpreted\ as\ bool.\ They\ are\ stored\ as\ a}}
\DoxyCodeLine{03520\ \ \ \textcolor{comment}{//\ flattened\ array\ in\ lhs-\/major\ order,\ use\ 'SpaceIndex()'\ to\ translate}}
\DoxyCodeLine{03521\ \ \ \textcolor{comment}{//\ a\ (ilhs,\ irhs)\ matrix\ coordinate\ into\ an\ offset.}}
\DoxyCodeLine{03522\ \ \ ::std::vector<char>\ matched\_;}
\DoxyCodeLine{03523\ \};}
\DoxyCodeLine{03524\ }
\DoxyCodeLine{03525\ typedef\ ::std::pair<size\_t,\ size\_t>\ ElementMatcherPair;}
\DoxyCodeLine{03526\ typedef\ ::std::vector<ElementMatcherPair>\ ElementMatcherPairs;}
\DoxyCodeLine{03527\ }
\DoxyCodeLine{03528\ \textcolor{comment}{//\ Returns\ a\ maximum\ bipartite\ matching\ for\ the\ specified\ graph\ 'g'.}}
\DoxyCodeLine{03529\ \textcolor{comment}{//\ The\ matching\ is\ represented\ as\ a\ vector\ of\ \{element,\ matcher\}\ pairs.}}
\DoxyCodeLine{03530\ GTEST\_API\_\ ElementMatcherPairs}
\DoxyCodeLine{03531\ FindMaxBipartiteMatching(\textcolor{keyword}{const}\ MatchMatrix\&\ g);}
\DoxyCodeLine{03532\ }
\DoxyCodeLine{03533\ \textcolor{keyword}{struct\ }UnorderedMatcherRequire\ \{}
\DoxyCodeLine{03534\ \ \ \textcolor{keyword}{enum}\ Flags\ \{}
\DoxyCodeLine{03535\ \ \ \ \ Superset\ =\ 1\ <<\ 0,}
\DoxyCodeLine{03536\ \ \ \ \ Subset\ =\ 1\ <<\ 1,}
\DoxyCodeLine{03537\ \ \ \ \ ExactMatch\ =\ Superset\ |\ Subset,}
\DoxyCodeLine{03538\ \ \ \};}
\DoxyCodeLine{03539\ \};}
\DoxyCodeLine{03540\ }
\DoxyCodeLine{03541\ \textcolor{comment}{//\ Untyped\ base\ class\ for\ implementing\ UnorderedElementsAre.\ \ By}}
\DoxyCodeLine{03542\ \textcolor{comment}{//\ putting\ logic\ that's\ not\ specific\ to\ the\ element\ type\ here,\ we}}
\DoxyCodeLine{03543\ \textcolor{comment}{//\ reduce\ binary\ bloat\ and\ increase\ compilation\ speed.}}
\DoxyCodeLine{03544\ \textcolor{keyword}{class\ }GTEST\_API\_\ UnorderedElementsAreMatcherImplBase\ \{}
\DoxyCodeLine{03545\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{03546\ \ \ \textcolor{keyword}{explicit}\ UnorderedElementsAreMatcherImplBase(}
\DoxyCodeLine{03547\ \ \ \ \ \ \ UnorderedMatcherRequire::Flags\ matcher\_flags)}
\DoxyCodeLine{03548\ \ \ \ \ \ \ :\ match\_flags\_(matcher\_flags)\ \{\}}
\DoxyCodeLine{03549\ }
\DoxyCodeLine{03550\ \ \ \textcolor{comment}{//\ A\ vector\ of\ matcher\ describers,\ one\ for\ each\ element\ matcher.}}
\DoxyCodeLine{03551\ \ \ \textcolor{comment}{//\ Does\ not\ own\ the\ describers\ (and\ thus\ can\ be\ used\ only\ when\ the}}
\DoxyCodeLine{03552\ \ \ \textcolor{comment}{//\ element\ matchers\ are\ alive).}}
\DoxyCodeLine{03553\ \ \ typedef\ ::std::vector<const\ MatcherDescriberInterface*>\ MatcherDescriberVec;}
\DoxyCodeLine{03554\ }
\DoxyCodeLine{03555\ \ \ \textcolor{comment}{//\ Describes\ this\ UnorderedElementsAre\ matcher.}}
\DoxyCodeLine{03556\ \ \ \textcolor{keywordtype}{void}\ DescribeToImpl(::std::ostream*\ os)\ \textcolor{keyword}{const};}
\DoxyCodeLine{03557\ }
\DoxyCodeLine{03558\ \ \ \textcolor{comment}{//\ Describes\ the\ negation\ of\ this\ UnorderedElementsAre\ matcher.}}
\DoxyCodeLine{03559\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationToImpl(::std::ostream*\ os)\ \textcolor{keyword}{const};}
\DoxyCodeLine{03560\ }
\DoxyCodeLine{03561\ \ \ \textcolor{keywordtype}{bool}\ VerifyMatchMatrix(const\ ::std::vector<std::string>\&\ element\_printouts,}
\DoxyCodeLine{03562\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ MatchMatrix\&\ matrix,}
\DoxyCodeLine{03563\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\ \textcolor{keyword}{const};}
\DoxyCodeLine{03564\ }
\DoxyCodeLine{03565\ \ \ \textcolor{keywordtype}{bool}\ FindPairing(\textcolor{keyword}{const}\ MatchMatrix\&\ matrix,}
\DoxyCodeLine{03566\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\ \textcolor{keyword}{const};}
\DoxyCodeLine{03567\ }
\DoxyCodeLine{03568\ \ \ MatcherDescriberVec\&\ matcher\_describers()\ \{}
\DoxyCodeLine{03569\ \ \ \ \ \textcolor{keywordflow}{return}\ matcher\_describers\_;}
\DoxyCodeLine{03570\ \ \ \}}
\DoxyCodeLine{03571\ }
\DoxyCodeLine{03572\ \ \ \textcolor{keyword}{static}\ Message\ Elements(\textcolor{keywordtype}{size\_t}\ n)\ \{}
\DoxyCodeLine{03573\ \ \ \ \ \textcolor{keywordflow}{return}\ Message()\ <<\ n\ <<\ \textcolor{stringliteral}{"{}\ element"{}}\ <<\ (n\ ==\ 1\ ?\ \textcolor{stringliteral}{"{}"{}}\ :\ \textcolor{stringliteral}{"{}s"{}});}
\DoxyCodeLine{03574\ \ \ \}}
\DoxyCodeLine{03575\ }
\DoxyCodeLine{03576\ \ \ UnorderedMatcherRequire::Flags\ match\_flags()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ match\_flags\_;\ \}}
\DoxyCodeLine{03577\ }
\DoxyCodeLine{03578\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03579\ \ \ UnorderedMatcherRequire::Flags\ match\_flags\_;}
\DoxyCodeLine{03580\ \ \ MatcherDescriberVec\ matcher\_describers\_;}
\DoxyCodeLine{03581\ \};}
\DoxyCodeLine{03582\ }
\DoxyCodeLine{03583\ \textcolor{comment}{//\ Implements\ UnorderedElementsAre,\ UnorderedElementsAreArray,\ IsSubsetOf,\ and}}
\DoxyCodeLine{03584\ \textcolor{comment}{//\ IsSupersetOf.}}
\DoxyCodeLine{03585\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03586\ \textcolor{keyword}{class\ }UnorderedElementsAreMatcherImpl}
\DoxyCodeLine{03587\ \ \ \ \ :\ \textcolor{keyword}{public}\ MatcherInterface<Container>,}
\DoxyCodeLine{03588\ \ \ \ \ \ \ \textcolor{keyword}{public}\ UnorderedElementsAreMatcherImplBase\ \{}
\DoxyCodeLine{03589\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03590\ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{03591\ \ \ \textcolor{keyword}{typedef}\ internal::StlContainerView<RawContainer>\ View;}
\DoxyCodeLine{03592\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::type\ StlContainer;}
\DoxyCodeLine{03593\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::const\_reference\ StlContainerReference;}
\DoxyCodeLine{03594\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ StlContainer::value\_type\ Element;}
\DoxyCodeLine{03595\ }
\DoxyCodeLine{03596\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InputIter>}
\DoxyCodeLine{03597\ \ \ UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags\ matcher\_flags,}
\DoxyCodeLine{03598\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputIter\ first,\ InputIter\ last)}
\DoxyCodeLine{03599\ \ \ \ \ \ \ :\ UnorderedElementsAreMatcherImplBase(matcher\_flags)\ \{}
\DoxyCodeLine{03600\ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ first\ !=\ last;\ ++first)\ \{}
\DoxyCodeLine{03601\ \ \ \ \ \ \ matchers\_.push\_back(MatcherCast<const\ Element\&>(*first));}
\DoxyCodeLine{03602\ \ \ \ \ \}}
\DoxyCodeLine{03603\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ m\ :\ matchers\_)\ \{}
\DoxyCodeLine{03604\ \ \ \ \ \ \ matcher\_describers().push\_back(m.GetDescriber());}
\DoxyCodeLine{03605\ \ \ \ \ \}}
\DoxyCodeLine{03606\ \ \ \}}
\DoxyCodeLine{03607\ }
\DoxyCodeLine{03608\ \ \ \textcolor{comment}{//\ Describes\ what\ this\ matcher\ does.}}
\DoxyCodeLine{03609\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03610\ \ \ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);}
\DoxyCodeLine{03611\ \ \ \}}
\DoxyCodeLine{03612\ }
\DoxyCodeLine{03613\ \ \ \textcolor{comment}{//\ Describes\ what\ the\ negation\ of\ this\ matcher\ does.}}
\DoxyCodeLine{03614\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03615\ \ \ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);}
\DoxyCodeLine{03616\ \ \ \}}
\DoxyCodeLine{03617\ }
\DoxyCodeLine{03618\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Container\ container,}
\DoxyCodeLine{03619\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03620\ \ \ \ \ StlContainerReference\ stl\_container\ =\ View::ConstReference(container);}
\DoxyCodeLine{03621\ \ \ \ \ ::std::vector<std::string>\ element\_printouts;}
\DoxyCodeLine{03622\ \ \ \ \ MatchMatrix\ matrix\ =}
\DoxyCodeLine{03623\ \ \ \ \ \ \ \ \ AnalyzeElements(stl\_container.begin(),\ stl\_container.end(),}
\DoxyCodeLine{03624\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \&element\_printouts,\ listener);}
\DoxyCodeLine{03625\ }
\DoxyCodeLine{03626\ \ \ \ \ \textcolor{keywordflow}{if}\ (matrix.LhsSize()\ ==\ 0\ \&\&\ matrix.RhsSize()\ ==\ 0)\ \{}
\DoxyCodeLine{03627\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{03628\ \ \ \ \ \}}
\DoxyCodeLine{03629\ }
\DoxyCodeLine{03630\ \ \ \ \ \textcolor{keywordflow}{if}\ (match\_flags()\ ==\ UnorderedMatcherRequire::ExactMatch)\ \{}
\DoxyCodeLine{03631\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matrix.LhsSize()\ !=\ matrix.RhsSize())\ \{}
\DoxyCodeLine{03632\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ element\ count\ doesn't\ match.\ \ If\ the\ container\ is\ empty,}}
\DoxyCodeLine{03633\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ there's\ no\ need\ to\ explain\ anything\ as\ Google\ Mock\ already}}
\DoxyCodeLine{03634\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ prints\ the\ empty\ container.\ Otherwise\ we\ just\ need\ to\ show}}
\DoxyCodeLine{03635\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ how\ many\ elements\ there\ actually\ are.}}
\DoxyCodeLine{03636\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (matrix.LhsSize()\ !=\ 0\ \&\&\ listener-\/>IsInterested())\ \{}
\DoxyCodeLine{03637\ \ \ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ has\ "{}}\ <<\ Elements(matrix.LhsSize());}
\DoxyCodeLine{03638\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03639\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03640\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03641\ \ \ \ \ \}}
\DoxyCodeLine{03642\ }
\DoxyCodeLine{03643\ \ \ \ \ \textcolor{keywordflow}{return}\ VerifyMatchMatrix(element\_printouts,\ matrix,\ listener)\ \&\&}
\DoxyCodeLine{03644\ \ \ \ \ \ \ \ \ \ \ \ FindPairing(matrix,\ listener);}
\DoxyCodeLine{03645\ \ \ \}}
\DoxyCodeLine{03646\ }
\DoxyCodeLine{03647\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03648\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ElementIter>}
\DoxyCodeLine{03649\ \ \ MatchMatrix\ AnalyzeElements(ElementIter\ elem\_first,\ ElementIter\ elem\_last,}
\DoxyCodeLine{03650\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::vector<std::string>*\ element\_printouts,}
\DoxyCodeLine{03651\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03652\ \ \ \ \ element\_printouts-\/>clear();}
\DoxyCodeLine{03653\ \ \ \ \ ::std::vector<char>\ did\_match;}
\DoxyCodeLine{03654\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ num\_elements\ =\ 0;}
\DoxyCodeLine{03655\ \ \ \ \ DummyMatchResultListener\ dummy;}
\DoxyCodeLine{03656\ \ \ \ \ \textcolor{keywordflow}{for}\ (;\ elem\_first\ !=\ elem\_last;\ ++num\_elements,\ ++elem\_first)\ \{}
\DoxyCodeLine{03657\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>IsInterested())\ \{}
\DoxyCodeLine{03658\ \ \ \ \ \ \ \ \ element\_printouts-\/>push\_back(PrintToString(*elem\_first));}
\DoxyCodeLine{03659\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03660\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ irhs\ =\ 0;\ irhs\ !=\ matchers\_.size();\ ++irhs)\ \{}
\DoxyCodeLine{03661\ \ \ \ \ \ \ \ \ did\_match.push\_back(}
\DoxyCodeLine{03662\ \ \ \ \ \ \ \ \ \ \ \ \ matchers\_[irhs].MatchAndExplain(*elem\_first,\ \&dummy));}
\DoxyCodeLine{03663\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03664\ \ \ \ \ \}}
\DoxyCodeLine{03665\ }
\DoxyCodeLine{03666\ \ \ \ \ MatchMatrix\ matrix(num\_elements,\ matchers\_.size());}
\DoxyCodeLine{03667\ \ \ \ \ ::std::vector<char>::const\_iterator\ did\_match\_iter\ =\ did\_match.begin();}
\DoxyCodeLine{03668\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ ilhs\ =\ 0;\ ilhs\ !=\ num\_elements;\ ++ilhs)\ \{}
\DoxyCodeLine{03669\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ irhs\ =\ 0;\ irhs\ !=\ matchers\_.size();\ ++irhs)\ \{}
\DoxyCodeLine{03670\ \ \ \ \ \ \ \ \ matrix.SetEdge(ilhs,\ irhs,\ *did\_match\_iter++\ !=\ 0);}
\DoxyCodeLine{03671\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03672\ \ \ \ \ \}}
\DoxyCodeLine{03673\ \ \ \ \ \textcolor{keywordflow}{return}\ matrix;}
\DoxyCodeLine{03674\ \ \ \}}
\DoxyCodeLine{03675\ }
\DoxyCodeLine{03676\ \ \ ::std::vector<Matcher<const\ Element\&>\ >\ matchers\_;}
\DoxyCodeLine{03677\ \};}
\DoxyCodeLine{03678\ }
\DoxyCodeLine{03679\ \textcolor{comment}{//\ Functor\ for\ use\ in\ TransformTuple.}}
\DoxyCodeLine{03680\ \textcolor{comment}{//\ Performs\ MatcherCast<Target>\ on\ an\ input\ argument\ of\ any\ type.}}
\DoxyCodeLine{03681\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Target>}
\DoxyCodeLine{03682\ \textcolor{keyword}{struct\ }CastAndAppendTransform\ \{}
\DoxyCodeLine{03683\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Arg>}
\DoxyCodeLine{03684\ \ \ Matcher<Target>\ operator()(\textcolor{keyword}{const}\ Arg\&\ a)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03685\ \ \ \ \ \textcolor{keywordflow}{return}\ MatcherCast<Target>(a);}
\DoxyCodeLine{03686\ \ \ \}}
\DoxyCodeLine{03687\ \};}
\DoxyCodeLine{03688\ }
\DoxyCodeLine{03689\ \textcolor{comment}{//\ Implements\ UnorderedElementsAre.}}
\DoxyCodeLine{03690\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple>}
\DoxyCodeLine{03691\ \textcolor{keyword}{class\ }UnorderedElementsAreMatcher\ \{}
\DoxyCodeLine{03692\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03693\ \ \ \textcolor{keyword}{explicit}\ UnorderedElementsAreMatcher(\textcolor{keyword}{const}\ MatcherTuple\&\ args)}
\DoxyCodeLine{03694\ \ \ \ \ \ \ :\ matchers\_(args)\ \{\}}
\DoxyCodeLine{03695\ }
\DoxyCodeLine{03696\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03697\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03698\ \ \ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{03699\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ internal::StlContainerView<RawContainer>::type\ View;}
\DoxyCodeLine{03700\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::value\_type\ Element;}
\DoxyCodeLine{03701\ \ \ \ \ typedef\ ::std::vector<Matcher<const\ Element\&>\ >\ MatcherVec;}
\DoxyCodeLine{03702\ \ \ \ \ MatcherVec\ matchers;}
\DoxyCodeLine{03703\ \ \ \ \ matchers.reserve(::std::tuple\_size<MatcherTuple>::value);}
\DoxyCodeLine{03704\ \ \ \ \ TransformTupleValues(CastAndAppendTransform<const\ Element\&>(),\ matchers\_,}
\DoxyCodeLine{03705\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::back\_inserter(matchers));}
\DoxyCodeLine{03706\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(}
\DoxyCodeLine{03707\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ UnorderedElementsAreMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{03708\ \ \ \ \ \ \ \ \ \ \ \ \ UnorderedMatcherRequire::ExactMatch,\ matchers.begin(),}
\DoxyCodeLine{03709\ \ \ \ \ \ \ \ \ \ \ \ \ matchers.end()));}
\DoxyCodeLine{03710\ \ \ \}}
\DoxyCodeLine{03711\ }
\DoxyCodeLine{03712\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03713\ \ \ \textcolor{keyword}{const}\ MatcherTuple\ matchers\_;}
\DoxyCodeLine{03714\ \};}
\DoxyCodeLine{03715\ }
\DoxyCodeLine{03716\ \textcolor{comment}{//\ Implements\ ElementsAre.}}
\DoxyCodeLine{03717\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTuple>}
\DoxyCodeLine{03718\ \textcolor{keyword}{class\ }ElementsAreMatcher\ \{}
\DoxyCodeLine{03719\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03720\ \ \ \textcolor{keyword}{explicit}\ ElementsAreMatcher(\textcolor{keyword}{const}\ MatcherTuple\&\ args)\ :\ matchers\_(args)\ \{\}}
\DoxyCodeLine{03721\ }
\DoxyCodeLine{03722\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03723\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03724\ \ \ \ \ GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{03725\ \ \ \ \ \ \ \ \ !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)>::value\ ||}
\DoxyCodeLine{03726\ \ \ \ \ \ \ \ \ \ \ \ \ ::std::tuple\_size<MatcherTuple>::value\ <\ 2,}
\DoxyCodeLine{03727\ \ \ \ \ \ \ \ \ use\_UnorderedElementsAre\_with\_hash\_tables);}
\DoxyCodeLine{03728\ }
\DoxyCodeLine{03729\ \ \ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)\ RawContainer;}
\DoxyCodeLine{03730\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ internal::StlContainerView<RawContainer>::type\ View;}
\DoxyCodeLine{03731\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ View::value\_type\ Element;}
\DoxyCodeLine{03732\ \ \ \ \ typedef\ ::std::vector<Matcher<const\ Element\&>\ >\ MatcherVec;}
\DoxyCodeLine{03733\ \ \ \ \ MatcherVec\ matchers;}
\DoxyCodeLine{03734\ \ \ \ \ matchers.reserve(::std::tuple\_size<MatcherTuple>::value);}
\DoxyCodeLine{03735\ \ \ \ \ TransformTupleValues(CastAndAppendTransform<const\ Element\&>(),\ matchers\_,}
\DoxyCodeLine{03736\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::back\_inserter(matchers));}
\DoxyCodeLine{03737\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ ElementsAreMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{03738\ \ \ \ \ \ \ \ \ matchers.begin(),\ matchers.end()));}
\DoxyCodeLine{03739\ \ \ \}}
\DoxyCodeLine{03740\ }
\DoxyCodeLine{03741\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03742\ \ \ \textcolor{keyword}{const}\ MatcherTuple\ matchers\_;}
\DoxyCodeLine{03743\ \};}
\DoxyCodeLine{03744\ }
\DoxyCodeLine{03745\ \textcolor{comment}{//\ Implements\ UnorderedElementsAreArray(),\ IsSubsetOf(),\ and\ IsSupersetOf().}}
\DoxyCodeLine{03746\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03747\ \textcolor{keyword}{class\ }UnorderedElementsAreArrayMatcher\ \{}
\DoxyCodeLine{03748\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03749\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{03750\ \ \ UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags\ match\_flags,}
\DoxyCodeLine{03751\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Iter\ first,\ Iter\ last)}
\DoxyCodeLine{03752\ \ \ \ \ \ \ :\ match\_flags\_(match\_flags),\ matchers\_(first,\ last)\ \{\}}
\DoxyCodeLine{03753\ }
\DoxyCodeLine{03754\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03755\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03756\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(}
\DoxyCodeLine{03757\ \ \ \ \ \ \ \ \ \textcolor{keyword}{new}\ UnorderedElementsAreMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{03758\ \ \ \ \ \ \ \ \ \ \ \ \ match\_flags\_,\ matchers\_.begin(),\ matchers\_.end()));}
\DoxyCodeLine{03759\ \ \ \}}
\DoxyCodeLine{03760\ }
\DoxyCodeLine{03761\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03762\ \ \ UnorderedMatcherRequire::Flags\ match\_flags\_;}
\DoxyCodeLine{03763\ \ \ ::std::vector<T>\ matchers\_;}
\DoxyCodeLine{03764\ \};}
\DoxyCodeLine{03765\ }
\DoxyCodeLine{03766\ \textcolor{comment}{//\ Implements\ ElementsAreArray().}}
\DoxyCodeLine{03767\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03768\ \textcolor{keyword}{class\ }ElementsAreArrayMatcher\ \{}
\DoxyCodeLine{03769\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03770\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{03771\ \ \ ElementsAreArrayMatcher(Iter\ first,\ Iter\ last)\ :\ matchers\_(first,\ last)\ \{\}}
\DoxyCodeLine{03772\ }
\DoxyCodeLine{03773\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{03774\ \ \ \textcolor{keyword}{operator}\ Matcher<Container>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03775\ \ \ \ \ GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{03776\ \ \ \ \ \ \ \ \ !IsHashTable<GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)>::value,}
\DoxyCodeLine{03777\ \ \ \ \ \ \ \ \ use\_UnorderedElementsAreArray\_with\_hash\_tables);}
\DoxyCodeLine{03778\ }
\DoxyCodeLine{03779\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Container>(\textcolor{keyword}{new}\ ElementsAreMatcherImpl<const\ Container\&>(}
\DoxyCodeLine{03780\ \ \ \ \ \ \ \ \ matchers\_.begin(),\ matchers\_.end()));}
\DoxyCodeLine{03781\ \ \ \}}
\DoxyCodeLine{03782\ }
\DoxyCodeLine{03783\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03784\ \ \ const\ ::std::vector<T>\ matchers\_;}
\DoxyCodeLine{03785\ \};}
\DoxyCodeLine{03786\ }
\DoxyCodeLine{03787\ \textcolor{comment}{//\ Given\ a\ 2-\/tuple\ matcher\ tm\ of\ type\ Tuple2Matcher\ and\ a\ value\ second}}
\DoxyCodeLine{03788\ \textcolor{comment}{//\ of\ type\ Second,\ BoundSecondMatcher<Tuple2Matcher,\ Second>(tm,}}
\DoxyCodeLine{03789\ \textcolor{comment}{//\ second)\ is\ a\ polymorphic\ matcher\ that\ matches\ a\ value\ x\ if\ and\ only\ if}}
\DoxyCodeLine{03790\ \textcolor{comment}{//\ tm\ matches\ tuple\ (x,\ second).\ \ Useful\ for\ implementing}}
\DoxyCodeLine{03791\ \textcolor{comment}{//\ UnorderedPointwise()\ in\ terms\ of\ UnorderedElementsAreArray().}}
\DoxyCodeLine{03792\ \textcolor{comment}{//}}
\DoxyCodeLine{03793\ \textcolor{comment}{//\ BoundSecondMatcher\ is\ copyable\ and\ assignable,\ as\ we\ need\ to\ put}}
\DoxyCodeLine{03794\ \textcolor{comment}{//\ instances\ of\ this\ class\ in\ a\ vector\ when\ implementing}}
\DoxyCodeLine{03795\ \textcolor{comment}{//\ UnorderedPointwise().}}
\DoxyCodeLine{03796\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple2Matcher,\ \textcolor{keyword}{typename}\ Second>}
\DoxyCodeLine{03797\ \textcolor{keyword}{class\ }BoundSecondMatcher\ \{}
\DoxyCodeLine{03798\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03799\ \ \ BoundSecondMatcher(\textcolor{keyword}{const}\ Tuple2Matcher\&\ tm,\ \textcolor{keyword}{const}\ Second\&\ second)}
\DoxyCodeLine{03800\ \ \ \ \ \ \ :\ tuple2\_matcher\_(tm),\ second\_value\_(second)\ \{\}}
\DoxyCodeLine{03801\ }
\DoxyCodeLine{03802\ \ \ BoundSecondMatcher(\textcolor{keyword}{const}\ BoundSecondMatcher\&\ other)\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{03803\ }
\DoxyCodeLine{03804\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03805\ \ \ \textcolor{keyword}{operator}\ Matcher<T>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03806\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ Impl<T>(tuple2\_matcher\_,\ second\_value\_));}
\DoxyCodeLine{03807\ \ \ \}}
\DoxyCodeLine{03808\ }
\DoxyCodeLine{03809\ \ \ \textcolor{comment}{//\ We\ have\ to\ define\ this\ for\ UnorderedPointwise()\ to\ compile\ in}}
\DoxyCodeLine{03810\ \ \ \textcolor{comment}{//\ C++98\ mode,\ as\ it\ puts\ BoundSecondMatcher\ instances\ in\ a\ vector,}}
\DoxyCodeLine{03811\ \ \ \textcolor{comment}{//\ which\ requires\ the\ elements\ to\ be\ assignable\ in\ C++98.\ \ The}}
\DoxyCodeLine{03812\ \ \ \textcolor{comment}{//\ compiler\ cannot\ generate\ the\ operator=\ for\ us,\ as\ Tuple2Matcher}}
\DoxyCodeLine{03813\ \ \ \textcolor{comment}{//\ and\ Second\ may\ not\ be\ assignable.}}
\DoxyCodeLine{03814\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{03815\ \ \ \textcolor{comment}{//\ However,\ this\ should\ never\ be\ called,\ so\ the\ implementation\ just}}
\DoxyCodeLine{03816\ \ \ \textcolor{comment}{//\ need\ to\ assert.}}
\DoxyCodeLine{03817\ \ \ \textcolor{keywordtype}{void}\ operator=(\textcolor{keyword}{const}\ BoundSecondMatcher\&\ \textcolor{comment}{/*rhs*/})\ \{}
\DoxyCodeLine{03818\ \ \ \ \ GTEST\_LOG\_(FATAL)\ <<\ \textcolor{stringliteral}{"{}BoundSecondMatcher\ should\ never\ be\ assigned."{}};}
\DoxyCodeLine{03819\ \ \ \}}
\DoxyCodeLine{03820\ }
\DoxyCodeLine{03821\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03822\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03823\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<T>\ \{}
\DoxyCodeLine{03824\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03825\ \ \ \ \ typedef\ ::std::tuple<T,\ Second>\ ArgTuple;}
\DoxyCodeLine{03826\ }
\DoxyCodeLine{03827\ \ \ \ \ Impl(\textcolor{keyword}{const}\ Tuple2Matcher\&\ tm,\ \textcolor{keyword}{const}\ Second\&\ second)}
\DoxyCodeLine{03828\ \ \ \ \ \ \ \ \ :\ mono\_tuple2\_matcher\_(SafeMatcherCast<const\ ArgTuple\&>(tm)),}
\DoxyCodeLine{03829\ \ \ \ \ \ \ \ \ \ \ second\_value\_(second)\ \{\}}
\DoxyCodeLine{03830\ }
\DoxyCodeLine{03831\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03832\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}and\ "{}};}
\DoxyCodeLine{03833\ \ \ \ \ \ \ UniversalPrint(second\_value\_,\ os);}
\DoxyCodeLine{03834\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{03835\ \ \ \ \ \ \ mono\_tuple2\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{03836\ \ \ \ \ \}}
\DoxyCodeLine{03837\ }
\DoxyCodeLine{03838\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\ x,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03839\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ mono\_tuple2\_matcher\_.MatchAndExplain(ArgTuple(x,\ second\_value\_),}
\DoxyCodeLine{03840\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ listener);}
\DoxyCodeLine{03841\ \ \ \ \ \}}
\DoxyCodeLine{03842\ }
\DoxyCodeLine{03843\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03844\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ ArgTuple\&>\ mono\_tuple2\_matcher\_;}
\DoxyCodeLine{03845\ \ \ \ \ \textcolor{keyword}{const}\ Second\ second\_value\_;}
\DoxyCodeLine{03846\ \ \ \};}
\DoxyCodeLine{03847\ }
\DoxyCodeLine{03848\ \ \ \textcolor{keyword}{const}\ Tuple2Matcher\ tuple2\_matcher\_;}
\DoxyCodeLine{03849\ \ \ \textcolor{keyword}{const}\ Second\ second\_value\_;}
\DoxyCodeLine{03850\ \};}
\DoxyCodeLine{03851\ }
\DoxyCodeLine{03852\ \textcolor{comment}{//\ Given\ a\ 2-\/tuple\ matcher\ tm\ and\ a\ value\ second,}}
\DoxyCodeLine{03853\ \textcolor{comment}{//\ MatcherBindSecond(tm,\ second)\ returns\ a\ matcher\ that\ matches\ a}}
\DoxyCodeLine{03854\ \textcolor{comment}{//\ value\ x\ if\ and\ only\ if\ tm\ matches\ tuple\ (x,\ second).\ \ Useful\ for}}
\DoxyCodeLine{03855\ \textcolor{comment}{//\ implementing\ UnorderedPointwise()\ in\ terms\ of\ UnorderedElementsAreArray().}}
\DoxyCodeLine{03856\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple2Matcher,\ \textcolor{keyword}{typename}\ Second>}
\DoxyCodeLine{03857\ BoundSecondMatcher<Tuple2Matcher,\ Second>\ MatcherBindSecond(}
\DoxyCodeLine{03858\ \ \ \ \ \textcolor{keyword}{const}\ Tuple2Matcher\&\ tm,\ \textcolor{keyword}{const}\ Second\&\ second)\ \{}
\DoxyCodeLine{03859\ \ \ \textcolor{keywordflow}{return}\ BoundSecondMatcher<Tuple2Matcher,\ Second>(tm,\ second);}
\DoxyCodeLine{03860\ \}}
\DoxyCodeLine{03861\ }
\DoxyCodeLine{03862\ \textcolor{comment}{//\ Returns\ the\ description\ for\ a\ matcher\ defined\ using\ the\ MATCHER*()}}
\DoxyCodeLine{03863\ \textcolor{comment}{//\ macro\ where\ the\ user-\/supplied\ description\ string\ is\ "{}"{},\ if}}
\DoxyCodeLine{03864\ \textcolor{comment}{//\ 'negation'\ is\ false;\ otherwise\ returns\ the\ description\ of\ the}}
\DoxyCodeLine{03865\ \textcolor{comment}{//\ negation\ of\ the\ matcher.\ \ 'param\_values'\ contains\ a\ list\ of\ strings}}
\DoxyCodeLine{03866\ \textcolor{comment}{//\ that\ are\ the\ print-\/out\ of\ the\ matcher's\ parameters.}}
\DoxyCodeLine{03867\ GTEST\_API\_\ std::string\ FormatMatcherDescription(\textcolor{keywordtype}{bool}\ negation,}
\DoxyCodeLine{03868\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ matcher\_name,}
\DoxyCodeLine{03869\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Strings\&\ param\_values);}
\DoxyCodeLine{03870\ }
\DoxyCodeLine{03871\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ checks\ the\ value\ of\ a\ optional<>\ type\ variable.}}
\DoxyCodeLine{03872\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ValueMatcher>}
\DoxyCodeLine{03873\ \textcolor{keyword}{class\ }OptionalMatcher\ \{}
\DoxyCodeLine{03874\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03875\ \ \ \textcolor{keyword}{explicit}\ OptionalMatcher(\textcolor{keyword}{const}\ ValueMatcher\&\ value\_matcher)}
\DoxyCodeLine{03876\ \ \ \ \ \ \ :\ value\_matcher\_(value\_matcher)\ \{\}}
\DoxyCodeLine{03877\ }
\DoxyCodeLine{03878\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Optional>}
\DoxyCodeLine{03879\ \ \ \textcolor{keyword}{operator}\ Matcher<Optional>()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03880\ \ \ \ \ \textcolor{keywordflow}{return}\ Matcher<Optional>(\textcolor{keyword}{new}\ Impl<const\ Optional\&>(value\_matcher\_));}
\DoxyCodeLine{03881\ \ \ \}}
\DoxyCodeLine{03882\ }
\DoxyCodeLine{03883\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Optional>}
\DoxyCodeLine{03884\ \ \ \textcolor{keyword}{class\ }Impl\ :\ \textcolor{keyword}{public}\ MatcherInterface<Optional>\ \{}
\DoxyCodeLine{03885\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03886\ \ \ \ \ \textcolor{keyword}{typedef}\ GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Optional)\ OptionalView;}
\DoxyCodeLine{03887\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ OptionalView::value\_type\ ValueType;}
\DoxyCodeLine{03888\ \ \ \ \ \textcolor{keyword}{explicit}\ Impl(\textcolor{keyword}{const}\ ValueMatcher\&\ value\_matcher)}
\DoxyCodeLine{03889\ \ \ \ \ \ \ \ \ :\ value\_matcher\_(MatcherCast<ValueType>(value\_matcher))\ \{\}}
\DoxyCodeLine{03890\ }
\DoxyCodeLine{03891\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03892\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}value\ "{}};}
\DoxyCodeLine{03893\ \ \ \ \ \ \ value\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{03894\ \ \ \ \ \}}
\DoxyCodeLine{03895\ }
\DoxyCodeLine{03896\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03897\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}value\ "{}};}
\DoxyCodeLine{03898\ \ \ \ \ \ \ value\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{03899\ \ \ \ \ \}}
\DoxyCodeLine{03900\ }
\DoxyCodeLine{03901\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Optional\ optional,}
\DoxyCodeLine{03902\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{03903\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!optional)\ \{}
\DoxyCodeLine{03904\ \ \ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ not\ engaged"{}};}
\DoxyCodeLine{03905\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03906\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03907\ \ \ \ \ \ \ \textcolor{keyword}{const}\ ValueType\&\ value\ =\ *optional;}
\DoxyCodeLine{03908\ \ \ \ \ \ \ StringMatchResultListener\ value\_listener;}
\DoxyCodeLine{03909\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ value\_matcher\_.MatchAndExplain(value,\ \&value\_listener);}
\DoxyCodeLine{03910\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ "{}}\ <<\ PrintToString(value)}
\DoxyCodeLine{03911\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (match\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{03912\ \ \ \ \ \ \ PrintIfNotEmpty(value\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{03913\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{03914\ \ \ \ \ \}}
\DoxyCodeLine{03915\ }
\DoxyCodeLine{03916\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03917\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<ValueType>\ value\_matcher\_;}
\DoxyCodeLine{03918\ \ \ \};}
\DoxyCodeLine{03919\ }
\DoxyCodeLine{03920\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03921\ \ \ \textcolor{keyword}{const}\ ValueMatcher\ value\_matcher\_;}
\DoxyCodeLine{03922\ \};}
\DoxyCodeLine{03923\ }
\DoxyCodeLine{03924\ \textcolor{keyword}{namespace\ }variant\_matcher\ \{}
\DoxyCodeLine{03925\ \textcolor{comment}{//\ Overloads\ to\ allow\ VariantMatcher\ to\ do\ proper\ ADL\ lookup.}}
\DoxyCodeLine{03926\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03927\ \textcolor{keywordtype}{void}\ holds\_alternative()\ \{\}}
\DoxyCodeLine{03928\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03929\ \textcolor{keywordtype}{void}\ get()\ \{\}}
\DoxyCodeLine{03930\ }
\DoxyCodeLine{03931\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ checks\ the\ value\ of\ a\ variant<>\ type\ variable.}}
\DoxyCodeLine{03932\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03933\ \textcolor{keyword}{class\ }VariantMatcher\ \{}
\DoxyCodeLine{03934\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03935\ \ \ \textcolor{keyword}{explicit}\ VariantMatcher(\mbox{\hyperlink{classtesting_1_1_matcher}{::testing::Matcher<const\ T\&>}}\ matcher)}
\DoxyCodeLine{03936\ \ \ \ \ \ \ :\ matcher\_(std::move(matcher))\ \{\}}
\DoxyCodeLine{03937\ }
\DoxyCodeLine{03938\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Variant>}
\DoxyCodeLine{03939\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ Variant\&\ value,}
\DoxyCodeLine{03940\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03941\ \ \ \ \ \textcolor{keyword}{using\ }std::get;}
\DoxyCodeLine{03942\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{03943\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ holds\_alternative<T>(value)\ \&\&\ matcher\_.Matches(get<T>(value));}
\DoxyCodeLine{03944\ \ \ \ \ \}}
\DoxyCodeLine{03945\ }
\DoxyCodeLine{03946\ \ \ \ \ \textcolor{keywordflow}{if}\ (!holds\_alternative<T>(value))\ \{}
\DoxyCodeLine{03947\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ is\ not\ of\ type\ '"{}}\ <<\ GetTypeName()\ <<\ \textcolor{stringliteral}{"{}'"{}};}
\DoxyCodeLine{03948\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{03949\ \ \ \ \ \}}
\DoxyCodeLine{03950\ }
\DoxyCodeLine{03951\ \ \ \ \ \textcolor{keyword}{const}\ T\&\ elem\ =\ get<T>(value);}
\DoxyCodeLine{03952\ \ \ \ \ StringMatchResultListener\ elem\_listener;}
\DoxyCodeLine{03953\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ matcher\_.MatchAndExplain(elem,\ \&elem\_listener);}
\DoxyCodeLine{03954\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ "{}}\ <<\ PrintToString(elem)}
\DoxyCodeLine{03955\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (match\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{03956\ \ \ \ \ PrintIfNotEmpty(elem\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{03957\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{03958\ \ \ \}}
\DoxyCodeLine{03959\ }
\DoxyCodeLine{03960\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03961\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ a\ variant<>\ with\ value\ of\ type\ '"{}}\ <<\ GetTypeName()}
\DoxyCodeLine{03962\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}'\ and\ the\ value\ "{}};}
\DoxyCodeLine{03963\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{03964\ \ \ \}}
\DoxyCodeLine{03965\ }
\DoxyCodeLine{03966\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{03967\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ a\ variant<>\ with\ value\ of\ type\ other\ than\ '"{}}\ <<\ GetTypeName()}
\DoxyCodeLine{03968\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}'\ or\ the\ value\ "{}};}
\DoxyCodeLine{03969\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{03970\ \ \ \}}
\DoxyCodeLine{03971\ }
\DoxyCodeLine{03972\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03973\ \ \ \textcolor{keyword}{static}\ std::string\ GetTypeName()\ \{}
\DoxyCodeLine{03974\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{03975\ \ \ \ \ GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(}
\DoxyCodeLine{03976\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ internal::GetTypeName<T>());}
\DoxyCodeLine{03977\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03978\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}the\ element\ type"{}};}
\DoxyCodeLine{03979\ \ \ \}}
\DoxyCodeLine{03980\ }
\DoxyCodeLine{03981\ \ \ const\ ::testing::Matcher<const\ T\&>\ matcher\_;}
\DoxyCodeLine{03982\ \};}
\DoxyCodeLine{03983\ }
\DoxyCodeLine{03984\ \}\ \ \textcolor{comment}{//\ namespace\ variant\_matcher}}
\DoxyCodeLine{03985\ }
\DoxyCodeLine{03986\ \textcolor{keyword}{namespace\ }any\_cast\_matcher\ \{}
\DoxyCodeLine{03987\ }
\DoxyCodeLine{03988\ \textcolor{comment}{//\ Overloads\ to\ allow\ AnyCastMatcher\ to\ do\ proper\ ADL\ lookup.}}
\DoxyCodeLine{03989\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03990\ \textcolor{keywordtype}{void}\ any\_cast()\ \{\}}
\DoxyCodeLine{03991\ }
\DoxyCodeLine{03992\ \textcolor{comment}{//\ Implements\ a\ matcher\ that\ any\_casts\ the\ value.}}
\DoxyCodeLine{03993\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03994\ \textcolor{keyword}{class\ }AnyCastMatcher\ \{}
\DoxyCodeLine{03995\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03996\ \ \ \textcolor{keyword}{explicit}\ AnyCastMatcher(const\ ::testing::Matcher<const\ T\&>\&\ matcher)}
\DoxyCodeLine{03997\ \ \ \ \ \ \ :\ matcher\_(matcher)\ \{\}}
\DoxyCodeLine{03998\ }
\DoxyCodeLine{03999\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ AnyType>}
\DoxyCodeLine{04000\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ AnyType\&\ value,}
\DoxyCodeLine{04001\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04002\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \{}
\DoxyCodeLine{04003\ \ \ \ \ \ \ \textcolor{keyword}{const}\ T*\ ptr\ =\ any\_cast<T>(\&value);}
\DoxyCodeLine{04004\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ptr\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ matcher\_.Matches(*ptr);}
\DoxyCodeLine{04005\ \ \ \ \ \}}
\DoxyCodeLine{04006\ }
\DoxyCodeLine{04007\ \ \ \ \ \textcolor{keyword}{const}\ T*\ elem\ =\ any\_cast<T>(\&value);}
\DoxyCodeLine{04008\ \ \ \ \ \textcolor{keywordflow}{if}\ (elem\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{04009\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ is\ not\ of\ type\ '"{}}\ <<\ GetTypeName()\ <<\ \textcolor{stringliteral}{"{}'"{}};}
\DoxyCodeLine{04010\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{04011\ \ \ \ \ \}}
\DoxyCodeLine{04012\ }
\DoxyCodeLine{04013\ \ \ \ \ StringMatchResultListener\ elem\_listener;}
\DoxyCodeLine{04014\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ matcher\_.MatchAndExplain(*elem,\ \&elem\_listener);}
\DoxyCodeLine{04015\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}whose\ value\ "{}}\ <<\ PrintToString(*elem)}
\DoxyCodeLine{04016\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ (match\ ?\ \textcolor{stringliteral}{"{}\ matches"{}}\ :\ \textcolor{stringliteral}{"{}\ doesn't\ match"{}});}
\DoxyCodeLine{04017\ \ \ \ \ PrintIfNotEmpty(elem\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{04018\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{04019\ \ \ \}}
\DoxyCodeLine{04020\ }
\DoxyCodeLine{04021\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04022\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ 'any'\ type\ with\ value\ of\ type\ '"{}}\ <<\ GetTypeName()}
\DoxyCodeLine{04023\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}'\ and\ the\ value\ "{}};}
\DoxyCodeLine{04024\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{04025\ \ \ \}}
\DoxyCodeLine{04026\ }
\DoxyCodeLine{04027\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04028\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ 'any'\ type\ with\ value\ of\ type\ other\ than\ '"{}}\ <<\ GetTypeName()}
\DoxyCodeLine{04029\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}'\ or\ the\ value\ "{}};}
\DoxyCodeLine{04030\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{04031\ \ \ \}}
\DoxyCodeLine{04032\ }
\DoxyCodeLine{04033\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04034\ \ \ \textcolor{keyword}{static}\ std::string\ GetTypeName()\ \{}
\DoxyCodeLine{04035\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{04036\ \ \ \ \ GTEST\_SUPPRESS\_UNREACHABLE\_CODE\_WARNING\_BELOW\_(}
\DoxyCodeLine{04037\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ internal::GetTypeName<T>());}
\DoxyCodeLine{04038\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{04039\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}the\ element\ type"{}};}
\DoxyCodeLine{04040\ \ \ \}}
\DoxyCodeLine{04041\ }
\DoxyCodeLine{04042\ \ \ const\ ::testing::Matcher<const\ T\&>\ matcher\_;}
\DoxyCodeLine{04043\ \};}
\DoxyCodeLine{04044\ }
\DoxyCodeLine{04045\ \}\ \ \textcolor{comment}{//\ namespace\ any\_cast\_matcher}}
\DoxyCodeLine{04046\ }
\DoxyCodeLine{04047\ \textcolor{comment}{//\ Implements\ the\ Args()\ matcher.}}
\DoxyCodeLine{04048\ \textcolor{keyword}{template}\ <\textcolor{keyword}{class\ }ArgsTuple,\ \textcolor{keywordtype}{size\_t}...\ k>}
\DoxyCodeLine{04049\ \textcolor{keyword}{class\ }ArgsMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<ArgsTuple>\ \{}
\DoxyCodeLine{04050\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04051\ \ \ \textcolor{keyword}{using\ }RawArgsTuple\ =\ \textcolor{keyword}{typename}\ std::decay<ArgsTuple>::type;}
\DoxyCodeLine{04052\ \ \ \textcolor{keyword}{using\ }SelectedArgs\ =}
\DoxyCodeLine{04053\ \ \ \ \ \ \ std::tuple<typename\ std::tuple\_element<k,\ RawArgsTuple>::type...>;}
\DoxyCodeLine{04054\ \ \ \textcolor{keyword}{using\ }MonomorphicInnerMatcher\ =\ Matcher<const\ SelectedArgs\&>;}
\DoxyCodeLine{04055\ }
\DoxyCodeLine{04056\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04057\ \ \ \textcolor{keyword}{explicit}\ ArgsMatcherImpl(\textcolor{keyword}{const}\ InnerMatcher\&\ inner\_matcher)}
\DoxyCodeLine{04058\ \ \ \ \ \ \ :\ inner\_matcher\_(SafeMatcherCast<const\ SelectedArgs\&>(inner\_matcher))\ \{\}}
\DoxyCodeLine{04059\ }
\DoxyCodeLine{04060\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(ArgsTuple\ args,}
\DoxyCodeLine{04061\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04062\ \ \ \ \ \textcolor{comment}{//\ Workaround\ spurious\ C4100\ on\ MSVC<=15.7\ when\ k\ is\ empty.}}
\DoxyCodeLine{04063\ \ \ \ \ (void)args;}
\DoxyCodeLine{04064\ \ \ \ \ \textcolor{keyword}{const}\ SelectedArgs\&\ selected\_args\ =}
\DoxyCodeLine{04065\ \ \ \ \ \ \ \ \ std::forward\_as\_tuple(std::get<k>(args)...);}
\DoxyCodeLine{04066\ \ \ \ \ \textcolor{keywordflow}{if}\ (!listener-\/>IsInterested())\ \textcolor{keywordflow}{return}\ inner\_matcher\_.Matches(selected\_args);}
\DoxyCodeLine{04067\ }
\DoxyCodeLine{04068\ \ \ \ \ PrintIndices(listener-\/>stream());}
\DoxyCodeLine{04069\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}are\ "{}}\ <<\ PrintToString(selected\_args);}
\DoxyCodeLine{04070\ }
\DoxyCodeLine{04071\ \ \ \ \ StringMatchResultListener\ inner\_listener;}
\DoxyCodeLine{04072\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =}
\DoxyCodeLine{04073\ \ \ \ \ \ \ \ \ inner\_matcher\_.MatchAndExplain(selected\_args,\ \&inner\_listener);}
\DoxyCodeLine{04074\ \ \ \ \ PrintIfNotEmpty(inner\_listener.str(),\ listener-\/>stream());}
\DoxyCodeLine{04075\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{04076\ \ \ \}}
\DoxyCodeLine{04077\ }
\DoxyCodeLine{04078\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04079\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ a\ tuple\ "{}};}
\DoxyCodeLine{04080\ \ \ \ \ PrintIndices(os);}
\DoxyCodeLine{04081\ \ \ \ \ inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{04082\ \ \ \}}
\DoxyCodeLine{04083\ }
\DoxyCodeLine{04084\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(::std::ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{04085\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ a\ tuple\ "{}};}
\DoxyCodeLine{04086\ \ \ \ \ PrintIndices(os);}
\DoxyCodeLine{04087\ \ \ \ \ inner\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{04088\ \ \ \}}
\DoxyCodeLine{04089\ }
\DoxyCodeLine{04090\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04091\ \ \ \textcolor{comment}{//\ Prints\ the\ indices\ of\ the\ selected\ fields.}}
\DoxyCodeLine{04092\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ PrintIndices(::std::ostream*\ os)\ \{}
\DoxyCodeLine{04093\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}whose\ fields\ ("{}};}
\DoxyCodeLine{04094\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ sep\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{04095\ \ \ \ \ \textcolor{comment}{//\ Workaround\ spurious\ C4189\ on\ MSVC<=15.7\ when\ k\ is\ empty.}}
\DoxyCodeLine{04096\ \ \ \ \ (void)sep;}
\DoxyCodeLine{04097\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ dummy[]\ =\ \{\textcolor{stringliteral}{"{}"{}},\ (*os\ <<\ sep\ <<\ \textcolor{stringliteral}{"{}\#"{}}\ <<\ k,\ sep\ =\ \textcolor{stringliteral}{"{},\ "{}})...\};}
\DoxyCodeLine{04098\ \ \ \ \ (void)dummy;}
\DoxyCodeLine{04099\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{})\ "{}};}
\DoxyCodeLine{04100\ \ \ \}}
\DoxyCodeLine{04101\ }
\DoxyCodeLine{04102\ \ \ MonomorphicInnerMatcher\ inner\_matcher\_;}
\DoxyCodeLine{04103\ \};}
\DoxyCodeLine{04104\ }
\DoxyCodeLine{04105\ \textcolor{keyword}{template}\ <\textcolor{keyword}{class\ }InnerMatcher,\ \textcolor{keywordtype}{size\_t}...\ k>}
\DoxyCodeLine{04106\ \textcolor{keyword}{class\ }ArgsMatcher\ \{}
\DoxyCodeLine{04107\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04108\ \ \ \textcolor{keyword}{explicit}\ ArgsMatcher(InnerMatcher\ inner\_matcher)}
\DoxyCodeLine{04109\ \ \ \ \ \ \ :\ inner\_matcher\_(std::move(inner\_matcher))\ \{\}}
\DoxyCodeLine{04110\ }
\DoxyCodeLine{04111\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ArgsTuple>}
\DoxyCodeLine{04112\ \ \ \textcolor{keyword}{operator}\ Matcher<ArgsTuple>()\textcolor{keyword}{\ const\ }\{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{04113\ \ \ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ ArgsMatcherImpl<ArgsTuple,\ k...>(inner\_matcher\_));}
\DoxyCodeLine{04114\ \ \ \}}
\DoxyCodeLine{04115\ }
\DoxyCodeLine{04116\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04117\ \ \ InnerMatcher\ inner\_matcher\_;}
\DoxyCodeLine{04118\ \};}
\DoxyCodeLine{04119\ }
\DoxyCodeLine{04120\ \}\ \ \textcolor{comment}{//\ namespace\ internal}}
\DoxyCodeLine{04121\ }
\DoxyCodeLine{04122\ \textcolor{comment}{//\ ElementsAreArray(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{04123\ \textcolor{comment}{//\ ElementsAreArray(pointer,\ count)}}
\DoxyCodeLine{04124\ \textcolor{comment}{//\ ElementsAreArray(array)}}
\DoxyCodeLine{04125\ \textcolor{comment}{//\ ElementsAreArray(container)}}
\DoxyCodeLine{04126\ \textcolor{comment}{//\ ElementsAreArray(\{\ e1,\ e2,\ ...,\ en\ \})}}
\DoxyCodeLine{04127\ \textcolor{comment}{//}}
\DoxyCodeLine{04128\ \textcolor{comment}{//\ The\ ElementsAreArray()\ functions\ are\ like\ ElementsAre(...),\ except}}
\DoxyCodeLine{04129\ \textcolor{comment}{//\ that\ they\ are\ given\ a\ homogeneous\ sequence\ rather\ than\ taking\ each}}
\DoxyCodeLine{04130\ \textcolor{comment}{//\ element\ as\ a\ function\ argument.\ The\ sequence\ can\ be\ specified\ as\ an}}
\DoxyCodeLine{04131\ \textcolor{comment}{//\ array,\ a\ pointer\ and\ count,\ a\ vector,\ an\ initializer\ list,\ or\ an}}
\DoxyCodeLine{04132\ \textcolor{comment}{//\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the\ underlying\ sequence}}
\DoxyCodeLine{04133\ \textcolor{comment}{//\ can\ be\ either\ a\ sequence\ of\ values\ or\ a\ sequence\ of\ matchers.}}
\DoxyCodeLine{04134\ \textcolor{comment}{//}}
\DoxyCodeLine{04135\ \textcolor{comment}{//\ All\ forms\ of\ ElementsAreArray()\ make\ a\ copy\ of\ the\ input\ matcher\ sequence.}}
\DoxyCodeLine{04136\ }
\DoxyCodeLine{04137\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{04138\ \textcolor{keyword}{inline}\ internal::ElementsAreArrayMatcher<}
\DoxyCodeLine{04139\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{04140\ ElementsAreArray(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{04141\ \ \ \textcolor{keyword}{typedef}\ typename\ ::std::iterator\_traits<Iter>::value\_type\ T;}
\DoxyCodeLine{04142\ \ \ \textcolor{keywordflow}{return}\ internal::ElementsAreArrayMatcher<T>(first,\ last);}
\DoxyCodeLine{04143\ \}}
\DoxyCodeLine{04144\ }
\DoxyCodeLine{04145\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04146\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ ElementsAreArray(\textcolor{keyword}{const}\ T*\ pointer,\ \textcolor{keywordtype}{size\_t}\ count)}
\DoxyCodeLine{04147\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(ElementsAreArray(pointer,\ pointer\ +\ count))\ \{}
\DoxyCodeLine{04148\ \ \ \textcolor{keywordflow}{return}\ ElementsAreArray(pointer,\ pointer\ +\ count);}
\DoxyCodeLine{04149\ \}}
\DoxyCodeLine{04150\ }
\DoxyCodeLine{04151\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{04152\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ ElementsAreArray(\textcolor{keyword}{const}\ T\ (\&array)[N])}
\DoxyCodeLine{04153\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(ElementsAreArray(array,\ N))\ \{}
\DoxyCodeLine{04154\ \ \ \textcolor{keywordflow}{return}\ ElementsAreArray(array,\ N);}
\DoxyCodeLine{04155\ \}}
\DoxyCodeLine{04156\ }
\DoxyCodeLine{04157\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04158\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ ElementsAreArray(\textcolor{keyword}{const}\ Container\&\ container)}
\DoxyCodeLine{04159\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(ElementsAreArray(container.begin(),\ container.end()))\ \{}
\DoxyCodeLine{04160\ \ \ \textcolor{keywordflow}{return}\ ElementsAreArray(container.begin(),\ container.end());}
\DoxyCodeLine{04161\ \}}
\DoxyCodeLine{04162\ }
\DoxyCodeLine{04163\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04164\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ ElementsAreArray(::std::initializer\_list<T>\ xs)}
\DoxyCodeLine{04165\ \ \ \ \ -\/>\ \textcolor{keyword}{decltype}(ElementsAreArray(xs.begin(),\ xs.end()))\ \{}
\DoxyCodeLine{04166\ \ \ \textcolor{keywordflow}{return}\ ElementsAreArray(xs.begin(),\ xs.end());}
\DoxyCodeLine{04167\ \}}
\DoxyCodeLine{04168\ }
\DoxyCodeLine{04169\ \textcolor{comment}{//\ UnorderedElementsAreArray(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{04170\ \textcolor{comment}{//\ UnorderedElementsAreArray(pointer,\ count)}}
\DoxyCodeLine{04171\ \textcolor{comment}{//\ UnorderedElementsAreArray(array)}}
\DoxyCodeLine{04172\ \textcolor{comment}{//\ UnorderedElementsAreArray(container)}}
\DoxyCodeLine{04173\ \textcolor{comment}{//\ UnorderedElementsAreArray(\{\ e1,\ e2,\ ...,\ en\ \})}}
\DoxyCodeLine{04174\ \textcolor{comment}{//}}
\DoxyCodeLine{04175\ \textcolor{comment}{//\ UnorderedElementsAreArray()\ verifies\ that\ a\ bijective\ mapping\ onto\ a}}
\DoxyCodeLine{04176\ \textcolor{comment}{//\ collection\ of\ matchers\ exists.}}
\DoxyCodeLine{04177\ \textcolor{comment}{//}}
\DoxyCodeLine{04178\ \textcolor{comment}{//\ The\ matchers\ can\ be\ specified\ as\ an\ array,\ a\ pointer\ and\ count,\ a\ container,}}
\DoxyCodeLine{04179\ \textcolor{comment}{//\ an\ initializer\ list,\ or\ an\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the}}
\DoxyCodeLine{04180\ \textcolor{comment}{//\ underlying\ matchers\ can\ be\ either\ values\ or\ matchers.}}
\DoxyCodeLine{04181\ }
\DoxyCodeLine{04182\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{04183\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04184\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{04185\ UnorderedElementsAreArray(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{04186\ \ \ \textcolor{keyword}{typedef}\ typename\ ::std::iterator\_traits<Iter>::value\_type\ T;}
\DoxyCodeLine{04187\ \ \ \textcolor{keywordflow}{return}\ internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{04188\ \ \ \ \ \ \ internal::UnorderedMatcherRequire::ExactMatch,\ first,\ last);}
\DoxyCodeLine{04189\ \}}
\DoxyCodeLine{04190\ }
\DoxyCodeLine{04191\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04192\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>}
\DoxyCodeLine{04193\ UnorderedElementsAreArray(\textcolor{keyword}{const}\ T*\ pointer,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{04194\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(pointer,\ pointer\ +\ count);}
\DoxyCodeLine{04195\ \}}
\DoxyCodeLine{04196\ }
\DoxyCodeLine{04197\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{04198\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>}
\DoxyCodeLine{04199\ UnorderedElementsAreArray(\textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{04200\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(array,\ N);}
\DoxyCodeLine{04201\ \}}
\DoxyCodeLine{04202\ }
\DoxyCodeLine{04203\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04204\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04205\ \ \ \ \ \textcolor{keyword}{typename}\ Container::value\_type>}
\DoxyCodeLine{04206\ UnorderedElementsAreArray(\textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{04207\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(container.begin(),\ container.end());}
\DoxyCodeLine{04208\ \}}
\DoxyCodeLine{04209\ }
\DoxyCodeLine{04210\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04211\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>}
\DoxyCodeLine{04212\ UnorderedElementsAreArray(::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{04213\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(xs.begin(),\ xs.end());}
\DoxyCodeLine{04214\ \}}
\DoxyCodeLine{04215\ }
\DoxyCodeLine{04216\ \textcolor{comment}{//\ \_\ is\ a\ matcher\ that\ matches\ anything\ of\ any\ type.}}
\DoxyCodeLine{04217\ \textcolor{comment}{//}}
\DoxyCodeLine{04218\ \textcolor{comment}{//\ This\ definition\ is\ fine\ as:}}
\DoxyCodeLine{04219\ \textcolor{comment}{//}}
\DoxyCodeLine{04220\ \textcolor{comment}{//\ \ \ 1.\ The\ C++\ standard\ permits\ using\ the\ name\ \_\ in\ a\ namespace\ that}}
\DoxyCodeLine{04221\ \textcolor{comment}{//\ \ \ \ \ \ is\ not\ the\ global\ namespace\ or\ ::std.}}
\DoxyCodeLine{04222\ \textcolor{comment}{//\ \ \ 2.\ The\ AnythingMatcher\ class\ has\ no\ data\ member\ or\ constructor,}}
\DoxyCodeLine{04223\ \textcolor{comment}{//\ \ \ \ \ \ so\ it's\ OK\ to\ create\ global\ variables\ of\ this\ type.}}
\DoxyCodeLine{04224\ \textcolor{comment}{//\ \ \ 3.\ c-\/style\ has\ approved\ of\ using\ \_\ in\ this\ case.}}
\DoxyCodeLine{04225\ \textcolor{keyword}{const}\ internal::AnythingMatcher\ \_\ =\ \{\};}
\DoxyCodeLine{04226\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ value\ of\ the\ given\ type\ T.}}
\DoxyCodeLine{04227\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04228\ \textcolor{keyword}{inline}\ Matcher<T>\ A()\ \{}
\DoxyCodeLine{04229\ \ \ \textcolor{keywordflow}{return}\ \_;}
\DoxyCodeLine{04230\ \}}
\DoxyCodeLine{04231\ }
\DoxyCodeLine{04232\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ value\ of\ the\ given\ type\ T.}}
\DoxyCodeLine{04233\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04234\ \textcolor{keyword}{inline}\ Matcher<T>\ An()\ \{}
\DoxyCodeLine{04235\ \ \ \textcolor{keywordflow}{return}\ \_;}
\DoxyCodeLine{04236\ \}}
\DoxyCodeLine{04237\ }
\DoxyCodeLine{04238\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{04239\ Matcher<T>\ internal::MatcherCastImpl<T,\ M>::CastImpl(}
\DoxyCodeLine{04240\ \ \ \ \ \textcolor{keyword}{const}\ M\&\ value,\ std::false\_type\ \textcolor{comment}{/*\ convertible\_to\_matcher\ */},}
\DoxyCodeLine{04241\ \ \ \ \ std::false\_type\ \textcolor{comment}{/*\ convertible\_to\_T\ */})\ \{}
\DoxyCodeLine{04242\ \ \ \textcolor{keywordflow}{return}\ Eq(value);}
\DoxyCodeLine{04243\ \}}
\DoxyCodeLine{04244\ }
\DoxyCodeLine{04245\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ any\ NULL\ pointer.}}
\DoxyCodeLine{04246\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::IsNullMatcher\ >\ IsNull()\ \{}
\DoxyCodeLine{04247\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::IsNullMatcher());}
\DoxyCodeLine{04248\ \}}
\DoxyCodeLine{04249\ }
\DoxyCodeLine{04250\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ any\ non-\/NULL\ pointer.}}
\DoxyCodeLine{04251\ \textcolor{comment}{//\ This\ is\ convenient\ as\ Not(NULL)\ doesn't\ compile\ (the\ compiler}}
\DoxyCodeLine{04252\ \textcolor{comment}{//\ thinks\ that\ that\ expression\ is\ comparing\ a\ pointer\ with\ an\ integer).}}
\DoxyCodeLine{04253\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::NotNullMatcher\ >\ NotNull()\ \{}
\DoxyCodeLine{04254\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::NotNullMatcher());}
\DoxyCodeLine{04255\ \}}
\DoxyCodeLine{04256\ }
\DoxyCodeLine{04257\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ any\ argument\ that}}
\DoxyCodeLine{04258\ \textcolor{comment}{//\ references\ variable\ x.}}
\DoxyCodeLine{04259\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04260\ \textcolor{keyword}{inline}\ internal::RefMatcher<T\&>\ Ref(T\&\ x)\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{04261\ \ \ \textcolor{keywordflow}{return}\ internal::RefMatcher<T\&>(x);}
\DoxyCodeLine{04262\ \}}
\DoxyCodeLine{04263\ }
\DoxyCodeLine{04264\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ any\ NaN\ floating\ point.}}
\DoxyCodeLine{04265\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::IsNanMatcher>\ IsNan()\ \{}
\DoxyCodeLine{04266\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::IsNanMatcher());}
\DoxyCodeLine{04267\ \}}
\DoxyCodeLine{04268\ }
\DoxyCodeLine{04269\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ double\ argument\ approximately}}
\DoxyCodeLine{04270\ \textcolor{comment}{//\ equal\ to\ rhs,\ where\ two\ NANs\ are\ considered\ unequal.}}
\DoxyCodeLine{04271\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<double>\ DoubleEq(\textcolor{keywordtype}{double}\ rhs)\ \{}
\DoxyCodeLine{04272\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<double>(rhs,\ \textcolor{keyword}{false});}
\DoxyCodeLine{04273\ \}}
\DoxyCodeLine{04274\ }
\DoxyCodeLine{04275\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ double\ argument\ approximately}}
\DoxyCodeLine{04276\ \textcolor{comment}{//\ equal\ to\ rhs,\ including\ NaN\ values\ when\ rhs\ is\ NaN.}}
\DoxyCodeLine{04277\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<double>\ NanSensitiveDoubleEq(\textcolor{keywordtype}{double}\ rhs)\ \{}
\DoxyCodeLine{04278\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<double>(rhs,\ \textcolor{keyword}{true});}
\DoxyCodeLine{04279\ \}}
\DoxyCodeLine{04280\ }
\DoxyCodeLine{04281\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ double\ argument\ approximately\ equal\ to}}
\DoxyCodeLine{04282\ \textcolor{comment}{//\ rhs,\ up\ to\ the\ specified\ max\ absolute\ error\ bound,\ where\ two\ NANs\ are}}
\DoxyCodeLine{04283\ \textcolor{comment}{//\ considered\ unequal.\ \ The\ max\ absolute\ error\ bound\ must\ be\ non-\/negative.}}
\DoxyCodeLine{04284\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<double>\ DoubleNear(}
\DoxyCodeLine{04285\ \ \ \ \ \textcolor{keywordtype}{double}\ rhs,\ \textcolor{keywordtype}{double}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04286\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<double>(rhs,\ \textcolor{keyword}{false},\ max\_abs\_error);}
\DoxyCodeLine{04287\ \}}
\DoxyCodeLine{04288\ }
\DoxyCodeLine{04289\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ double\ argument\ approximately\ equal\ to}}
\DoxyCodeLine{04290\ \textcolor{comment}{//\ rhs,\ up\ to\ the\ specified\ max\ absolute\ error\ bound,\ including\ NaN\ values\ when}}
\DoxyCodeLine{04291\ \textcolor{comment}{//\ rhs\ is\ NaN.\ \ The\ max\ absolute\ error\ bound\ must\ be\ non-\/negative.}}
\DoxyCodeLine{04292\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<double>\ NanSensitiveDoubleNear(}
\DoxyCodeLine{04293\ \ \ \ \ \textcolor{keywordtype}{double}\ rhs,\ \textcolor{keywordtype}{double}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04294\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<double>(rhs,\ \textcolor{keyword}{true},\ max\_abs\_error);}
\DoxyCodeLine{04295\ \}}
\DoxyCodeLine{04296\ }
\DoxyCodeLine{04297\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ float\ argument\ approximately}}
\DoxyCodeLine{04298\ \textcolor{comment}{//\ equal\ to\ rhs,\ where\ two\ NANs\ are\ considered\ unequal.}}
\DoxyCodeLine{04299\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<float>\ FloatEq(\textcolor{keywordtype}{float}\ rhs)\ \{}
\DoxyCodeLine{04300\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<float>(rhs,\ \textcolor{keyword}{false});}
\DoxyCodeLine{04301\ \}}
\DoxyCodeLine{04302\ }
\DoxyCodeLine{04303\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ float\ argument\ approximately}}
\DoxyCodeLine{04304\ \textcolor{comment}{//\ equal\ to\ rhs,\ including\ NaN\ values\ when\ rhs\ is\ NaN.}}
\DoxyCodeLine{04305\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<float>\ NanSensitiveFloatEq(\textcolor{keywordtype}{float}\ rhs)\ \{}
\DoxyCodeLine{04306\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<float>(rhs,\ \textcolor{keyword}{true});}
\DoxyCodeLine{04307\ \}}
\DoxyCodeLine{04308\ }
\DoxyCodeLine{04309\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ float\ argument\ approximately\ equal\ to}}
\DoxyCodeLine{04310\ \textcolor{comment}{//\ rhs,\ up\ to\ the\ specified\ max\ absolute\ error\ bound,\ where\ two\ NANs\ are}}
\DoxyCodeLine{04311\ \textcolor{comment}{//\ considered\ unequal.\ \ The\ max\ absolute\ error\ bound\ must\ be\ non-\/negative.}}
\DoxyCodeLine{04312\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<float>\ FloatNear(}
\DoxyCodeLine{04313\ \ \ \ \ \textcolor{keywordtype}{float}\ rhs,\ \textcolor{keywordtype}{float}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04314\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<float>(rhs,\ \textcolor{keyword}{false},\ max\_abs\_error);}
\DoxyCodeLine{04315\ \}}
\DoxyCodeLine{04316\ }
\DoxyCodeLine{04317\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ float\ argument\ approximately\ equal\ to}}
\DoxyCodeLine{04318\ \textcolor{comment}{//\ rhs,\ up\ to\ the\ specified\ max\ absolute\ error\ bound,\ including\ NaN\ values\ when}}
\DoxyCodeLine{04319\ \textcolor{comment}{//\ rhs\ is\ NaN.\ \ The\ max\ absolute\ error\ bound\ must\ be\ non-\/negative.}}
\DoxyCodeLine{04320\ \textcolor{keyword}{inline}\ internal::FloatingEqMatcher<float>\ NanSensitiveFloatNear(}
\DoxyCodeLine{04321\ \ \ \ \ \textcolor{keywordtype}{float}\ rhs,\ \textcolor{keywordtype}{float}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04322\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEqMatcher<float>(rhs,\ \textcolor{keyword}{true},\ max\_abs\_error);}
\DoxyCodeLine{04323\ \}}
\DoxyCodeLine{04324\ }
\DoxyCodeLine{04325\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ a\ pointer\ (raw\ or\ smart)\ that\ points}}
\DoxyCodeLine{04326\ \textcolor{comment}{//\ to\ a\ value\ that\ matches\ inner\_matcher.}}
\DoxyCodeLine{04327\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04328\ \textcolor{keyword}{inline}\ internal::PointeeMatcher<InnerMatcher>\ Pointee(}
\DoxyCodeLine{04329\ \ \ \ \ \textcolor{keyword}{const}\ InnerMatcher\&\ inner\_matcher)\ \{}
\DoxyCodeLine{04330\ \ \ \textcolor{keywordflow}{return}\ internal::PointeeMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{04331\ \}}
\DoxyCodeLine{04332\ }
\DoxyCodeLine{04333\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{04334\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ a\ pointer\ or\ reference\ that\ matches}}
\DoxyCodeLine{04335\ \textcolor{comment}{//\ inner\_matcher\ when\ dynamic\_cast<To>\ is\ applied.}}
\DoxyCodeLine{04336\ \textcolor{comment}{//\ The\ result\ of\ dynamic\_cast<To>\ is\ forwarded\ to\ the\ inner\ matcher.}}
\DoxyCodeLine{04337\ \textcolor{comment}{//\ If\ To\ is\ a\ pointer\ and\ the\ cast\ fails,\ the\ inner\ matcher\ will\ receive\ NULL.}}
\DoxyCodeLine{04338\ \textcolor{comment}{//\ If\ To\ is\ a\ reference\ and\ the\ cast\ fails,\ this\ matcher\ returns\ false}}
\DoxyCodeLine{04339\ \textcolor{comment}{//\ immediately.}}
\DoxyCodeLine{04340\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ To>}
\DoxyCodeLine{04341\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To>\ >}
\DoxyCodeLine{04342\ WhenDynamicCastTo(\textcolor{keyword}{const}\ Matcher<To>\&\ inner\_matcher)\ \{}
\DoxyCodeLine{04343\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04344\ \ \ \ \ \ \ internal::WhenDynamicCastToMatcher<To>(inner\_matcher));}
\DoxyCodeLine{04345\ \}}
\DoxyCodeLine{04346\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{04347\ }
\DoxyCodeLine{04348\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ an\ object\ whose\ given\ field\ matches}}
\DoxyCodeLine{04349\ \textcolor{comment}{//\ 'matcher'.\ \ For\ example,}}
\DoxyCodeLine{04350\ \textcolor{comment}{//\ \ \ Field(\&Foo::number,\ Ge(5))}}
\DoxyCodeLine{04351\ \textcolor{comment}{//\ matches\ a\ Foo\ object\ x\ if\ and\ only\ if\ x.number\ >=\ 5.}}
\DoxyCodeLine{04352\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ FieldType,\ \textcolor{keyword}{typename}\ FieldMatcher>}
\DoxyCodeLine{04353\ \textcolor{keyword}{inline}\ PolymorphicMatcher<}
\DoxyCodeLine{04354\ \ \ internal::FieldMatcher<Class,\ FieldType>\ >\ Field(}
\DoxyCodeLine{04355\ \ \ \ \ FieldType\ Class::*field,\ const\ FieldMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04356\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04357\ \ \ \ \ \ \ internal::FieldMatcher<Class,\ FieldType>(}
\DoxyCodeLine{04358\ \ \ \ \ \ \ \ \ \ \ field,\ MatcherCast<const\ FieldType\&>(matcher)));}
\DoxyCodeLine{04359\ \ \ \textcolor{comment}{//\ The\ call\ to\ MatcherCast()\ is\ required\ for\ supporting\ inner}}
\DoxyCodeLine{04360\ \ \ \textcolor{comment}{//\ matchers\ of\ compatible\ types.\ \ For\ example,\ it\ allows}}
\DoxyCodeLine{04361\ \ \ \textcolor{comment}{//\ \ \ Field(\&Foo::bar,\ m)}}
\DoxyCodeLine{04362\ \ \ \textcolor{comment}{//\ to\ compile\ where\ bar\ is\ an\ int32\ and\ m\ is\ a\ matcher\ for\ int64.}}
\DoxyCodeLine{04363\ \}}
\DoxyCodeLine{04364\ }
\DoxyCodeLine{04365\ \textcolor{comment}{//\ Same\ as\ Field()\ but\ also\ takes\ the\ name\ of\ the\ field\ to\ provide\ better\ error}}
\DoxyCodeLine{04366\ \textcolor{comment}{//\ messages.}}
\DoxyCodeLine{04367\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ FieldType,\ \textcolor{keyword}{typename}\ FieldMatcher>}
\DoxyCodeLine{04368\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::FieldMatcher<Class,\ FieldType>\ >\ Field(}
\DoxyCodeLine{04369\ \ \ \ \ \textcolor{keyword}{const}\ std::string\&\ field\_name,\ FieldType\ Class::*field,}
\DoxyCodeLine{04370\ \ \ \ \ const\ FieldMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04371\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::FieldMatcher<Class,\ FieldType>(}
\DoxyCodeLine{04372\ \ \ \ \ \ \ field\_name,\ field,\ MatcherCast<const\ FieldType\&>(matcher)));}
\DoxyCodeLine{04373\ \}}
\DoxyCodeLine{04374\ }
\DoxyCodeLine{04375\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ an\ object\ whose\ given\ property}}
\DoxyCodeLine{04376\ \textcolor{comment}{//\ matches\ 'matcher'.\ \ For\ example,}}
\DoxyCodeLine{04377\ \textcolor{comment}{//\ \ \ Property(\&Foo::str,\ StartsWith("{}hi"{}))}}
\DoxyCodeLine{04378\ \textcolor{comment}{//\ matches\ a\ Foo\ object\ x\ if\ and\ only\ if\ x.str()\ starts\ with\ "{}hi"{}.}}
\DoxyCodeLine{04379\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ PropertyMatcher>}
\DoxyCodeLine{04380\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{04381\ \ \ \ \ Class,\ PropertyType,\ PropertyType\ (Class::*)()\ const>\ >}
\DoxyCodeLine{04382\ Property(PropertyType\ (Class::*property)()\ const,}
\DoxyCodeLine{04383\ \ \ \ \ \ \ \ \ \ const\ PropertyMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04384\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04385\ \ \ \ \ \ \ internal::PropertyMatcher<Class,\ PropertyType,}
\DoxyCodeLine{04386\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*)()\ const>(}
\DoxyCodeLine{04387\ \ \ \ \ \ \ \ \ \ \ property,\ MatcherCast<const\ PropertyType\&>(matcher)));}
\DoxyCodeLine{04388\ \ \ \textcolor{comment}{//\ The\ call\ to\ MatcherCast()\ is\ required\ for\ supporting\ inner}}
\DoxyCodeLine{04389\ \ \ \textcolor{comment}{//\ matchers\ of\ compatible\ types.\ \ For\ example,\ it\ allows}}
\DoxyCodeLine{04390\ \ \ \textcolor{comment}{//\ \ \ Property(\&Foo::bar,\ m)}}
\DoxyCodeLine{04391\ \ \ \textcolor{comment}{//\ to\ compile\ where\ bar()\ returns\ an\ int32\ and\ m\ is\ a\ matcher\ for\ int64.}}
\DoxyCodeLine{04392\ \}}
\DoxyCodeLine{04393\ }
\DoxyCodeLine{04394\ \textcolor{comment}{//\ Same\ as\ Property()\ above,\ but\ also\ takes\ the\ name\ of\ the\ property\ to\ provide}}
\DoxyCodeLine{04395\ \textcolor{comment}{//\ better\ error\ messages.}}
\DoxyCodeLine{04396\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ PropertyMatcher>}
\DoxyCodeLine{04397\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{04398\ \ \ \ \ Class,\ PropertyType,\ PropertyType\ (Class::*)()\ const>\ >}
\DoxyCodeLine{04399\ Property(const\ std::string\&\ property\_name,}
\DoxyCodeLine{04400\ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*property)()\ const,}
\DoxyCodeLine{04401\ \ \ \ \ \ \ \ \ \ const\ PropertyMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04402\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04403\ \ \ \ \ \ \ internal::PropertyMatcher<Class,\ PropertyType,}
\DoxyCodeLine{04404\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*)()\ const>(}
\DoxyCodeLine{04405\ \ \ \ \ \ \ \ \ \ \ property\_name,\ property,\ MatcherCast<const\ PropertyType\&>(matcher)));}
\DoxyCodeLine{04406\ \}}
\DoxyCodeLine{04407\ }
\DoxyCodeLine{04408\ \textcolor{comment}{//\ The\ same\ as\ above\ but\ for\ reference-\/qualified\ member\ functions.}}
\DoxyCodeLine{04409\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ PropertyMatcher>}
\DoxyCodeLine{04410\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{04411\ \ \ \ \ Class,\ PropertyType,\ PropertyType\ (Class::*)()\ const\ \&>\ >}
\DoxyCodeLine{04412\ Property(PropertyType\ (Class::*property)()\ const\ \&,}
\DoxyCodeLine{04413\ \ \ \ \ \ \ \ \ \ const\ PropertyMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04414\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04415\ \ \ \ \ \ \ internal::PropertyMatcher<Class,\ PropertyType,}
\DoxyCodeLine{04416\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*)()\ const\&>(}
\DoxyCodeLine{04417\ \ \ \ \ \ \ \ \ \ \ property,\ MatcherCast<const\ PropertyType\&>(matcher)));}
\DoxyCodeLine{04418\ \}}
\DoxyCodeLine{04419\ }
\DoxyCodeLine{04420\ \textcolor{comment}{//\ Three-\/argument\ form\ for\ reference-\/qualified\ member\ functions.}}
\DoxyCodeLine{04421\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Class,\ \textcolor{keyword}{typename}\ PropertyType,\ \textcolor{keyword}{typename}\ PropertyMatcher>}
\DoxyCodeLine{04422\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::PropertyMatcher<}
\DoxyCodeLine{04423\ \ \ \ \ Class,\ PropertyType,\ PropertyType\ (Class::*)()\ const\ \&>\ >}
\DoxyCodeLine{04424\ Property(const\ std::string\&\ property\_name,}
\DoxyCodeLine{04425\ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*property)()\ const\ \&,}
\DoxyCodeLine{04426\ \ \ \ \ \ \ \ \ \ const\ PropertyMatcher\&\ matcher)\ \{}
\DoxyCodeLine{04427\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04428\ \ \ \ \ \ \ internal::PropertyMatcher<Class,\ PropertyType,}
\DoxyCodeLine{04429\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PropertyType\ (Class::*)()\ const\&>(}
\DoxyCodeLine{04430\ \ \ \ \ \ \ \ \ \ \ property\_name,\ property,\ MatcherCast<const\ PropertyType\&>(matcher)));}
\DoxyCodeLine{04431\ \}}
\DoxyCodeLine{04432\ }
\DoxyCodeLine{04433\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ an\ object\ if\ and\ only\ if\ the\ result\ of}}
\DoxyCodeLine{04434\ \textcolor{comment}{//\ applying\ a\ callable\ to\ x\ matches\ 'matcher'.\ For\ example,}}
\DoxyCodeLine{04435\ \textcolor{comment}{//\ \ \ ResultOf(f,\ StartsWith("{}hi"{}))}}
\DoxyCodeLine{04436\ \textcolor{comment}{//\ matches\ a\ Foo\ object\ x\ if\ and\ only\ if\ f(x)\ starts\ with\ "{}hi"{}.}}
\DoxyCodeLine{04437\ \textcolor{comment}{//\ \`{}callable`\ parameter\ can\ be\ a\ function,\ function\ pointer,\ or\ a\ functor.\ It\ is}}
\DoxyCodeLine{04438\ \textcolor{comment}{//\ required\ to\ keep\ no\ state\ affecting\ the\ results\ of\ the\ calls\ on\ it\ and\ make}}
\DoxyCodeLine{04439\ \textcolor{comment}{//\ no\ assumptions\ about\ how\ many\ calls\ will\ be\ made.\ Any\ state\ it\ keeps\ must\ be}}
\DoxyCodeLine{04440\ \textcolor{comment}{//\ protected\ from\ the\ concurrent\ access.}}
\DoxyCodeLine{04441\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Callable,\ \textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04442\ internal::ResultOfMatcher<Callable,\ InnerMatcher>\ ResultOf(}
\DoxyCodeLine{04443\ \ \ \ \ Callable\ callable,\ InnerMatcher\ matcher)\ \{}
\DoxyCodeLine{04444\ \ \ \textcolor{keywordflow}{return}\ internal::ResultOfMatcher<Callable,\ InnerMatcher>(}
\DoxyCodeLine{04445\ \ \ \ \ \ \ std::move(callable),\ std::move(matcher));}
\DoxyCodeLine{04446\ \}}
\DoxyCodeLine{04447\ }
\DoxyCodeLine{04448\ \textcolor{comment}{//\ String\ matchers.}}
\DoxyCodeLine{04449\ }
\DoxyCodeLine{04450\ \textcolor{comment}{//\ Matches\ a\ string\ equal\ to\ str.}}
\DoxyCodeLine{04451\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04452\ PolymorphicMatcher<internal::StrEqualityMatcher<std::string>\ >\ StrEq(}
\DoxyCodeLine{04453\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ str)\ \{}
\DoxyCodeLine{04454\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04455\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::string>(std::string(str),\ \textcolor{keyword}{true},\ \textcolor{keyword}{true}));}
\DoxyCodeLine{04456\ \}}
\DoxyCodeLine{04457\ }
\DoxyCodeLine{04458\ \textcolor{comment}{//\ Matches\ a\ string\ not\ equal\ to\ str.}}
\DoxyCodeLine{04459\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04460\ PolymorphicMatcher<internal::StrEqualityMatcher<std::string>\ >\ StrNe(}
\DoxyCodeLine{04461\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ str)\ \{}
\DoxyCodeLine{04462\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04463\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::string>(std::string(str),\ \textcolor{keyword}{false},\ \textcolor{keyword}{true}));}
\DoxyCodeLine{04464\ \}}
\DoxyCodeLine{04465\ }
\DoxyCodeLine{04466\ \textcolor{comment}{//\ Matches\ a\ string\ equal\ to\ str,\ ignoring\ case.}}
\DoxyCodeLine{04467\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04468\ PolymorphicMatcher<internal::StrEqualityMatcher<std::string>\ >\ StrCaseEq(}
\DoxyCodeLine{04469\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ str)\ \{}
\DoxyCodeLine{04470\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04471\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::string>(std::string(str),\ \textcolor{keyword}{true},\ \textcolor{keyword}{false}));}
\DoxyCodeLine{04472\ \}}
\DoxyCodeLine{04473\ }
\DoxyCodeLine{04474\ \textcolor{comment}{//\ Matches\ a\ string\ not\ equal\ to\ str,\ ignoring\ case.}}
\DoxyCodeLine{04475\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04476\ PolymorphicMatcher<internal::StrEqualityMatcher<std::string>\ >\ StrCaseNe(}
\DoxyCodeLine{04477\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ str)\ \{}
\DoxyCodeLine{04478\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::StrEqualityMatcher<std::string>(}
\DoxyCodeLine{04479\ \ \ \ \ \ \ std::string(str),\ \textcolor{keyword}{false},\ \textcolor{keyword}{false}));}
\DoxyCodeLine{04480\ \}}
\DoxyCodeLine{04481\ }
\DoxyCodeLine{04482\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ string,\ std::string,\ or\ C\ string}}
\DoxyCodeLine{04483\ \textcolor{comment}{//\ that\ contains\ the\ given\ substring.}}
\DoxyCodeLine{04484\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04485\ PolymorphicMatcher<internal::HasSubstrMatcher<std::string>\ >\ HasSubstr(}
\DoxyCodeLine{04486\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ substring)\ \{}
\DoxyCodeLine{04487\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04488\ \ \ \ \ \ \ internal::HasSubstrMatcher<std::string>(std::string(substring)));}
\DoxyCodeLine{04489\ \}}
\DoxyCodeLine{04490\ }
\DoxyCodeLine{04491\ \textcolor{comment}{//\ Matches\ a\ string\ that\ starts\ with\ 'prefix'\ (case-\/sensitive).}}
\DoxyCodeLine{04492\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04493\ PolymorphicMatcher<internal::StartsWithMatcher<std::string>\ >\ StartsWith(}
\DoxyCodeLine{04494\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ prefix)\ \{}
\DoxyCodeLine{04495\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04496\ \ \ \ \ \ \ internal::StartsWithMatcher<std::string>(std::string(prefix)));}
\DoxyCodeLine{04497\ \}}
\DoxyCodeLine{04498\ }
\DoxyCodeLine{04499\ \textcolor{comment}{//\ Matches\ a\ string\ that\ ends\ with\ 'suffix'\ (case-\/sensitive).}}
\DoxyCodeLine{04500\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{04501\ PolymorphicMatcher<internal::EndsWithMatcher<std::string>\ >\ EndsWith(}
\DoxyCodeLine{04502\ \ \ \ \ \textcolor{keyword}{const}\ internal::StringLike<T>\&\ suffix)\ \{}
\DoxyCodeLine{04503\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04504\ \ \ \ \ \ \ internal::EndsWithMatcher<std::string>(std::string(suffix)));}
\DoxyCodeLine{04505\ \}}
\DoxyCodeLine{04506\ }
\DoxyCodeLine{04507\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{04508\ \textcolor{comment}{//\ Wide\ string\ matchers.}}
\DoxyCodeLine{04509\ }
\DoxyCodeLine{04510\ \textcolor{comment}{//\ Matches\ a\ string\ equal\ to\ str.}}
\DoxyCodeLine{04511\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>\ >\ StrEq(}
\DoxyCodeLine{04512\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ str)\ \{}
\DoxyCodeLine{04513\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04514\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::wstring>(str,\ \textcolor{keyword}{true},\ \textcolor{keyword}{true}));}
\DoxyCodeLine{04515\ \}}
\DoxyCodeLine{04516\ }
\DoxyCodeLine{04517\ \textcolor{comment}{//\ Matches\ a\ string\ not\ equal\ to\ str.}}
\DoxyCodeLine{04518\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>\ >\ StrNe(}
\DoxyCodeLine{04519\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ str)\ \{}
\DoxyCodeLine{04520\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04521\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::wstring>(str,\ \textcolor{keyword}{false},\ \textcolor{keyword}{true}));}
\DoxyCodeLine{04522\ \}}
\DoxyCodeLine{04523\ }
\DoxyCodeLine{04524\ \textcolor{comment}{//\ Matches\ a\ string\ equal\ to\ str,\ ignoring\ case.}}
\DoxyCodeLine{04525\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>\ >}
\DoxyCodeLine{04526\ StrCaseEq(\textcolor{keyword}{const}\ std::wstring\&\ str)\ \{}
\DoxyCodeLine{04527\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04528\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::wstring>(str,\ \textcolor{keyword}{true},\ \textcolor{keyword}{false}));}
\DoxyCodeLine{04529\ \}}
\DoxyCodeLine{04530\ }
\DoxyCodeLine{04531\ \textcolor{comment}{//\ Matches\ a\ string\ not\ equal\ to\ str,\ ignoring\ case.}}
\DoxyCodeLine{04532\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StrEqualityMatcher<std::wstring>\ >}
\DoxyCodeLine{04533\ StrCaseNe(\textcolor{keyword}{const}\ std::wstring\&\ str)\ \{}
\DoxyCodeLine{04534\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04535\ \ \ \ \ \ \ internal::StrEqualityMatcher<std::wstring>(str,\ \textcolor{keyword}{false},\ \textcolor{keyword}{false}));}
\DoxyCodeLine{04536\ \}}
\DoxyCodeLine{04537\ }
\DoxyCodeLine{04538\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ ::wstring,\ std::wstring,\ or\ C\ wide\ string}}
\DoxyCodeLine{04539\ \textcolor{comment}{//\ that\ contains\ the\ given\ substring.}}
\DoxyCodeLine{04540\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::HasSubstrMatcher<std::wstring>\ >\ HasSubstr(}
\DoxyCodeLine{04541\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ substring)\ \{}
\DoxyCodeLine{04542\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04543\ \ \ \ \ \ \ internal::HasSubstrMatcher<std::wstring>(substring));}
\DoxyCodeLine{04544\ \}}
\DoxyCodeLine{04545\ }
\DoxyCodeLine{04546\ \textcolor{comment}{//\ Matches\ a\ string\ that\ starts\ with\ 'prefix'\ (case-\/sensitive).}}
\DoxyCodeLine{04547\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::StartsWithMatcher<std::wstring>\ >}
\DoxyCodeLine{04548\ StartsWith(\textcolor{keyword}{const}\ std::wstring\&\ prefix)\ \{}
\DoxyCodeLine{04549\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04550\ \ \ \ \ \ \ internal::StartsWithMatcher<std::wstring>(prefix));}
\DoxyCodeLine{04551\ \}}
\DoxyCodeLine{04552\ }
\DoxyCodeLine{04553\ \textcolor{comment}{//\ Matches\ a\ string\ that\ ends\ with\ 'suffix'\ (case-\/sensitive).}}
\DoxyCodeLine{04554\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::EndsWithMatcher<std::wstring>\ >\ EndsWith(}
\DoxyCodeLine{04555\ \ \ \ \ \textcolor{keyword}{const}\ std::wstring\&\ suffix)\ \{}
\DoxyCodeLine{04556\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{04557\ \ \ \ \ \ \ internal::EndsWithMatcher<std::wstring>(suffix));}
\DoxyCodeLine{04558\ \}}
\DoxyCodeLine{04559\ }
\DoxyCodeLine{04560\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{04561\ }
\DoxyCodeLine{04562\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04563\ \textcolor{comment}{//\ first\ field\ ==\ the\ second\ field.}}
\DoxyCodeLine{04564\ \textcolor{keyword}{inline}\ internal::Eq2Matcher\ Eq()\ \{\ \textcolor{keywordflow}{return}\ internal::Eq2Matcher();\ \}}
\DoxyCodeLine{04565\ }
\DoxyCodeLine{04566\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04567\ \textcolor{comment}{//\ first\ field\ >=\ the\ second\ field.}}
\DoxyCodeLine{04568\ \textcolor{keyword}{inline}\ internal::Ge2Matcher\ Ge()\ \{\ \textcolor{keywordflow}{return}\ internal::Ge2Matcher();\ \}}
\DoxyCodeLine{04569\ }
\DoxyCodeLine{04570\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04571\ \textcolor{comment}{//\ first\ field\ >\ the\ second\ field.}}
\DoxyCodeLine{04572\ \textcolor{keyword}{inline}\ internal::Gt2Matcher\ Gt()\ \{\ \textcolor{keywordflow}{return}\ internal::Gt2Matcher();\ \}}
\DoxyCodeLine{04573\ }
\DoxyCodeLine{04574\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04575\ \textcolor{comment}{//\ first\ field\ <=\ the\ second\ field.}}
\DoxyCodeLine{04576\ \textcolor{keyword}{inline}\ internal::Le2Matcher\ Le()\ \{\ \textcolor{keywordflow}{return}\ internal::Le2Matcher();\ \}}
\DoxyCodeLine{04577\ }
\DoxyCodeLine{04578\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04579\ \textcolor{comment}{//\ first\ field\ <\ the\ second\ field.}}
\DoxyCodeLine{04580\ \textcolor{keyword}{inline}\ internal::Lt2Matcher\ Lt()\ \{\ \textcolor{keywordflow}{return}\ internal::Lt2Matcher();\ \}}
\DoxyCodeLine{04581\ }
\DoxyCodeLine{04582\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where\ the}}
\DoxyCodeLine{04583\ \textcolor{comment}{//\ first\ field\ !=\ the\ second\ field.}}
\DoxyCodeLine{04584\ \textcolor{keyword}{inline}\ internal::Ne2Matcher\ Ne()\ \{\ \textcolor{keywordflow}{return}\ internal::Ne2Matcher();\ \}}
\DoxyCodeLine{04585\ }
\DoxyCodeLine{04586\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04587\ \textcolor{comment}{//\ FloatEq(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{04588\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<float>\ FloatEq()\ \{}
\DoxyCodeLine{04589\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<float>();}
\DoxyCodeLine{04590\ \}}
\DoxyCodeLine{04591\ }
\DoxyCodeLine{04592\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04593\ \textcolor{comment}{//\ DoubleEq(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{04594\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<double>\ DoubleEq()\ \{}
\DoxyCodeLine{04595\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<double>();}
\DoxyCodeLine{04596\ \}}
\DoxyCodeLine{04597\ }
\DoxyCodeLine{04598\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04599\ \textcolor{comment}{//\ FloatEq(first\ field)\ matches\ the\ second\ field\ with\ NaN\ equality.}}
\DoxyCodeLine{04600\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<float>\ NanSensitiveFloatEq()\ \{}
\DoxyCodeLine{04601\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<float>(\textcolor{keyword}{true});}
\DoxyCodeLine{04602\ \}}
\DoxyCodeLine{04603\ }
\DoxyCodeLine{04604\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04605\ \textcolor{comment}{//\ DoubleEq(first\ field)\ matches\ the\ second\ field\ with\ NaN\ equality.}}
\DoxyCodeLine{04606\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<double>\ NanSensitiveDoubleEq()\ \{}
\DoxyCodeLine{04607\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<double>(\textcolor{keyword}{true});}
\DoxyCodeLine{04608\ \}}
\DoxyCodeLine{04609\ }
\DoxyCodeLine{04610\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04611\ \textcolor{comment}{//\ FloatNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field.}}
\DoxyCodeLine{04612\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<float>\ FloatNear(\textcolor{keywordtype}{float}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04613\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<float>(max\_abs\_error);}
\DoxyCodeLine{04614\ \}}
\DoxyCodeLine{04615\ }
\DoxyCodeLine{04616\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04617\ \textcolor{comment}{//\ DoubleNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field.}}
\DoxyCodeLine{04618\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<double>\ DoubleNear(\textcolor{keywordtype}{double}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04619\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<double>(max\_abs\_error);}
\DoxyCodeLine{04620\ \}}
\DoxyCodeLine{04621\ }
\DoxyCodeLine{04622\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04623\ \textcolor{comment}{//\ FloatNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field\ with\ NaN}}
\DoxyCodeLine{04624\ \textcolor{comment}{//\ equality.}}
\DoxyCodeLine{04625\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<float>\ NanSensitiveFloatNear(}
\DoxyCodeLine{04626\ \ \ \ \ \textcolor{keywordtype}{float}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04627\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<float>(max\_abs\_error,\ \textcolor{keyword}{true});}
\DoxyCodeLine{04628\ \}}
\DoxyCodeLine{04629\ }
\DoxyCodeLine{04630\ \textcolor{comment}{//\ Creates\ a\ polymorphic\ matcher\ that\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{04631\ \textcolor{comment}{//\ DoubleNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field\ with\ NaN}}
\DoxyCodeLine{04632\ \textcolor{comment}{//\ equality.}}
\DoxyCodeLine{04633\ \textcolor{keyword}{inline}\ internal::FloatingEq2Matcher<double>\ NanSensitiveDoubleNear(}
\DoxyCodeLine{04634\ \ \ \ \ \textcolor{keywordtype}{double}\ max\_abs\_error)\ \{}
\DoxyCodeLine{04635\ \ \ \textcolor{keywordflow}{return}\ internal::FloatingEq2Matcher<double>(max\_abs\_error,\ \textcolor{keyword}{true});}
\DoxyCodeLine{04636\ \}}
\DoxyCodeLine{04637\ }
\DoxyCodeLine{04638\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ any\ value\ of\ type\ T\ that\ m\ doesn't}}
\DoxyCodeLine{04639\ \textcolor{comment}{//\ match.}}
\DoxyCodeLine{04640\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{04641\ \textcolor{keyword}{inline}\ internal::NotMatcher<InnerMatcher>\ Not(InnerMatcher\ m)\ \{}
\DoxyCodeLine{04642\ \ \ \textcolor{keywordflow}{return}\ internal::NotMatcher<InnerMatcher>(m);}
\DoxyCodeLine{04643\ \}}
\DoxyCodeLine{04644\ }
\DoxyCodeLine{04645\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ anything\ that\ satisfies\ the\ given}}
\DoxyCodeLine{04646\ \textcolor{comment}{//\ predicate.\ \ The\ predicate\ can\ be\ any\ unary\ function\ or\ functor}}
\DoxyCodeLine{04647\ \textcolor{comment}{//\ whose\ return\ type\ can\ be\ implicitly\ converted\ to\ bool.}}
\DoxyCodeLine{04648\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Predicate>}
\DoxyCodeLine{04649\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::TrulyMatcher<Predicate>\ >}
\DoxyCodeLine{04650\ Truly(Predicate\ pred)\ \{}
\DoxyCodeLine{04651\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));}
\DoxyCodeLine{04652\ \}}
\DoxyCodeLine{04653\ }
\DoxyCodeLine{04654\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ container\ size.\ The\ container\ must}}
\DoxyCodeLine{04655\ \textcolor{comment}{//\ support\ both\ size()\ and\ size\_type\ which\ all\ STL-\/like\ containers\ provide.}}
\DoxyCodeLine{04656\ \textcolor{comment}{//\ Note\ that\ the\ parameter\ 'size'\ can\ be\ a\ value\ of\ type\ size\_type\ as\ well\ as}}
\DoxyCodeLine{04657\ \textcolor{comment}{//\ matcher.\ For\ instance:}}
\DoxyCodeLine{04658\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(container,\ SizeIs(2));\ \ \ \ \ //\ Checks\ container\ has\ 2\ elements.}}
\DoxyCodeLine{04659\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(container,\ SizeIs(Le(2));\ \ //\ Checks\ container\ has\ at\ most\ 2.}}
\DoxyCodeLine{04660\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ SizeMatcher>}
\DoxyCodeLine{04661\ \textcolor{keyword}{inline}\ internal::SizeIsMatcher<SizeMatcher>}
\DoxyCodeLine{04662\ SizeIs(\textcolor{keyword}{const}\ SizeMatcher\&\ size\_matcher)\ \{}
\DoxyCodeLine{04663\ \ \ \textcolor{keywordflow}{return}\ internal::SizeIsMatcher<SizeMatcher>(size\_matcher);}
\DoxyCodeLine{04664\ \}}
\DoxyCodeLine{04665\ }
\DoxyCodeLine{04666\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ distance\ between\ the\ container's\ begin()}}
\DoxyCodeLine{04667\ \textcolor{comment}{//\ iterator\ and\ its\ end()\ iterator,\ i.e.\ the\ size\ of\ the\ container.\ This\ matcher}}
\DoxyCodeLine{04668\ \textcolor{comment}{//\ can\ be\ used\ instead\ of\ SizeIs\ with\ containers\ such\ as\ std::forward\_list\ which}}
\DoxyCodeLine{04669\ \textcolor{comment}{//\ do\ not\ implement\ size().\ The\ container\ must\ provide\ const\_iterator\ (with}}
\DoxyCodeLine{04670\ \textcolor{comment}{//\ valid\ iterator\_traits),\ begin()\ and\ end().}}
\DoxyCodeLine{04671\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ DistanceMatcher>}
\DoxyCodeLine{04672\ \textcolor{keyword}{inline}\ internal::BeginEndDistanceIsMatcher<DistanceMatcher>}
\DoxyCodeLine{04673\ BeginEndDistanceIs(\textcolor{keyword}{const}\ DistanceMatcher\&\ distance\_matcher)\ \{}
\DoxyCodeLine{04674\ \ \ \textcolor{keywordflow}{return}\ internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance\_matcher);}
\DoxyCodeLine{04675\ \}}
\DoxyCodeLine{04676\ }
\DoxyCodeLine{04677\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ an\ equal\ container.}}
\DoxyCodeLine{04678\ \textcolor{comment}{//\ This\ matcher\ behaves\ like\ Eq(),\ but\ in\ the\ event\ of\ mismatch\ lists\ the}}
\DoxyCodeLine{04679\ \textcolor{comment}{//\ values\ that\ are\ included\ in\ one\ container\ but\ not\ the\ other.\ (Duplicate}}
\DoxyCodeLine{04680\ \textcolor{comment}{//\ values\ and\ order\ differences\ are\ not\ explained.)}}
\DoxyCodeLine{04681\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04682\ \textcolor{keyword}{inline}\ PolymorphicMatcher<internal::ContainerEqMatcher<}
\DoxyCodeLine{04683\ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_const<Container>::type>>}
\DoxyCodeLine{04684\ ContainerEq(\textcolor{keyword}{const}\ Container\&\ rhs)\ \{}
\DoxyCodeLine{04685\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::ContainerEqMatcher<Container>(rhs));}
\DoxyCodeLine{04686\ \}}
\DoxyCodeLine{04687\ }
\DoxyCodeLine{04688\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ a\ container\ that,\ when\ sorted\ using}}
\DoxyCodeLine{04689\ \textcolor{comment}{//\ the\ given\ comparator,\ matches\ container\_matcher.}}
\DoxyCodeLine{04690\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Comparator,\ \textcolor{keyword}{typename}\ ContainerMatcher>}
\DoxyCodeLine{04691\ \textcolor{keyword}{inline}\ internal::WhenSortedByMatcher<Comparator,\ ContainerMatcher>}
\DoxyCodeLine{04692\ WhenSortedBy(\textcolor{keyword}{const}\ Comparator\&\ comparator,}
\DoxyCodeLine{04693\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ ContainerMatcher\&\ container\_matcher)\ \{}
\DoxyCodeLine{04694\ \ \ \textcolor{keywordflow}{return}\ internal::WhenSortedByMatcher<Comparator,\ ContainerMatcher>(}
\DoxyCodeLine{04695\ \ \ \ \ \ \ comparator,\ container\_matcher);}
\DoxyCodeLine{04696\ \}}
\DoxyCodeLine{04697\ }
\DoxyCodeLine{04698\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ a\ container\ that,\ when\ sorted\ using}}
\DoxyCodeLine{04699\ \textcolor{comment}{//\ the\ <\ operator,\ matches\ container\_matcher.}}
\DoxyCodeLine{04700\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ContainerMatcher>}
\DoxyCodeLine{04701\ \textcolor{keyword}{inline}\ internal::WhenSortedByMatcher<internal::LessComparator,\ ContainerMatcher>}
\DoxyCodeLine{04702\ WhenSorted(\textcolor{keyword}{const}\ ContainerMatcher\&\ container\_matcher)\ \{}
\DoxyCodeLine{04703\ \ \ \textcolor{keywordflow}{return}}
\DoxyCodeLine{04704\ \ \ \ \ \ \ internal::WhenSortedByMatcher<internal::LessComparator,\ ContainerMatcher>(}
\DoxyCodeLine{04705\ \ \ \ \ \ \ \ \ \ \ internal::LessComparator(),\ container\_matcher);}
\DoxyCodeLine{04706\ \}}
\DoxyCodeLine{04707\ }
\DoxyCodeLine{04708\ \textcolor{comment}{//\ Matches\ an\ STL-\/style\ container\ or\ a\ native\ array\ that\ contains\ the}}
\DoxyCodeLine{04709\ \textcolor{comment}{//\ same\ number\ of\ elements\ as\ in\ rhs,\ where\ its\ i-\/th\ element\ and\ rhs's}}
\DoxyCodeLine{04710\ \textcolor{comment}{//\ i-\/th\ element\ (as\ a\ pair)\ satisfy\ the\ given\ pair\ matcher,\ for\ all\ i.}}
\DoxyCodeLine{04711\ \textcolor{comment}{//\ TupleMatcher\ must\ be\ able\ to\ be\ safely\ cast\ to\ Matcher<std::tuple<const}}
\DoxyCodeLine{04712\ \textcolor{comment}{//\ T1\&,\ const\ T2\&>\ >,\ where\ T1\ and\ T2\ are\ the\ types\ of\ elements\ in\ the}}
\DoxyCodeLine{04713\ \textcolor{comment}{//\ LHS\ container\ and\ the\ RHS\ container\ respectively.}}
\DoxyCodeLine{04714\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ TupleMatcher,\ \textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04715\ \textcolor{keyword}{inline}\ internal::PointwiseMatcher<TupleMatcher,}
\DoxyCodeLine{04716\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_const<Container>::type>}
\DoxyCodeLine{04717\ Pointwise(\textcolor{keyword}{const}\ TupleMatcher\&\ tuple\_matcher,\ \textcolor{keyword}{const}\ Container\&\ rhs)\ \{}
\DoxyCodeLine{04718\ \ \ \textcolor{keywordflow}{return}\ internal::PointwiseMatcher<TupleMatcher,\ Container>(tuple\_matcher,}
\DoxyCodeLine{04719\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ rhs);}
\DoxyCodeLine{04720\ \}}
\DoxyCodeLine{04721\ }
\DoxyCodeLine{04722\ }
\DoxyCodeLine{04723\ \textcolor{comment}{//\ Supports\ the\ Pointwise(m,\ \{a,\ b,\ c\})\ syntax.}}
\DoxyCodeLine{04724\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ TupleMatcher,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04725\ \textcolor{keyword}{inline}\ internal::PointwiseMatcher<TupleMatcher,\ std::vector<T>\ >\ Pointwise(}
\DoxyCodeLine{04726\ \ \ \ \ \textcolor{keyword}{const}\ TupleMatcher\&\ tuple\_matcher,\ std::initializer\_list<T>\ rhs)\ \{}
\DoxyCodeLine{04727\ \ \ \textcolor{keywordflow}{return}\ Pointwise(tuple\_matcher,\ std::vector<T>(rhs));}
\DoxyCodeLine{04728\ \}}
\DoxyCodeLine{04729\ }
\DoxyCodeLine{04730\ }
\DoxyCodeLine{04731\ \textcolor{comment}{//\ UnorderedPointwise(pair\_matcher,\ rhs)\ matches\ an\ STL-\/style}}
\DoxyCodeLine{04732\ \textcolor{comment}{//\ container\ or\ a\ native\ array\ that\ contains\ the\ same\ number\ of}}
\DoxyCodeLine{04733\ \textcolor{comment}{//\ elements\ as\ in\ rhs,\ where\ in\ some\ permutation\ of\ the\ container,\ its}}
\DoxyCodeLine{04734\ \textcolor{comment}{//\ i-\/th\ element\ and\ rhs's\ i-\/th\ element\ (as\ a\ pair)\ satisfy\ the\ given}}
\DoxyCodeLine{04735\ \textcolor{comment}{//\ pair\ matcher,\ for\ all\ i.\ \ Tuple2Matcher\ must\ be\ able\ to\ be\ safely}}
\DoxyCodeLine{04736\ \textcolor{comment}{//\ cast\ to\ Matcher<std::tuple<const\ T1\&,\ const\ T2\&>\ >,\ where\ T1\ and\ T2\ are}}
\DoxyCodeLine{04737\ \textcolor{comment}{//\ the\ types\ of\ elements\ in\ the\ LHS\ container\ and\ the\ RHS\ container}}
\DoxyCodeLine{04738\ \textcolor{comment}{//\ respectively.}}
\DoxyCodeLine{04739\ \textcolor{comment}{//}}
\DoxyCodeLine{04740\ \textcolor{comment}{//\ This\ is\ like\ Pointwise(pair\_matcher,\ rhs),\ except\ that\ the\ element}}
\DoxyCodeLine{04741\ \textcolor{comment}{//\ order\ doesn't\ matter.}}
\DoxyCodeLine{04742\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple2Matcher,\ \textcolor{keyword}{typename}\ RhsContainer>}
\DoxyCodeLine{04743\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04744\ \ \ \ \ \textcolor{keyword}{typename}\ internal::BoundSecondMatcher<}
\DoxyCodeLine{04745\ \ \ \ \ \ \ \ \ Tuple2Matcher,}
\DoxyCodeLine{04746\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ internal::StlContainerView<}
\DoxyCodeLine{04747\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_const<RhsContainer>::type>::type::value\_type>>}
\DoxyCodeLine{04748\ UnorderedPointwise(\textcolor{keyword}{const}\ Tuple2Matcher\&\ tuple2\_matcher,}
\DoxyCodeLine{04749\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ RhsContainer\&\ rhs\_container)\ \{}
\DoxyCodeLine{04750\ \ \ \textcolor{comment}{//\ RhsView\ allows\ the\ same\ code\ to\ handle\ RhsContainer\ being\ a}}
\DoxyCodeLine{04751\ \ \ \textcolor{comment}{//\ STL-\/style\ container\ and\ it\ being\ a\ native\ C-\/style\ array.}}
\DoxyCodeLine{04752\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ internal::StlContainerView<RhsContainer>\ RhsView;}
\DoxyCodeLine{04753\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RhsView::type\ RhsStlContainer;}
\DoxyCodeLine{04754\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ RhsStlContainer::value\_type\ Second;}
\DoxyCodeLine{04755\ \ \ \textcolor{keyword}{const}\ RhsStlContainer\&\ rhs\_stl\_container\ =}
\DoxyCodeLine{04756\ \ \ \ \ \ \ RhsView::ConstReference(rhs\_container);}
\DoxyCodeLine{04757\ }
\DoxyCodeLine{04758\ \ \ \textcolor{comment}{//\ Create\ a\ matcher\ for\ each\ element\ in\ rhs\_container.}}
\DoxyCodeLine{04759\ \ \ ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher,\ Second>\ >\ matchers;}
\DoxyCodeLine{04760\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ rhs\_stl\_container.begin();}
\DoxyCodeLine{04761\ \ \ \ \ \ \ \ it\ !=\ rhs\_stl\_container.end();\ ++it)\ \{}
\DoxyCodeLine{04762\ \ \ \ \ matchers.push\_back(}
\DoxyCodeLine{04763\ \ \ \ \ \ \ \ \ internal::MatcherBindSecond(tuple2\_matcher,\ *it));}
\DoxyCodeLine{04764\ \ \ \}}
\DoxyCodeLine{04765\ }
\DoxyCodeLine{04766\ \ \ \textcolor{comment}{//\ Delegate\ the\ work\ to\ UnorderedElementsAreArray().}}
\DoxyCodeLine{04767\ \ \ \textcolor{keywordflow}{return}\ UnorderedElementsAreArray(matchers);}
\DoxyCodeLine{04768\ \}}
\DoxyCodeLine{04769\ }
\DoxyCodeLine{04770\ }
\DoxyCodeLine{04771\ \textcolor{comment}{//\ Supports\ the\ UnorderedPointwise(m,\ \{a,\ b,\ c\})\ syntax.}}
\DoxyCodeLine{04772\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Tuple2Matcher,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04773\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04774\ \ \ \ \ \textcolor{keyword}{typename}\ internal::BoundSecondMatcher<Tuple2Matcher,\ T>\ >}
\DoxyCodeLine{04775\ UnorderedPointwise(\textcolor{keyword}{const}\ Tuple2Matcher\&\ tuple2\_matcher,}
\DoxyCodeLine{04776\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::initializer\_list<T>\ rhs)\ \{}
\DoxyCodeLine{04777\ \ \ \textcolor{keywordflow}{return}\ UnorderedPointwise(tuple2\_matcher,\ std::vector<T>(rhs));}
\DoxyCodeLine{04778\ \}}
\DoxyCodeLine{04779\ }
\DoxyCodeLine{04780\ \textcolor{comment}{//\ Matches\ an\ STL-\/style\ container\ or\ a\ native\ array\ that\ contains\ at}}
\DoxyCodeLine{04781\ \textcolor{comment}{//\ least\ one\ element\ matching\ the\ given\ value\ or\ matcher.}}
\DoxyCodeLine{04782\ \textcolor{comment}{//}}
\DoxyCodeLine{04783\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{04784\ \textcolor{comment}{//\ \ \ ::std::set<int>\ page\_ids;}}
\DoxyCodeLine{04785\ \textcolor{comment}{//\ \ \ page\_ids.insert(3);}}
\DoxyCodeLine{04786\ \textcolor{comment}{//\ \ \ page\_ids.insert(1);}}
\DoxyCodeLine{04787\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Contains(1));}}
\DoxyCodeLine{04788\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Contains(Gt(2)));}}
\DoxyCodeLine{04789\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Not(Contains(4)));\ \ //\ See\ below\ for\ Times(0)}}
\DoxyCodeLine{04790\ \textcolor{comment}{//}}
\DoxyCodeLine{04791\ \textcolor{comment}{//\ \ \ ::std::map<int,\ size\_t>\ page\_lengths;}}
\DoxyCodeLine{04792\ \textcolor{comment}{//\ \ \ page\_lengths[1]\ =\ 100;}}
\DoxyCodeLine{04793\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_lengths,}}
\DoxyCodeLine{04794\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Contains(::std::pair<const\ int,\ size\_t>(1,\ 100)));}}
\DoxyCodeLine{04795\ \textcolor{comment}{//}}
\DoxyCodeLine{04796\ \textcolor{comment}{//\ \ \ const\ char*\ user\_ids[]\ =\ \{\ "{}joe"{},\ "{}mike"{},\ "{}tom"{}\ \};}}
\DoxyCodeLine{04797\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(user\_ids,\ Contains(Eq(::std::string("{}tom"{}))));}}
\DoxyCodeLine{04798\ \textcolor{comment}{//}}
\DoxyCodeLine{04799\ \textcolor{comment}{//\ The\ matcher\ supports\ a\ modifier\ \`{}Times`\ that\ allows\ to\ check\ for\ arbitrary}}
\DoxyCodeLine{04800\ \textcolor{comment}{//\ occurrences\ including\ testing\ for\ absence\ with\ Times(0).}}
\DoxyCodeLine{04801\ \textcolor{comment}{//}}
\DoxyCodeLine{04802\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{04803\ \textcolor{comment}{//\ \ \ ::std::vector<int>\ ids;}}
\DoxyCodeLine{04804\ \textcolor{comment}{//\ \ \ ids.insert(1);}}
\DoxyCodeLine{04805\ \textcolor{comment}{//\ \ \ ids.insert(1);}}
\DoxyCodeLine{04806\ \textcolor{comment}{//\ \ \ ids.insert(3);}}
\DoxyCodeLine{04807\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(ids,\ Contains(1).Times(2));\ \ \ \ \ \ //\ 1\ occurs\ 2\ times}}
\DoxyCodeLine{04808\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(ids,\ Contains(2).Times(0));\ \ \ \ \ \ //\ 2\ is\ not\ present}}
\DoxyCodeLine{04809\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(ids,\ Contains(3).Times(Ge(1)));\ \ //\ 3\ occurs\ at\ least\ once}}
\DoxyCodeLine{04810\ }
\DoxyCodeLine{04811\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{04812\ \textcolor{keyword}{inline}\ internal::ContainsMatcher<M>\ Contains(M\ matcher)\ \{}
\DoxyCodeLine{04813\ \ \ \textcolor{keywordflow}{return}\ internal::ContainsMatcher<M>(matcher);}
\DoxyCodeLine{04814\ \}}
\DoxyCodeLine{04815\ }
\DoxyCodeLine{04816\ \textcolor{comment}{//\ IsSupersetOf(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{04817\ \textcolor{comment}{//\ IsSupersetOf(pointer,\ count)}}
\DoxyCodeLine{04818\ \textcolor{comment}{//\ IsSupersetOf(array)}}
\DoxyCodeLine{04819\ \textcolor{comment}{//\ IsSupersetOf(container)}}
\DoxyCodeLine{04820\ \textcolor{comment}{//\ IsSupersetOf(\{e1,\ e2,\ ...,\ en\})}}
\DoxyCodeLine{04821\ \textcolor{comment}{//}}
\DoxyCodeLine{04822\ \textcolor{comment}{//\ IsSupersetOf()\ verifies\ that\ a\ surjective\ partial\ mapping\ onto\ a\ collection}}
\DoxyCodeLine{04823\ \textcolor{comment}{//\ of\ matchers\ exists.\ In\ other\ words,\ a\ container\ matches}}
\DoxyCodeLine{04824\ \textcolor{comment}{//\ IsSupersetOf(\{e1,\ ...,\ en\})\ if\ and\ only\ if\ there\ is\ a\ permutation}}
\DoxyCodeLine{04825\ \textcolor{comment}{//\ \{y1,\ ...,\ yn\}\ of\ some\ of\ the\ container's\ elements\ where\ y1\ matches\ e1,}}
\DoxyCodeLine{04826\ \textcolor{comment}{//\ ...,\ and\ yn\ matches\ en.\ Obviously,\ the\ size\ of\ the\ container\ must\ be\ >=\ n}}
\DoxyCodeLine{04827\ \textcolor{comment}{//\ in\ order\ to\ have\ a\ match.\ Examples:}}
\DoxyCodeLine{04828\ \textcolor{comment}{//}}
\DoxyCodeLine{04829\ \textcolor{comment}{//\ -\/\ \{1,\ 2,\ 3\}\ matches\ IsSupersetOf(\{Ge(3),\ Ne(0)\}),\ as\ 3\ matches\ Ge(3)\ and}}
\DoxyCodeLine{04830\ \textcolor{comment}{//\ \ \ 1\ matches\ Ne(0).}}
\DoxyCodeLine{04831\ \textcolor{comment}{//\ -\/\ \{1,\ 2\}\ doesn't\ match\ IsSupersetOf(\{Eq(1),\ Lt(2)\}),\ even\ though\ 1\ matches}}
\DoxyCodeLine{04832\ \textcolor{comment}{//\ \ \ both\ Eq(1)\ and\ Lt(2).\ The\ reason\ is\ that\ different\ matchers\ must\ be\ used}}
\DoxyCodeLine{04833\ \textcolor{comment}{//\ \ \ for\ elements\ in\ different\ slots\ of\ the\ container.}}
\DoxyCodeLine{04834\ \textcolor{comment}{//\ -\/\ \{1,\ 1,\ 2\}\ matches\ IsSupersetOf(\{Eq(1),\ Lt(2)\}),\ as\ (the\ first)\ 1\ matches}}
\DoxyCodeLine{04835\ \textcolor{comment}{//\ \ \ Eq(1)\ and\ (the\ second)\ 1\ matches\ Lt(2).}}
\DoxyCodeLine{04836\ \textcolor{comment}{//\ -\/\ \{1,\ 2,\ 3\}\ matches\ IsSupersetOf(Gt(1),\ Gt(1)),\ as\ 2\ matches\ (the\ first)}}
\DoxyCodeLine{04837\ \textcolor{comment}{//\ \ \ Gt(1)\ and\ 3\ matches\ (the\ second)\ Gt(1).}}
\DoxyCodeLine{04838\ \textcolor{comment}{//}}
\DoxyCodeLine{04839\ \textcolor{comment}{//\ The\ matchers\ can\ be\ specified\ as\ an\ array,\ a\ pointer\ and\ count,\ a\ container,}}
\DoxyCodeLine{04840\ \textcolor{comment}{//\ an\ initializer\ list,\ or\ an\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the}}
\DoxyCodeLine{04841\ \textcolor{comment}{//\ underlying\ matchers\ can\ be\ either\ values\ or\ matchers.}}
\DoxyCodeLine{04842\ }
\DoxyCodeLine{04843\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{04844\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04845\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{04846\ IsSupersetOf(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{04847\ \ \ \textcolor{keyword}{typedef}\ typename\ ::std::iterator\_traits<Iter>::value\_type\ T;}
\DoxyCodeLine{04848\ \ \ \textcolor{keywordflow}{return}\ internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{04849\ \ \ \ \ \ \ internal::UnorderedMatcherRequire::Superset,\ first,\ last);}
\DoxyCodeLine{04850\ \}}
\DoxyCodeLine{04851\ }
\DoxyCodeLine{04852\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04853\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSupersetOf(}
\DoxyCodeLine{04854\ \ \ \ \ \textcolor{keyword}{const}\ T*\ pointer,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{04855\ \ \ \textcolor{keywordflow}{return}\ IsSupersetOf(pointer,\ pointer\ +\ count);}
\DoxyCodeLine{04856\ \}}
\DoxyCodeLine{04857\ }
\DoxyCodeLine{04858\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{04859\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSupersetOf(}
\DoxyCodeLine{04860\ \ \ \ \ \textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{04861\ \ \ \textcolor{keywordflow}{return}\ IsSupersetOf(array,\ N);}
\DoxyCodeLine{04862\ \}}
\DoxyCodeLine{04863\ }
\DoxyCodeLine{04864\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04865\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04866\ \ \ \ \ \textcolor{keyword}{typename}\ Container::value\_type>}
\DoxyCodeLine{04867\ IsSupersetOf(\textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{04868\ \ \ \textcolor{keywordflow}{return}\ IsSupersetOf(container.begin(),\ container.end());}
\DoxyCodeLine{04869\ \}}
\DoxyCodeLine{04870\ }
\DoxyCodeLine{04871\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04872\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSupersetOf(}
\DoxyCodeLine{04873\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{04874\ \ \ \textcolor{keywordflow}{return}\ IsSupersetOf(xs.begin(),\ xs.end());}
\DoxyCodeLine{04875\ \}}
\DoxyCodeLine{04876\ }
\DoxyCodeLine{04877\ \textcolor{comment}{//\ IsSubsetOf(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{04878\ \textcolor{comment}{//\ IsSubsetOf(pointer,\ count)}}
\DoxyCodeLine{04879\ \textcolor{comment}{//\ IsSubsetOf(array)}}
\DoxyCodeLine{04880\ \textcolor{comment}{//\ IsSubsetOf(container)}}
\DoxyCodeLine{04881\ \textcolor{comment}{//\ IsSubsetOf(\{e1,\ e2,\ ...,\ en\})}}
\DoxyCodeLine{04882\ \textcolor{comment}{//}}
\DoxyCodeLine{04883\ \textcolor{comment}{//\ IsSubsetOf()\ verifies\ that\ an\ injective\ mapping\ onto\ a\ collection\ of\ matchers}}
\DoxyCodeLine{04884\ \textcolor{comment}{//\ exists.\ \ In\ other\ words,\ a\ container\ matches\ IsSubsetOf(\{e1,\ ...,\ en\})\ if\ and}}
\DoxyCodeLine{04885\ \textcolor{comment}{//\ only\ if\ there\ is\ a\ subset\ of\ matchers\ \{m1,\ ...,\ mk\}\ which\ would\ match\ the}}
\DoxyCodeLine{04886\ \textcolor{comment}{//\ container\ using\ UnorderedElementsAre.\ \ Obviously,\ the\ size\ of\ the\ container}}
\DoxyCodeLine{04887\ \textcolor{comment}{//\ must\ be\ <=\ n\ in\ order\ to\ have\ a\ match.\ Examples:}}
\DoxyCodeLine{04888\ \textcolor{comment}{//}}
\DoxyCodeLine{04889\ \textcolor{comment}{//\ -\/\ \{1\}\ matches\ IsSubsetOf(\{Gt(0),\ Lt(0)\}),\ as\ 1\ matches\ Gt(0).}}
\DoxyCodeLine{04890\ \textcolor{comment}{//\ -\/\ \{1,\ -\/1\}\ matches\ IsSubsetOf(\{Lt(0),\ Gt(0)\}),\ as\ 1\ matches\ Gt(0)\ and\ -\/1}}
\DoxyCodeLine{04891\ \textcolor{comment}{//\ \ \ matches\ Lt(0).}}
\DoxyCodeLine{04892\ \textcolor{comment}{//\ -\/\ \{1,\ 2\}\ doesn't\ matches\ IsSubsetOf(\{Gt(0),\ Lt(0)\}),\ even\ though\ 1\ and\ 2\ both}}
\DoxyCodeLine{04893\ \textcolor{comment}{//\ \ \ match\ Gt(0).\ The\ reason\ is\ that\ different\ matchers\ must\ be\ used\ for}}
\DoxyCodeLine{04894\ \textcolor{comment}{//\ \ \ elements\ in\ different\ slots\ of\ the\ container.}}
\DoxyCodeLine{04895\ \textcolor{comment}{//}}
\DoxyCodeLine{04896\ \textcolor{comment}{//\ The\ matchers\ can\ be\ specified\ as\ an\ array,\ a\ pointer\ and\ count,\ a\ container,}}
\DoxyCodeLine{04897\ \textcolor{comment}{//\ an\ initializer\ list,\ or\ an\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the}}
\DoxyCodeLine{04898\ \textcolor{comment}{//\ underlying\ matchers\ can\ be\ either\ values\ or\ matchers.}}
\DoxyCodeLine{04899\ }
\DoxyCodeLine{04900\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{04901\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04902\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{04903\ IsSubsetOf(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{04904\ \ \ \textcolor{keyword}{typedef}\ typename\ ::std::iterator\_traits<Iter>::value\_type\ T;}
\DoxyCodeLine{04905\ \ \ \textcolor{keywordflow}{return}\ internal::UnorderedElementsAreArrayMatcher<T>(}
\DoxyCodeLine{04906\ \ \ \ \ \ \ internal::UnorderedMatcherRequire::Subset,\ first,\ last);}
\DoxyCodeLine{04907\ \}}
\DoxyCodeLine{04908\ }
\DoxyCodeLine{04909\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04910\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSubsetOf(}
\DoxyCodeLine{04911\ \ \ \ \ \textcolor{keyword}{const}\ T*\ pointer,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{04912\ \ \ \textcolor{keywordflow}{return}\ IsSubsetOf(pointer,\ pointer\ +\ count);}
\DoxyCodeLine{04913\ \}}
\DoxyCodeLine{04914\ }
\DoxyCodeLine{04915\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{04916\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSubsetOf(}
\DoxyCodeLine{04917\ \ \ \ \ \textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{04918\ \ \ \textcolor{keywordflow}{return}\ IsSubsetOf(array,\ N);}
\DoxyCodeLine{04919\ \}}
\DoxyCodeLine{04920\ }
\DoxyCodeLine{04921\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{04922\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{04923\ \ \ \ \ \textcolor{keyword}{typename}\ Container::value\_type>}
\DoxyCodeLine{04924\ IsSubsetOf(\textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{04925\ \ \ \textcolor{keywordflow}{return}\ IsSubsetOf(container.begin(),\ container.end());}
\DoxyCodeLine{04926\ \}}
\DoxyCodeLine{04927\ }
\DoxyCodeLine{04928\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04929\ \textcolor{keyword}{inline}\ internal::UnorderedElementsAreArrayMatcher<T>\ IsSubsetOf(}
\DoxyCodeLine{04930\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{04931\ \ \ \textcolor{keywordflow}{return}\ IsSubsetOf(xs.begin(),\ xs.end());}
\DoxyCodeLine{04932\ \}}
\DoxyCodeLine{04933\ }
\DoxyCodeLine{04934\ \textcolor{comment}{//\ Matches\ an\ STL-\/style\ container\ or\ a\ native\ array\ that\ contains\ only}}
\DoxyCodeLine{04935\ \textcolor{comment}{//\ elements\ matching\ the\ given\ value\ or\ matcher.}}
\DoxyCodeLine{04936\ \textcolor{comment}{//}}
\DoxyCodeLine{04937\ \textcolor{comment}{//\ Each(m)\ is\ semantically\ equivalent\ to\ \`{}Not(Contains(Not(m)))`.\ Only}}
\DoxyCodeLine{04938\ \textcolor{comment}{//\ the\ messages\ are\ different.}}
\DoxyCodeLine{04939\ \textcolor{comment}{//}}
\DoxyCodeLine{04940\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{04941\ \textcolor{comment}{//\ \ \ ::std::set<int>\ page\_ids;}}
\DoxyCodeLine{04942\ \textcolor{comment}{//\ \ \ //\ Each(m)\ matches\ an\ empty\ container,\ regardless\ of\ what\ m\ is.}}
\DoxyCodeLine{04943\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Each(Eq(1)));}}
\DoxyCodeLine{04944\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Each(Eq(77)));}}
\DoxyCodeLine{04945\ \textcolor{comment}{//}}
\DoxyCodeLine{04946\ \textcolor{comment}{//\ \ \ page\_ids.insert(3);}}
\DoxyCodeLine{04947\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Each(Gt(0)));}}
\DoxyCodeLine{04948\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Not(Each(Gt(4))));}}
\DoxyCodeLine{04949\ \textcolor{comment}{//\ \ \ page\_ids.insert(1);}}
\DoxyCodeLine{04950\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_ids,\ Not(Each(Lt(2))));}}
\DoxyCodeLine{04951\ \textcolor{comment}{//}}
\DoxyCodeLine{04952\ \textcolor{comment}{//\ \ \ ::std::map<int,\ size\_t>\ page\_lengths;}}
\DoxyCodeLine{04953\ \textcolor{comment}{//\ \ \ page\_lengths[1]\ =\ 100;}}
\DoxyCodeLine{04954\ \textcolor{comment}{//\ \ \ page\_lengths[2]\ =\ 200;}}
\DoxyCodeLine{04955\ \textcolor{comment}{//\ \ \ page\_lengths[3]\ =\ 300;}}
\DoxyCodeLine{04956\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_lengths,\ Not(Each(Pair(1,\ 100))));}}
\DoxyCodeLine{04957\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(page\_lengths,\ Each(Key(Le(3))));}}
\DoxyCodeLine{04958\ \textcolor{comment}{//}}
\DoxyCodeLine{04959\ \textcolor{comment}{//\ \ \ const\ char*\ user\_ids[]\ =\ \{\ "{}joe"{},\ "{}mike"{},\ "{}tom"{}\ \};}}
\DoxyCodeLine{04960\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(user\_ids,\ Not(Each(Eq(::std::string("{}tom"{})))));}}
\DoxyCodeLine{04961\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{04962\ \textcolor{keyword}{inline}\ internal::EachMatcher<M>\ Each(M\ matcher)\ \{}
\DoxyCodeLine{04963\ \ \ \textcolor{keywordflow}{return}\ internal::EachMatcher<M>(matcher);}
\DoxyCodeLine{04964\ \}}
\DoxyCodeLine{04965\ }
\DoxyCodeLine{04966\ \textcolor{comment}{//\ Key(inner\_matcher)\ matches\ an\ std::pair\ whose\ 'first'\ field\ matches}}
\DoxyCodeLine{04967\ \textcolor{comment}{//\ inner\_matcher.\ \ For\ example,\ Contains(Key(Ge(5)))\ can\ be\ used\ to\ match\ an}}
\DoxyCodeLine{04968\ \textcolor{comment}{//\ std::map\ that\ contains\ at\ least\ one\ element\ whose\ key\ is\ >=\ 5.}}
\DoxyCodeLine{04969\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{04970\ \textcolor{keyword}{inline}\ internal::KeyMatcher<M>\ Key(M\ inner\_matcher)\ \{}
\DoxyCodeLine{04971\ \ \ \textcolor{keywordflow}{return}\ internal::KeyMatcher<M>(inner\_matcher);}
\DoxyCodeLine{04972\ \}}
\DoxyCodeLine{04973\ }
\DoxyCodeLine{04974\ \textcolor{comment}{//\ Pair(first\_matcher,\ second\_matcher)\ matches\ a\ std::pair\ whose\ 'first'\ field}}
\DoxyCodeLine{04975\ \textcolor{comment}{//\ matches\ first\_matcher\ and\ whose\ 'second'\ field\ matches\ second\_matcher.\ \ For}}
\DoxyCodeLine{04976\ \textcolor{comment}{//\ example,\ EXPECT\_THAT(map\_type,\ ElementsAre(Pair(Ge(5),\ "{}foo"{})))\ can\ be\ used}}
\DoxyCodeLine{04977\ \textcolor{comment}{//\ to\ match\ a\ std::map<int,\ string>\ that\ contains\ exactly\ one\ element\ whose\ key}}
\DoxyCodeLine{04978\ \textcolor{comment}{//\ is\ >=\ 5\ and\ whose\ value\ equals\ "{}foo"{}.}}
\DoxyCodeLine{04979\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ FirstMatcher,\ \textcolor{keyword}{typename}\ SecondMatcher>}
\DoxyCodeLine{04980\ \textcolor{keyword}{inline}\ internal::PairMatcher<FirstMatcher,\ SecondMatcher>}
\DoxyCodeLine{04981\ Pair(FirstMatcher\ first\_matcher,\ SecondMatcher\ second\_matcher)\ \{}
\DoxyCodeLine{04982\ \ \ \textcolor{keywordflow}{return}\ internal::PairMatcher<FirstMatcher,\ SecondMatcher>(}
\DoxyCodeLine{04983\ \ \ \ \ \ \ first\_matcher,\ second\_matcher);}
\DoxyCodeLine{04984\ \}}
\DoxyCodeLine{04985\ }
\DoxyCodeLine{04986\ \textcolor{keyword}{namespace\ }no\_adl\ \{}
\DoxyCodeLine{04987\ \textcolor{comment}{//\ Conditional()\ creates\ a\ matcher\ that\ conditionally\ uses\ either\ the\ first\ or}}
\DoxyCodeLine{04988\ \textcolor{comment}{//\ second\ matcher\ provided.\ For\ example,\ we\ could\ create\ an\ \`{}equal\ if,\ and\ only}}
\DoxyCodeLine{04989\ \textcolor{comment}{//\ if'\ matcher\ using\ the\ Conditional\ wrapper\ as\ follows:}}
\DoxyCodeLine{04990\ \textcolor{comment}{//}}
\DoxyCodeLine{04991\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(result,\ Conditional(condition,\ Eq(expected),\ Ne(expected)));}}
\DoxyCodeLine{04992\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherTrue,\ \textcolor{keyword}{typename}\ MatcherFalse>}
\DoxyCodeLine{04993\ internal::ConditionalMatcher<MatcherTrue,\ MatcherFalse>\ Conditional(}
\DoxyCodeLine{04994\ \ \ \ \ \textcolor{keywordtype}{bool}\ condition,\ MatcherTrue\ matcher\_true,\ MatcherFalse\ matcher\_false)\ \{}
\DoxyCodeLine{04995\ \ \ \textcolor{keywordflow}{return}\ internal::ConditionalMatcher<MatcherTrue,\ MatcherFalse>(}
\DoxyCodeLine{04996\ \ \ \ \ \ \ condition,\ std::move(matcher\_true),\ std::move(matcher\_false));}
\DoxyCodeLine{04997\ \}}
\DoxyCodeLine{04998\ }
\DoxyCodeLine{04999\ \textcolor{comment}{//\ FieldsAre(matchers...)\ matches\ piecewise\ the\ fields\ of\ compatible\ structs.}}
\DoxyCodeLine{05000\ \textcolor{comment}{//\ These\ include\ those\ that\ support\ \`{}get<I>(obj)`,\ and\ when\ structured\ bindings}}
\DoxyCodeLine{05001\ \textcolor{comment}{//\ are\ enabled\ any\ class\ that\ supports\ them.}}
\DoxyCodeLine{05002\ \textcolor{comment}{//\ In\ particular,\ \`{}std::tuple`,\ \`{}std::pair`,\ \`{}std::array`\ and\ aggregate\ types.}}
\DoxyCodeLine{05003\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ M>}
\DoxyCodeLine{05004\ internal::FieldsAreMatcher<typename\ std::decay<M>::type...>\ FieldsAre(}
\DoxyCodeLine{05005\ \ \ \ \ M\&\&...\ matchers)\ \{}
\DoxyCodeLine{05006\ \ \ \textcolor{keywordflow}{return}\ internal::FieldsAreMatcher<typename\ std::decay<M>::type...>(}
\DoxyCodeLine{05007\ \ \ \ \ \ \ std::forward<M>(matchers)...);}
\DoxyCodeLine{05008\ \}}
\DoxyCodeLine{05009\ }
\DoxyCodeLine{05010\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ a\ pointer\ (raw\ or\ smart)\ that\ matches}}
\DoxyCodeLine{05011\ \textcolor{comment}{//\ inner\_matcher.}}
\DoxyCodeLine{05012\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{05013\ \textcolor{keyword}{inline}\ internal::PointerMatcher<InnerMatcher>\ Pointer(}
\DoxyCodeLine{05014\ \ \ \ \ \textcolor{keyword}{const}\ InnerMatcher\&\ inner\_matcher)\ \{}
\DoxyCodeLine{05015\ \ \ \textcolor{keywordflow}{return}\ internal::PointerMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{05016\ \}}
\DoxyCodeLine{05017\ }
\DoxyCodeLine{05018\ \textcolor{comment}{//\ Creates\ a\ matcher\ that\ matches\ an\ object\ that\ has\ an\ address\ that\ matches}}
\DoxyCodeLine{05019\ \textcolor{comment}{//\ inner\_matcher.}}
\DoxyCodeLine{05020\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{05021\ \textcolor{keyword}{inline}\ internal::AddressMatcher<InnerMatcher>\ Address(}
\DoxyCodeLine{05022\ \ \ \ \ \textcolor{keyword}{const}\ InnerMatcher\&\ inner\_matcher)\ \{}
\DoxyCodeLine{05023\ \ \ \textcolor{keywordflow}{return}\ internal::AddressMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{05024\ \}}
\DoxyCodeLine{05025\ }
\DoxyCodeLine{05026\ \textcolor{comment}{//\ Matches\ a\ base64\ escaped\ string,\ when\ the\ unescaped\ string\ matches\ the}}
\DoxyCodeLine{05027\ \textcolor{comment}{//\ internal\ matcher.}}
\DoxyCodeLine{05028\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherType>}
\DoxyCodeLine{05029\ internal::WhenBase64UnescapedMatcher\ WhenBase64Unescaped(}
\DoxyCodeLine{05030\ \ \ \ \ \textcolor{keyword}{const}\ MatcherType\&\ internal\_matcher)\ \{}
\DoxyCodeLine{05031\ \ \ \textcolor{keywordflow}{return}\ internal::WhenBase64UnescapedMatcher(internal\_matcher);}
\DoxyCodeLine{05032\ \}}
\DoxyCodeLine{05033\ \}\ \ \textcolor{comment}{//\ namespace\ no\_adl}}
\DoxyCodeLine{05034\ }
\DoxyCodeLine{05035\ \textcolor{comment}{//\ Returns\ a\ predicate\ that\ is\ satisfied\ by\ anything\ that\ matches\ the}}
\DoxyCodeLine{05036\ \textcolor{comment}{//\ given\ matcher.}}
\DoxyCodeLine{05037\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05038\ \textcolor{keyword}{inline}\ internal::MatcherAsPredicate<M>\ Matches(M\ matcher)\ \{}
\DoxyCodeLine{05039\ \ \ \textcolor{keywordflow}{return}\ internal::MatcherAsPredicate<M>(matcher);}
\DoxyCodeLine{05040\ \}}
\DoxyCodeLine{05041\ }
\DoxyCodeLine{05042\ \textcolor{comment}{//\ Returns\ true\ if\ and\ only\ if\ the\ value\ matches\ the\ matcher.}}
\DoxyCodeLine{05043\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05044\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ Value(\textcolor{keyword}{const}\ T\&\ value,\ M\ matcher)\ \{}
\DoxyCodeLine{05045\ \ \ \textcolor{keywordflow}{return}\ testing::Matches(matcher)(value);}
\DoxyCodeLine{05046\ \}}
\DoxyCodeLine{05047\ }
\DoxyCodeLine{05048\ \textcolor{comment}{//\ Matches\ the\ value\ against\ the\ given\ matcher\ and\ explains\ the\ match}}
\DoxyCodeLine{05049\ \textcolor{comment}{//\ result\ to\ listener.}}
\DoxyCodeLine{05050\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05051\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ ExplainMatchResult(}
\DoxyCodeLine{05052\ \ \ \ \ M\ matcher,\ \textcolor{keyword}{const}\ T\&\ value,\ MatchResultListener*\ listener)\ \{}
\DoxyCodeLine{05053\ \ \ \textcolor{keywordflow}{return}\ SafeMatcherCast<const\ T\&>(matcher).MatchAndExplain(value,\ listener);}
\DoxyCodeLine{05054\ \}}
\DoxyCodeLine{05055\ }
\DoxyCodeLine{05056\ \textcolor{comment}{//\ Returns\ a\ string\ representation\ of\ the\ given\ matcher.\ \ Useful\ for\ description}}
\DoxyCodeLine{05057\ \textcolor{comment}{//\ strings\ of\ matchers\ defined\ using\ MATCHER\_P*\ macros\ that\ accept\ matchers\ as}}
\DoxyCodeLine{05058\ \textcolor{comment}{//\ their\ arguments.\ \ For\ example:}}
\DoxyCodeLine{05059\ \textcolor{comment}{//}}
\DoxyCodeLine{05060\ \textcolor{comment}{//\ MATCHER\_P(XAndYThat,\ matcher,}}
\DoxyCodeLine{05061\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ "{}X\ that\ "{}\ +\ DescribeMatcher<int>(matcher,\ negation)\ +}}
\DoxyCodeLine{05062\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}\ and\ Y\ that\ "{}\ +\ DescribeMatcher<double>(matcher,\ negation))\ \{}}
\DoxyCodeLine{05063\ \textcolor{comment}{//\ \ \ return\ ExplainMatchResult(matcher,\ arg.x(),\ result\_listener)\ \&\&}}
\DoxyCodeLine{05064\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ ExplainMatchResult(matcher,\ arg.y(),\ result\_listener);}}
\DoxyCodeLine{05065\ \textcolor{comment}{//\ \}}}
\DoxyCodeLine{05066\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ M>}
\DoxyCodeLine{05067\ std::string\ DescribeMatcher(\textcolor{keyword}{const}\ M\&\ matcher,\ \textcolor{keywordtype}{bool}\ negation\ =\ \textcolor{keyword}{false})\ \{}
\DoxyCodeLine{05068\ \ \ ::std::stringstream\ ss;}
\DoxyCodeLine{05069\ \ \ Matcher<T>\ monomorphic\_matcher\ =\ SafeMatcherCast<T>(matcher);}
\DoxyCodeLine{05070\ \ \ \textcolor{keywordflow}{if}\ (negation)\ \{}
\DoxyCodeLine{05071\ \ \ \ \ monomorphic\_matcher.DescribeNegationTo(\&ss);}
\DoxyCodeLine{05072\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{05073\ \ \ \ \ monomorphic\_matcher.DescribeTo(\&ss);}
\DoxyCodeLine{05074\ \ \ \}}
\DoxyCodeLine{05075\ \ \ \textcolor{keywordflow}{return}\ ss.str();}
\DoxyCodeLine{05076\ \}}
\DoxyCodeLine{05077\ }
\DoxyCodeLine{05078\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{05079\ internal::ElementsAreMatcher<}
\DoxyCodeLine{05080\ \ \ \ \ std::tuple<typename\ std::decay<const\ Args\&>::type...>>}
\DoxyCodeLine{05081\ ElementsAre(\textcolor{keyword}{const}\ Args\&...\ matchers)\ \{}
\DoxyCodeLine{05082\ \ \ \textcolor{keywordflow}{return}\ internal::ElementsAreMatcher<}
\DoxyCodeLine{05083\ \ \ \ \ \ \ std::tuple<typename\ std::decay<const\ Args\&>::type...>>(}
\DoxyCodeLine{05084\ \ \ \ \ \ \ std::make\_tuple(matchers...));}
\DoxyCodeLine{05085\ \}}
\DoxyCodeLine{05086\ }
\DoxyCodeLine{05087\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{05088\ internal::UnorderedElementsAreMatcher<}
\DoxyCodeLine{05089\ \ \ \ \ std::tuple<typename\ std::decay<const\ Args\&>::type...>>}
\DoxyCodeLine{05090\ UnorderedElementsAre(\textcolor{keyword}{const}\ Args\&...\ matchers)\ \{}
\DoxyCodeLine{05091\ \ \ \textcolor{keywordflow}{return}\ internal::UnorderedElementsAreMatcher<}
\DoxyCodeLine{05092\ \ \ \ \ \ \ std::tuple<typename\ std::decay<const\ Args\&>::type...>>(}
\DoxyCodeLine{05093\ \ \ \ \ \ \ std::make\_tuple(matchers...));}
\DoxyCodeLine{05094\ \}}
\DoxyCodeLine{05095\ }
\DoxyCodeLine{05096\ \textcolor{comment}{//\ Define\ variadic\ matcher\ versions.}}
\DoxyCodeLine{05097\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{05098\ internal::AllOfMatcher<typename\ std::decay<const\ Args\&>::type...>\ AllOf(}
\DoxyCodeLine{05099\ \ \ \ \ \textcolor{keyword}{const}\ Args\&...\ matchers)\ \{}
\DoxyCodeLine{05100\ \ \ \textcolor{keywordflow}{return}\ internal::AllOfMatcher<typename\ std::decay<const\ Args\&>::type...>(}
\DoxyCodeLine{05101\ \ \ \ \ \ \ matchers...);}
\DoxyCodeLine{05102\ \}}
\DoxyCodeLine{05103\ }
\DoxyCodeLine{05104\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{05105\ internal::AnyOfMatcher<typename\ std::decay<const\ Args\&>::type...>\ AnyOf(}
\DoxyCodeLine{05106\ \ \ \ \ \textcolor{keyword}{const}\ Args\&...\ matchers)\ \{}
\DoxyCodeLine{05107\ \ \ \textcolor{keywordflow}{return}\ internal::AnyOfMatcher<typename\ std::decay<const\ Args\&>::type...>(}
\DoxyCodeLine{05108\ \ \ \ \ \ \ matchers...);}
\DoxyCodeLine{05109\ \}}
\DoxyCodeLine{05110\ }
\DoxyCodeLine{05111\ \textcolor{comment}{//\ AnyOfArray(array)}}
\DoxyCodeLine{05112\ \textcolor{comment}{//\ AnyOfArray(pointer,\ count)}}
\DoxyCodeLine{05113\ \textcolor{comment}{//\ AnyOfArray(container)}}
\DoxyCodeLine{05114\ \textcolor{comment}{//\ AnyOfArray(\{\ e1,\ e2,\ ...,\ en\ \})}}
\DoxyCodeLine{05115\ \textcolor{comment}{//\ AnyOfArray(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{05116\ \textcolor{comment}{//}}
\DoxyCodeLine{05117\ \textcolor{comment}{//\ AnyOfArray()\ verifies\ whether\ a\ given\ value\ matches\ any\ member\ of\ a}}
\DoxyCodeLine{05118\ \textcolor{comment}{//\ collection\ of\ matchers.}}
\DoxyCodeLine{05119\ \textcolor{comment}{//}}
\DoxyCodeLine{05120\ \textcolor{comment}{//\ AllOfArray(array)}}
\DoxyCodeLine{05121\ \textcolor{comment}{//\ AllOfArray(pointer,\ count)}}
\DoxyCodeLine{05122\ \textcolor{comment}{//\ AllOfArray(container)}}
\DoxyCodeLine{05123\ \textcolor{comment}{//\ AllOfArray(\{\ e1,\ e2,\ ...,\ en\ \})}}
\DoxyCodeLine{05124\ \textcolor{comment}{//\ AllOfArray(iterator\_first,\ iterator\_last)}}
\DoxyCodeLine{05125\ \textcolor{comment}{//}}
\DoxyCodeLine{05126\ \textcolor{comment}{//\ AllOfArray()\ verifies\ whether\ a\ given\ value\ matches\ all\ members\ of\ a}}
\DoxyCodeLine{05127\ \textcolor{comment}{//\ collection\ of\ matchers.}}
\DoxyCodeLine{05128\ \textcolor{comment}{//}}
\DoxyCodeLine{05129\ \textcolor{comment}{//\ The\ matchers\ can\ be\ specified\ as\ an\ array,\ a\ pointer\ and\ count,\ a\ container,}}
\DoxyCodeLine{05130\ \textcolor{comment}{//\ an\ initializer\ list,\ or\ an\ STL\ iterator\ range.\ In\ each\ of\ these\ cases,\ the}}
\DoxyCodeLine{05131\ \textcolor{comment}{//\ underlying\ matchers\ can\ be\ either\ values\ or\ matchers.}}
\DoxyCodeLine{05132\ }
\DoxyCodeLine{05133\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{05134\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<}
\DoxyCodeLine{05135\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{05136\ AnyOfArray(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{05137\ \ \ \textcolor{keywordflow}{return}\ internal::AnyOfArrayMatcher<}
\DoxyCodeLine{05138\ \ \ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>(first,\ last);}
\DoxyCodeLine{05139\ \}}
\DoxyCodeLine{05140\ }
\DoxyCodeLine{05141\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Iter>}
\DoxyCodeLine{05142\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<}
\DoxyCodeLine{05143\ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{05144\ AllOfArray(Iter\ first,\ Iter\ last)\ \{}
\DoxyCodeLine{05145\ \ \ \textcolor{keywordflow}{return}\ internal::AllOfArrayMatcher<}
\DoxyCodeLine{05146\ \ \ \ \ \ \ typename\ ::std::iterator\_traits<Iter>::value\_type>(first,\ last);}
\DoxyCodeLine{05147\ \}}
\DoxyCodeLine{05148\ }
\DoxyCodeLine{05149\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05150\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<T>\ AnyOfArray(\textcolor{keyword}{const}\ T*\ ptr,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{05151\ \ \ \textcolor{keywordflow}{return}\ AnyOfArray(ptr,\ ptr\ +\ count);}
\DoxyCodeLine{05152\ \}}
\DoxyCodeLine{05153\ }
\DoxyCodeLine{05154\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05155\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<T>\ AllOfArray(\textcolor{keyword}{const}\ T*\ ptr,\ \textcolor{keywordtype}{size\_t}\ count)\ \{}
\DoxyCodeLine{05156\ \ \ \textcolor{keywordflow}{return}\ AllOfArray(ptr,\ ptr\ +\ count);}
\DoxyCodeLine{05157\ \}}
\DoxyCodeLine{05158\ }
\DoxyCodeLine{05159\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{05160\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<T>\ AnyOfArray(\textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{05161\ \ \ \textcolor{keywordflow}{return}\ AnyOfArray(array,\ N);}
\DoxyCodeLine{05162\ \}}
\DoxyCodeLine{05163\ }
\DoxyCodeLine{05164\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{05165\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<T>\ AllOfArray(\textcolor{keyword}{const}\ T\ (\&array)[N])\ \{}
\DoxyCodeLine{05166\ \ \ \textcolor{keywordflow}{return}\ AllOfArray(array,\ N);}
\DoxyCodeLine{05167\ \}}
\DoxyCodeLine{05168\ }
\DoxyCodeLine{05169\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{05170\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<typename\ Container::value\_type>\ AnyOfArray(}
\DoxyCodeLine{05171\ \ \ \ \ \textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{05172\ \ \ \textcolor{keywordflow}{return}\ AnyOfArray(container.begin(),\ container.end());}
\DoxyCodeLine{05173\ \}}
\DoxyCodeLine{05174\ }
\DoxyCodeLine{05175\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Container>}
\DoxyCodeLine{05176\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<typename\ Container::value\_type>\ AllOfArray(}
\DoxyCodeLine{05177\ \ \ \ \ \textcolor{keyword}{const}\ Container\&\ container)\ \{}
\DoxyCodeLine{05178\ \ \ \textcolor{keywordflow}{return}\ AllOfArray(container.begin(),\ container.end());}
\DoxyCodeLine{05179\ \}}
\DoxyCodeLine{05180\ }
\DoxyCodeLine{05181\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05182\ \textcolor{keyword}{inline}\ internal::AnyOfArrayMatcher<T>\ AnyOfArray(}
\DoxyCodeLine{05183\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{05184\ \ \ \textcolor{keywordflow}{return}\ AnyOfArray(xs.begin(),\ xs.end());}
\DoxyCodeLine{05185\ \}}
\DoxyCodeLine{05186\ }
\DoxyCodeLine{05187\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05188\ \textcolor{keyword}{inline}\ internal::AllOfArrayMatcher<T>\ AllOfArray(}
\DoxyCodeLine{05189\ \ \ \ \ ::std::initializer\_list<T>\ xs)\ \{}
\DoxyCodeLine{05190\ \ \ \textcolor{keywordflow}{return}\ AllOfArray(xs.begin(),\ xs.end());}
\DoxyCodeLine{05191\ \}}
\DoxyCodeLine{05192\ }
\DoxyCodeLine{05193\ \textcolor{comment}{//\ Args<N1,\ N2,\ ...,\ Nk>(a\_matcher)\ matches\ a\ tuple\ if\ the\ selected}}
\DoxyCodeLine{05194\ \textcolor{comment}{//\ fields\ of\ it\ matches\ a\_matcher.\ \ C++\ doesn't\ support\ default}}
\DoxyCodeLine{05195\ \textcolor{comment}{//\ arguments\ for\ function\ templates,\ so\ we\ have\ to\ overload\ it.}}
\DoxyCodeLine{05196\ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}...\ k,\ \textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{05197\ internal::ArgsMatcher<typename\ std::decay<InnerMatcher>::type,\ k...>\ Args(}
\DoxyCodeLine{05198\ \ \ \ \ InnerMatcher\&\&\ matcher)\ \{}
\DoxyCodeLine{05199\ \ \ \textcolor{keywordflow}{return}\ internal::ArgsMatcher<typename\ std::decay<InnerMatcher>::type,\ k...>(}
\DoxyCodeLine{05200\ \ \ \ \ \ \ std::forward<InnerMatcher>(matcher));}
\DoxyCodeLine{05201\ \}}
\DoxyCodeLine{05202\ }
\DoxyCodeLine{05203\ \textcolor{comment}{//\ AllArgs(m)\ is\ a\ synonym\ of\ m.\ \ This\ is\ useful\ in}}
\DoxyCodeLine{05204\ \textcolor{comment}{//}}
\DoxyCodeLine{05205\ \textcolor{comment}{//\ \ \ EXPECT\_CALL(foo,\ Bar(\_,\ \_)).With(AllArgs(Eq()));}}
\DoxyCodeLine{05206\ \textcolor{comment}{//}}
\DoxyCodeLine{05207\ \textcolor{comment}{//\ which\ is\ easier\ to\ read\ than}}
\DoxyCodeLine{05208\ \textcolor{comment}{//}}
\DoxyCodeLine{05209\ \textcolor{comment}{//\ \ \ EXPECT\_CALL(foo,\ Bar(\_,\ \_)).With(Eq());}}
\DoxyCodeLine{05210\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InnerMatcher>}
\DoxyCodeLine{05211\ \textcolor{keyword}{inline}\ InnerMatcher\ AllArgs(\textcolor{keyword}{const}\ InnerMatcher\&\ matcher)\ \{\ \textcolor{keywordflow}{return}\ matcher;\ \}}
\DoxyCodeLine{05212\ }
\DoxyCodeLine{05213\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ value\ of\ an\ optional<>\ type\ variable.}}
\DoxyCodeLine{05214\ \textcolor{comment}{//\ The\ matcher\ implementation\ only\ uses\ '!arg'\ and\ requires\ that\ the\ optional<>}}
\DoxyCodeLine{05215\ \textcolor{comment}{//\ type\ has\ a\ 'value\_type'\ member\ type\ and\ that\ '*arg'\ is\ of\ type\ 'value\_type'}}
\DoxyCodeLine{05216\ \textcolor{comment}{//\ and\ is\ printable\ using\ 'PrintToString'.\ It\ is\ compatible\ with}}
\DoxyCodeLine{05217\ \textcolor{comment}{//\ std::optional/std::experimental::optional.}}
\DoxyCodeLine{05218\ \textcolor{comment}{//\ Note\ that\ to\ compare\ an\ optional\ type\ variable\ against\ nullopt\ you\ should}}
\DoxyCodeLine{05219\ \textcolor{comment}{//\ use\ Eq(nullopt)\ and\ not\ Eq(Optional(nullopt)).\ The\ latter\ implies\ that\ the}}
\DoxyCodeLine{05220\ \textcolor{comment}{//\ optional\ value\ contains\ an\ optional\ itself.}}
\DoxyCodeLine{05221\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ValueMatcher>}
\DoxyCodeLine{05222\ \textcolor{keyword}{inline}\ internal::OptionalMatcher<ValueMatcher>\ Optional(}
\DoxyCodeLine{05223\ \ \ \ \ \textcolor{keyword}{const}\ ValueMatcher\&\ value\_matcher)\ \{}
\DoxyCodeLine{05224\ \ \ \textcolor{keywordflow}{return}\ internal::OptionalMatcher<ValueMatcher>(value\_matcher);}
\DoxyCodeLine{05225\ \}}
\DoxyCodeLine{05226\ }
\DoxyCodeLine{05227\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ value\ of\ a\ absl::any\ type\ variable.}}
\DoxyCodeLine{05228\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05229\ PolymorphicMatcher<internal::any\_cast\_matcher::AnyCastMatcher<T>\ >\ AnyWith(}
\DoxyCodeLine{05230\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ T\&>\&\ matcher)\ \{}
\DoxyCodeLine{05231\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{05232\ \ \ \ \ \ \ internal::any\_cast\_matcher::AnyCastMatcher<T>(matcher));}
\DoxyCodeLine{05233\ \}}
\DoxyCodeLine{05234\ }
\DoxyCodeLine{05235\ \textcolor{comment}{//\ Returns\ a\ matcher\ that\ matches\ the\ value\ of\ a\ variant<>\ type\ variable.}}
\DoxyCodeLine{05236\ \textcolor{comment}{//\ The\ matcher\ implementation\ uses\ ADL\ to\ find\ the\ holds\_alternative\ and\ get}}
\DoxyCodeLine{05237\ \textcolor{comment}{//\ functions.}}
\DoxyCodeLine{05238\ \textcolor{comment}{//\ It\ is\ compatible\ with\ std::variant.}}
\DoxyCodeLine{05239\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05240\ PolymorphicMatcher<internal::variant\_matcher::VariantMatcher<T>\ >\ VariantWith(}
\DoxyCodeLine{05241\ \ \ \ \ \textcolor{keyword}{const}\ Matcher<const\ T\&>\&\ matcher)\ \{}
\DoxyCodeLine{05242\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{05243\ \ \ \ \ \ \ internal::variant\_matcher::VariantMatcher<T>(matcher));}
\DoxyCodeLine{05244\ \}}
\DoxyCodeLine{05245\ }
\DoxyCodeLine{05246\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{05247\ }
\DoxyCodeLine{05248\ \textcolor{comment}{//\ Anything\ inside\ the\ \`{}internal`\ namespace\ is\ internal\ to\ the\ implementation}}
\DoxyCodeLine{05249\ \textcolor{comment}{//\ and\ must\ not\ be\ used\ in\ user\ code!}}
\DoxyCodeLine{05250\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{05251\ }
\DoxyCodeLine{05252\ \textcolor{keyword}{class\ }WithWhatMatcherImpl\ \{}
\DoxyCodeLine{05253\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05254\ \ \ WithWhatMatcherImpl(Matcher<std::string>\ matcher)}
\DoxyCodeLine{05255\ \ \ \ \ \ \ :\ matcher\_(std::move(matcher))\ \{\}}
\DoxyCodeLine{05256\ }
\DoxyCodeLine{05257\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05258\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ .what()\ that\ "{}};}
\DoxyCodeLine{05259\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{05260\ \ \ \}}
\DoxyCodeLine{05261\ }
\DoxyCodeLine{05262\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05263\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}contains\ .what()\ that\ does\ not\ "{}};}
\DoxyCodeLine{05264\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{05265\ \ \ \}}
\DoxyCodeLine{05266\ }
\DoxyCodeLine{05267\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err>}
\DoxyCodeLine{05268\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ Err\&\ err,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05269\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ contains\ .what()\ (of\ value\ =\ "{}}\ <<\ err.what()}
\DoxyCodeLine{05270\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{})\ that\ "{}};}
\DoxyCodeLine{05271\ \ \ \ \ \textcolor{keywordflow}{return}\ matcher\_.MatchAndExplain(err.what(),\ listener);}
\DoxyCodeLine{05272\ \ \ \}}
\DoxyCodeLine{05273\ }
\DoxyCodeLine{05274\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{05275\ \ \ \textcolor{keyword}{const}\ Matcher<std::string>\ matcher\_;}
\DoxyCodeLine{05276\ \};}
\DoxyCodeLine{05277\ }
\DoxyCodeLine{05278\ \textcolor{keyword}{inline}\ PolymorphicMatcher<WithWhatMatcherImpl>\ WithWhat(}
\DoxyCodeLine{05279\ \ \ \ \ Matcher<std::string>\ m)\ \{}
\DoxyCodeLine{05280\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(WithWhatMatcherImpl(std::move(m)));}
\DoxyCodeLine{05281\ \}}
\DoxyCodeLine{05282\ }
\DoxyCodeLine{05283\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err>}
\DoxyCodeLine{05284\ \textcolor{keyword}{class\ }ExceptionMatcherImpl\ \{}
\DoxyCodeLine{05285\ \ \ \textcolor{keyword}{class\ }NeverThrown\ \{}
\DoxyCodeLine{05286\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05287\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ what()\ const\ noexcept\ \{}
\DoxyCodeLine{05288\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}this\ exception\ should\ never\ be\ thrown"{}};}
\DoxyCodeLine{05289\ \ \ \ \ \}}
\DoxyCodeLine{05290\ \ \ \};}
\DoxyCodeLine{05291\ }
\DoxyCodeLine{05292\ \ \ \textcolor{comment}{//\ If\ the\ matchee\ raises\ an\ exception\ of\ a\ wrong\ type,\ we'd\ like\ to}}
\DoxyCodeLine{05293\ \ \ \textcolor{comment}{//\ catch\ it\ and\ print\ its\ message\ and\ type.\ To\ do\ that,\ we\ add\ an\ additional}}
\DoxyCodeLine{05294\ \ \ \textcolor{comment}{//\ catch\ clause:}}
\DoxyCodeLine{05295\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05296\ \ \ \textcolor{comment}{//\ \ \ \ \ try\ \{\ ...\ \}}}
\DoxyCodeLine{05297\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ Err\&)\ \{\ /*\ an\ expected\ exception\ */\ \}}}
\DoxyCodeLine{05298\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ std::exception\&)\ \{\ /*\ exception\ of\ a\ wrong\ type\ */\ \}}}
\DoxyCodeLine{05299\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05300\ \ \ \textcolor{comment}{//\ However,\ if\ the\ \`{}Err`\ itself\ is\ \`{}std::exception`,\ we'd\ end\ up\ with\ two}}
\DoxyCodeLine{05301\ \ \ \textcolor{comment}{//\ identical\ \`{}catch`\ clauses:}}
\DoxyCodeLine{05302\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05303\ \ \ \textcolor{comment}{//\ \ \ \ \ try\ \{\ ...\ \}}}
\DoxyCodeLine{05304\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ std::exception\&)\ \{\ /*\ an\ expected\ exception\ */\ \}}}
\DoxyCodeLine{05305\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ std::exception\&)\ \{\ /*\ exception\ of\ a\ wrong\ type\ */\ \}}}
\DoxyCodeLine{05306\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05307\ \ \ \textcolor{comment}{//\ This\ can\ cause\ a\ warning\ or\ an\ error\ in\ some\ compilers.\ To\ resolve}}
\DoxyCodeLine{05308\ \ \ \textcolor{comment}{//\ the\ issue,\ we\ use\ a\ fake\ error\ type\ whenever\ \`{}Err`\ is\ \`{}std::exception`:}}
\DoxyCodeLine{05309\ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{05310\ \ \ \textcolor{comment}{//\ \ \ \ \ try\ \{\ ...\ \}}}
\DoxyCodeLine{05311\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ std::exception\&)\ \{\ /*\ an\ expected\ exception\ */\ \}}}
\DoxyCodeLine{05312\ \ \ \textcolor{comment}{//\ \ \ \ \ catch\ (const\ NeverThrown\&)\ \{\ /*\ exception\ of\ a\ wrong\ type\ */\ \}}}
\DoxyCodeLine{05313\ \ \ \textcolor{keyword}{using\ }DefaultExceptionType\ =\ \textcolor{keyword}{typename}\ std::conditional<}
\DoxyCodeLine{05314\ \ \ \ \ \ \ std::is\_same<\textcolor{keyword}{typename}\ std::remove\_cv<}
\DoxyCodeLine{05315\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::remove\_reference<Err>::type>::type,}
\DoxyCodeLine{05316\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::exception>::value,}
\DoxyCodeLine{05317\ \ \ \ \ \ \ \textcolor{keyword}{const}\ NeverThrown\&,\ \textcolor{keyword}{const}\ std::exception\&>::type;}
\DoxyCodeLine{05318\ }
\DoxyCodeLine{05319\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05320\ \ \ ExceptionMatcherImpl(Matcher<const\ Err\&>\ matcher)}
\DoxyCodeLine{05321\ \ \ \ \ \ \ :\ matcher\_(std::move(matcher))\ \{\}}
\DoxyCodeLine{05322\ }
\DoxyCodeLine{05323\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05324\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ which\ is\ a\ "{}}\ <<\ GetTypeName<Err>();}
\DoxyCodeLine{05325\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ which\ "{}};}
\DoxyCodeLine{05326\ \ \ \ \ matcher\_.DescribeTo(os);}
\DoxyCodeLine{05327\ \ \ \}}
\DoxyCodeLine{05328\ }
\DoxyCodeLine{05329\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(std::ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05330\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ which\ is\ not\ a\ "{}}\ <<\ GetTypeName<Err>();}
\DoxyCodeLine{05331\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}\ which\ "{}};}
\DoxyCodeLine{05332\ \ \ \ \ matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{05333\ \ \ \}}
\DoxyCodeLine{05334\ }
\DoxyCodeLine{05335\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05336\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\&\&\ x,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05337\ \ \ \ \ \textcolor{keywordflow}{try}\ \{}
\DoxyCodeLine{05338\ \ \ \ \ \ \ (void)(std::forward<T>(x)());}
\DoxyCodeLine{05339\ \ \ \ \ \}\ \textcolor{keywordflow}{catch}\ (\textcolor{keyword}{const}\ Err\&\ err)\ \{}
\DoxyCodeLine{05340\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ which\ is\ a\ "{}}\ <<\ GetTypeName<Err>();}
\DoxyCodeLine{05341\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{05342\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ matcher\_.MatchAndExplain(err,\ listener);}
\DoxyCodeLine{05343\ \ \ \ \ \}\ \textcolor{keywordflow}{catch}\ (DefaultExceptionType\ err)\ \{}
\DoxyCodeLine{05344\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{05345\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ of\ type\ "{}}\ <<\ GetTypeName(\textcolor{keyword}{typeid}(err));}
\DoxyCodeLine{05346\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{05347\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{05348\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}throws\ an\ std::exception-\/derived\ type\ "{}};}
\DoxyCodeLine{05349\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05350\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}with\ description\ \(\backslash\)"{}"{}}\ <<\ err.what()\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}"{}};}
\DoxyCodeLine{05351\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{05352\ \ \ \ \ \}\ \textcolor{keywordflow}{catch}\ (...)\ \{}
\DoxyCodeLine{05353\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}throws\ an\ exception\ of\ an\ unknown\ type"{}};}
\DoxyCodeLine{05354\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{05355\ \ \ \ \ \}}
\DoxyCodeLine{05356\ }
\DoxyCodeLine{05357\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}does\ not\ throw\ any\ exception"{}};}
\DoxyCodeLine{05358\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{05359\ \ \ \}}
\DoxyCodeLine{05360\ }
\DoxyCodeLine{05361\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{05362\ \ \ \textcolor{keyword}{const}\ Matcher<const\ Err\&>\ matcher\_;}
\DoxyCodeLine{05363\ \};}
\DoxyCodeLine{05364\ }
\DoxyCodeLine{05365\ \}\ \ \textcolor{comment}{//\ namespace\ internal}}
\DoxyCodeLine{05366\ }
\DoxyCodeLine{05367\ \textcolor{comment}{//\ Throws()}}
\DoxyCodeLine{05368\ \textcolor{comment}{//\ Throws(exceptionMatcher)}}
\DoxyCodeLine{05369\ \textcolor{comment}{//\ ThrowsMessage(messageMatcher)}}
\DoxyCodeLine{05370\ \textcolor{comment}{//}}
\DoxyCodeLine{05371\ \textcolor{comment}{//\ This\ matcher\ accepts\ a\ callable\ and\ verifies\ that\ when\ invoked,\ it\ throws}}
\DoxyCodeLine{05372\ \textcolor{comment}{//\ an\ exception\ with\ the\ given\ type\ and\ properties.}}
\DoxyCodeLine{05373\ \textcolor{comment}{//}}
\DoxyCodeLine{05374\ \textcolor{comment}{//\ Examples:}}
\DoxyCodeLine{05375\ \textcolor{comment}{//}}
\DoxyCodeLine{05376\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(}}
\DoxyCodeLine{05377\ \textcolor{comment}{//\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error("{}message"{});\ \},}}
\DoxyCodeLine{05378\ \textcolor{comment}{//\ \ \ \ \ \ \ Throws<std::runtime\_error>());}}
\DoxyCodeLine{05379\ \textcolor{comment}{//}}
\DoxyCodeLine{05380\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(}}
\DoxyCodeLine{05381\ \textcolor{comment}{//\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error("{}message"{});\ \},}}
\DoxyCodeLine{05382\ \textcolor{comment}{//\ \ \ \ \ \ \ ThrowsMessage<std::runtime\_error>(HasSubstr("{}message"{})));}}
\DoxyCodeLine{05383\ \textcolor{comment}{//}}
\DoxyCodeLine{05384\ \textcolor{comment}{//\ \ \ EXPECT\_THAT(}}
\DoxyCodeLine{05385\ \textcolor{comment}{//\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error("{}message"{});\ \},}}
\DoxyCodeLine{05386\ \textcolor{comment}{//\ \ \ \ \ \ \ Throws<std::runtime\_error>(}}
\DoxyCodeLine{05387\ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ \ \ Property(\&std::runtime\_error::what,\ HasSubstr("{}message"{}))));}}
\DoxyCodeLine{05388\ }
\DoxyCodeLine{05389\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err>}
\DoxyCodeLine{05390\ PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>>\ Throws()\ \{}
\DoxyCodeLine{05391\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(}
\DoxyCodeLine{05392\ \ \ \ \ \ \ internal::ExceptionMatcherImpl<Err>(A<const\ Err\&>()));}
\DoxyCodeLine{05393\ \}}
\DoxyCodeLine{05394\ }
\DoxyCodeLine{05395\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err,\ \textcolor{keyword}{typename}\ ExceptionMatcher>}
\DoxyCodeLine{05396\ PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>>\ Throws(}
\DoxyCodeLine{05397\ \ \ \ \ \textcolor{keyword}{const}\ ExceptionMatcher\&\ exception\_matcher)\ \{}
\DoxyCodeLine{05398\ \ \ \textcolor{comment}{//\ Using\ matcher\ cast\ allows\ users\ to\ pass\ a\ matcher\ of\ a\ more\ broad\ type.}}
\DoxyCodeLine{05399\ \ \ \textcolor{comment}{//\ For\ example\ user\ may\ want\ to\ pass\ Matcher<std::exception>}}
\DoxyCodeLine{05400\ \ \ \textcolor{comment}{//\ to\ Throws<std::runtime\_error>,\ or\ Matcher<int64>\ to\ Throws<int32>.}}
\DoxyCodeLine{05401\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(internal::ExceptionMatcherImpl<Err>(}
\DoxyCodeLine{05402\ \ \ \ \ \ \ SafeMatcherCast<const\ Err\&>(exception\_matcher)));}
\DoxyCodeLine{05403\ \}}
\DoxyCodeLine{05404\ }
\DoxyCodeLine{05405\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Err,\ \textcolor{keyword}{typename}\ MessageMatcher>}
\DoxyCodeLine{05406\ PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>>\ ThrowsMessage(}
\DoxyCodeLine{05407\ \ \ \ \ MessageMatcher\&\&\ message\_matcher)\ \{}
\DoxyCodeLine{05408\ \ \ \textcolor{keyword}{static\_assert}(std::is\_base\_of<std::exception,\ Err>::value,}
\DoxyCodeLine{05409\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}expected\ an\ std::exception-\/derived\ type"{}});}
\DoxyCodeLine{05410\ \ \ \textcolor{keywordflow}{return}\ Throws<Err>(internal::WithWhat(}
\DoxyCodeLine{05411\ \ \ \ \ \ \ MatcherCast<std::string>(std::forward<MessageMatcher>(message\_matcher))));}
\DoxyCodeLine{05412\ \}}
\DoxyCodeLine{05413\ }
\DoxyCodeLine{05414\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{05415\ }
\DoxyCodeLine{05416\ \textcolor{comment}{//\ These\ macros\ allow\ using\ matchers\ to\ check\ values\ in\ Google\ Test}}
\DoxyCodeLine{05417\ \textcolor{comment}{//\ tests.\ \ ASSERT\_THAT(value,\ matcher)\ and\ EXPECT\_THAT(value,\ matcher)}}
\DoxyCodeLine{05418\ \textcolor{comment}{//\ succeed\ if\ and\ only\ if\ the\ value\ matches\ the\ matcher.\ \ If\ the\ assertion}}
\DoxyCodeLine{05419\ \textcolor{comment}{//\ fails,\ the\ value\ and\ the\ description\ of\ the\ matcher\ will\ be\ printed.}}
\DoxyCodeLine{05420\ \textcolor{preprocessor}{\#define\ ASSERT\_THAT(value,\ matcher)\ ASSERT\_PRED\_FORMAT1(\(\backslash\)}}
\DoxyCodeLine{05421\ \textcolor{preprocessor}{\ \ \ \ ::testing::internal::MakePredicateFormatterFromMatcher(matcher),\ value)}}
\DoxyCodeLine{05422\ \textcolor{preprocessor}{\#define\ EXPECT\_THAT(value,\ matcher)\ EXPECT\_PRED\_FORMAT1(\(\backslash\)}}
\DoxyCodeLine{05423\ \textcolor{preprocessor}{\ \ \ \ ::testing::internal::MakePredicateFormatterFromMatcher(matcher),\ value)}}
\DoxyCodeLine{05424\ }
\DoxyCodeLine{05425\ \textcolor{comment}{//\ MATCHER*\ macros\ itself\ are\ listed\ below.}}
\DoxyCodeLine{05426\ \textcolor{preprocessor}{\#define\ MATCHER(name,\ description)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05427\ \textcolor{preprocessor}{\ \ class\ name\#\#Matcher\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05428\ \textcolor{preprocessor}{\ \ \ \ \ \ :\ public\ ::testing::internal::MatcherBaseImpl<name\#\#Matcher>\ \{\ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05429\ \textcolor{preprocessor}{\ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05430\ \textcolor{preprocessor}{\ \ \ \ template\ <typename\ arg\_type>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05431\ \textcolor{preprocessor}{\ \ \ \ class\ gmock\_Impl\ :\ public\ ::testing::MatcherInterface<const\ arg\_type\&>\ \{\ \ \ \(\backslash\)}}
\DoxyCodeLine{05432\ \textcolor{preprocessor}{\ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05433\ \textcolor{preprocessor}{\ \ \ \ \ \ gmock\_Impl()\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05434\ \textcolor{preprocessor}{\ \ \ \ \ \ bool\ MatchAndExplain(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05435\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ const\ arg\_type\&\ arg,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05436\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ result\_listener)\ const\ override;\ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05437\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ DescribeTo(::std::ostream*\ gmock\_os)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05438\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ *gmock\_os\ <<\ FormatDescription(false);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05439\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05440\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ DescribeNegationTo(::std::ostream*\ gmock\_os)\ const\ override\ \{\ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05441\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ *gmock\_os\ <<\ FormatDescription(true);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05442\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05443\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05444\ \textcolor{preprocessor}{\ \ \ \ \ private:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05445\ \textcolor{preprocessor}{\ \ \ \ \ \ ::std::string\ FormatDescription(bool\ negation)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05446\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ }\textcolor{comment}{/*\ NOLINTNEXTLINE\ readability-\/redundant-\/string-\/init\ */}\textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05447\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ ::std::string\ gmock\_description\ =\ (description);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05448\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ if\ (!gmock\_description.empty())\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05449\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ return\ gmock\_description;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05450\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05451\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ return\ ::testing::internal::FormatMatcherDescription(negation,\ \#name,\ \ \(\backslash\)}}
\DoxyCodeLine{05452\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\});\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05453\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05454\ \textcolor{preprocessor}{\ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05455\ \textcolor{preprocessor}{\ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05456\ \textcolor{preprocessor}{\ \ GTEST\_ATTRIBUTE\_UNUSED\_\ inline\ name\#\#Matcher\ name()\ \{\ return\ \{\};\ \}\ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05457\ \textcolor{preprocessor}{\ \ template\ <typename\ arg\_type>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05458\ \textcolor{preprocessor}{\ \ bool\ name\#\#Matcher::gmock\_Impl<arg\_type>::MatchAndExplain(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05459\ \textcolor{preprocessor}{\ \ \ \ \ \ const\ arg\_type\&\ arg,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05460\ \textcolor{preprocessor}{\ \ \ \ \ \ ::testing::MatchResultListener*\ result\_listener\ GTEST\_ATTRIBUTE\_UNUSED\_)\ \(\backslash\)}}
\DoxyCodeLine{05461\ \textcolor{preprocessor}{\ \ \ \ \ \ const}}
\DoxyCodeLine{05462\ }
\DoxyCodeLine{05463\ \textcolor{preprocessor}{\#define\ MATCHER\_P(name,\ p0,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05464\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP,\ description,\ (p0))}}
\DoxyCodeLine{05465\ \textcolor{preprocessor}{\#define\ MATCHER\_P2(name,\ p0,\ p1,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05466\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP2,\ description,\ (p0,\ p1))}}
\DoxyCodeLine{05467\ \textcolor{preprocessor}{\#define\ MATCHER\_P3(name,\ p0,\ p1,\ p2,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05468\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP3,\ description,\ (p0,\ p1,\ p2))}}
\DoxyCodeLine{05469\ \textcolor{preprocessor}{\#define\ MATCHER\_P4(name,\ p0,\ p1,\ p2,\ p3,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05470\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP4,\ description,\ (p0,\ p1,\ p2,\ p3))}}
\DoxyCodeLine{05471\ \textcolor{preprocessor}{\#define\ MATCHER\_P5(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ description)\ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05472\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP5,\ description,\ \(\backslash\)}}
\DoxyCodeLine{05473\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4))}}
\DoxyCodeLine{05474\ \textcolor{preprocessor}{\#define\ MATCHER\_P6(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05475\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP6,\ description,\ \ \(\backslash\)}}
\DoxyCodeLine{05476\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5))}}
\DoxyCodeLine{05477\ \textcolor{preprocessor}{\#define\ MATCHER\_P7(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05478\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP7,\ description,\ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05479\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6))}}
\DoxyCodeLine{05480\ \textcolor{preprocessor}{\#define\ MATCHER\_P8(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05481\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP8,\ description,\ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05482\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7))}}
\DoxyCodeLine{05483\ \textcolor{preprocessor}{\#define\ MATCHER\_P9(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ p8,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05484\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP9,\ description,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05485\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ p8))}}
\DoxyCodeLine{05486\ \textcolor{preprocessor}{\#define\ MATCHER\_P10(name,\ p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ p8,\ p9,\ description)\ \(\backslash\)}}
\DoxyCodeLine{05487\ \textcolor{preprocessor}{\ \ GMOCK\_INTERNAL\_MATCHER(name,\ name\#\#MatcherP10,\ description,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05488\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (p0,\ p1,\ p2,\ p3,\ p4,\ p5,\ p6,\ p7,\ p8,\ p9))}}
\DoxyCodeLine{05489\ }
\DoxyCodeLine{05490\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER(name,\ full\_name,\ description,\ args)\ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05491\ \textcolor{preprocessor}{\ \ template\ <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05492\ \textcolor{preprocessor}{\ \ class\ full\_name\ :\ public\ ::testing::internal::MatcherBaseImpl<\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05493\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>>\ \{\ \(\backslash\)}}
\DoxyCodeLine{05494\ \textcolor{preprocessor}{\ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05495\ \textcolor{preprocessor}{\ \ \ \ using\ full\_name::MatcherBaseImpl::MatcherBaseImpl;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05496\ \textcolor{preprocessor}{\ \ \ \ template\ <typename\ arg\_type>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05497\ \textcolor{preprocessor}{\ \ \ \ class\ gmock\_Impl\ :\ public\ ::testing::MatcherInterface<const\ arg\_type\&>\ \{\ \ \ \(\backslash\)}}
\DoxyCodeLine{05498\ \textcolor{preprocessor}{\ \ \ \ \ public:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05499\ \textcolor{preprocessor}{\ \ \ \ \ \ explicit\ gmock\_Impl(GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args))\ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05500\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ :\ GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARGS(args)\ \{\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05501\ \textcolor{preprocessor}{\ \ \ \ \ \ bool\ MatchAndExplain(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05502\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ const\ arg\_type\&\ arg,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05503\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ result\_listener)\ const\ override;\ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05504\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ DescribeTo(::std::ostream*\ gmock\_os)\ const\ override\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05505\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ *gmock\_os\ <<\ FormatDescription(false);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05506\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05507\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ DescribeNegationTo(::std::ostream*\ gmock\_os)\ const\ override\ \{\ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05508\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ *gmock\_os\ <<\ FormatDescription(true);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05509\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05510\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_MEMBERS(args)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05511\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05512\ \textcolor{preprocessor}{\ \ \ \ \ private:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05513\ \textcolor{preprocessor}{\ \ \ \ \ \ ::std::string\ FormatDescription(bool\ negation)\ const\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05514\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ ::std::string\ gmock\_description\ =\ (description);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05515\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ if\ (!gmock\_description.empty())\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05516\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ return\ gmock\_description;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05517\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05518\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ return\ ::testing::internal::FormatMatcherDescription(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05519\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ negation,\ \#name,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05520\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05521\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::std::tuple<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>(\ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05522\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_MEMBERS\_USAGE(args))));\ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05523\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05524\ \textcolor{preprocessor}{\ \ \ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05525\ \textcolor{preprocessor}{\ \ \};\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05526\ \textcolor{preprocessor}{\ \ template\ <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05527\ \textcolor{preprocessor}{\ \ inline\ full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>\ name(\ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05528\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args))\ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05529\ \textcolor{preprocessor}{\ \ \ \ return\ full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05530\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_ARGS\_USAGE(args));\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05531\ \textcolor{preprocessor}{\ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05532\ \textcolor{preprocessor}{\ \ template\ <GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05533\ \textcolor{preprocessor}{\ \ template\ <typename\ arg\_type>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05534\ \textcolor{preprocessor}{\ \ bool\ full\_name<GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)>::gmock\_Impl<\ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05535\ \textcolor{preprocessor}{\ \ \ \ \ \ arg\_type>::MatchAndExplain(const\ arg\_type\&\ arg,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05536\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::testing::MatchResultListener*\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05537\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ result\_listener\ GTEST\_ATTRIBUTE\_UNUSED\_)\ \ \(\backslash\)}}
\DoxyCodeLine{05538\ \textcolor{preprocessor}{\ \ \ \ \ \ const}}
\DoxyCodeLine{05539\ }
\DoxyCodeLine{05540\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAMS(args)\ \(\backslash\)}}
\DoxyCodeLine{05541\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05542\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAM,\ ,\ args))}}
\DoxyCodeLine{05543\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_TEMPLATE\_PARAM(i\_unused,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05544\ \textcolor{preprocessor}{\ \ ,\ typename\ arg\#\#\_type}}
\DoxyCodeLine{05545\ }
\DoxyCodeLine{05546\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAMS(args)\ \(\backslash\)}}
\DoxyCodeLine{05547\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAM,\ ,\ args))}}
\DoxyCodeLine{05548\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_TYPE\_PARAM(i\_unused,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05549\ \textcolor{preprocessor}{\ \ ,\ arg\#\#\_type}}
\DoxyCodeLine{05550\ }
\DoxyCodeLine{05551\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARGS(args)\ \(\backslash\)}}
\DoxyCodeLine{05552\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(dummy\_first\ GMOCK\_PP\_FOR\_EACH(\ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{05553\ \textcolor{preprocessor}{\ \ \ \ \ \ GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARG,\ ,\ args))}}
\DoxyCodeLine{05554\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_FUNCTION\_ARG(i,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05555\ \textcolor{preprocessor}{\ \ ,\ arg\#\#\_type\ gmock\_p\#\#i}}
\DoxyCodeLine{05556\ }
\DoxyCodeLine{05557\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARGS(args)\ \(\backslash\)}}
\DoxyCodeLine{05558\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARG,\ ,\ args))}}
\DoxyCodeLine{05559\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_FORWARD\_ARG(i,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05560\ \textcolor{preprocessor}{\ \ ,\ arg(::std::forward<arg\#\#\_type>(gmock\_p\#\#i))}}
\DoxyCodeLine{05561\ }
\DoxyCodeLine{05562\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_MEMBERS(args)\ \(\backslash\)}}
\DoxyCodeLine{05563\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_MEMBER,\ ,\ args)}}
\DoxyCodeLine{05564\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_MEMBER(i\_unused,\ data\_unused,\ arg)\ \(\backslash\)}}
\DoxyCodeLine{05565\ \textcolor{preprocessor}{\ \ const\ arg\#\#\_type\ arg;}}
\DoxyCodeLine{05566\ }
\DoxyCodeLine{05567\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_MEMBERS\_USAGE(args)\ \(\backslash\)}}
\DoxyCodeLine{05568\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_MEMBER\_USAGE,\ ,\ args))}}
\DoxyCodeLine{05569\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_MEMBER\_USAGE(i\_unused,\ data\_unused,\ arg)\ ,\ arg}}
\DoxyCodeLine{05570\ }
\DoxyCodeLine{05571\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_ARGS\_USAGE(args)\ \(\backslash\)}}
\DoxyCodeLine{05572\ \textcolor{preprocessor}{\ \ GMOCK\_PP\_TAIL(GMOCK\_PP\_FOR\_EACH(GMOCK\_INTERNAL\_MATCHER\_ARG\_USAGE,\ ,\ args))}}
\DoxyCodeLine{05573\ \textcolor{preprocessor}{\#define\ GMOCK\_INTERNAL\_MATCHER\_ARG\_USAGE(i,\ data\_unused,\ arg\_unused)\ \(\backslash\)}}
\DoxyCodeLine{05574\ \textcolor{preprocessor}{\ \ ,\ gmock\_p\#\#i}}
\DoxyCodeLine{05575\ }
\DoxyCodeLine{05576\ \textcolor{comment}{//\ To\ prevent\ ADL\ on\ certain\ functions\ we\ put\ them\ on\ a\ separate\ namespace.}}
\DoxyCodeLine{05577\ \textcolor{keyword}{using\ namespace\ }no\_adl;\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{05578\ }
\DoxyCodeLine{05579\ \}\ \ \textcolor{comment}{//\ namespace\ testing}}
\DoxyCodeLine{05580\ }
\DoxyCodeLine{05581\ GTEST\_DISABLE\_MSC\_WARNINGS\_POP\_()\ \ \textcolor{comment}{//\ \ 4251\ 5046}}
\DoxyCodeLine{05582\ }
\DoxyCodeLine{05583\ \textcolor{comment}{//\ Include\ any\ custom\ callback\ matchers\ added\ by\ the\ local\ installation.}}
\DoxyCodeLine{05584\ \textcolor{comment}{//\ We\ must\ include\ this\ header\ at\ the\ end\ to\ make\ sure\ it\ can\ use\ the}}
\DoxyCodeLine{05585\ \textcolor{comment}{//\ declarations\ from\ this\ file.}}
\DoxyCodeLine{05586\ \textcolor{preprocessor}{\#include\ "{}gmock/internal/custom/gmock-\/matchers.h"{}}}
\DoxyCodeLine{05587\ }
\DoxyCodeLine{05588\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GOOGLEMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}

\end{DoxyCode}
