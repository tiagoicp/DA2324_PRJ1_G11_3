\doxysection{gmock-\/matchers\+\_\+test.cc}
\hypertarget{gmock-matchers__test_8cc_source}{}\label{gmock-matchers__test_8cc_source}\index{lib/googletest-\/master/googlemock/test/gmock-\/matchers\_test.cc@{lib/googletest-\/master/googlemock/test/gmock-\/matchers\_test.cc}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{//\ Copyright\ 2007,\ Google\ Inc.}}
\DoxyCodeLine{00002\ \textcolor{comment}{//\ All\ rights\ reserved.}}
\DoxyCodeLine{00003\ \textcolor{comment}{//}}
\DoxyCodeLine{00004\ \textcolor{comment}{//\ Redistribution\ and\ use\ in\ source\ and\ binary\ forms,\ with\ or\ without}}
\DoxyCodeLine{00005\ \textcolor{comment}{//\ modification,\ are\ permitted\ provided\ that\ the\ following\ conditions\ are}}
\DoxyCodeLine{00006\ \textcolor{comment}{//\ met:}}
\DoxyCodeLine{00007\ \textcolor{comment}{//}}
\DoxyCodeLine{00008\ \textcolor{comment}{//\ \ \ \ \ *\ Redistributions\ of\ source\ code\ must\ retain\ the\ above\ copyright}}
\DoxyCodeLine{00009\ \textcolor{comment}{//\ notice,\ this\ list\ of\ conditions\ and\ the\ following\ disclaimer.}}
\DoxyCodeLine{00010\ \textcolor{comment}{//\ \ \ \ \ *\ Redistributions\ in\ binary\ form\ must\ reproduce\ the\ above}}
\DoxyCodeLine{00011\ \textcolor{comment}{//\ copyright\ notice,\ this\ list\ of\ conditions\ and\ the\ following\ disclaimer}}
\DoxyCodeLine{00012\ \textcolor{comment}{//\ in\ the\ documentation\ and/or\ other\ materials\ provided\ with\ the}}
\DoxyCodeLine{00013\ \textcolor{comment}{//\ distribution.}}
\DoxyCodeLine{00014\ \textcolor{comment}{//\ \ \ \ \ *\ Neither\ the\ name\ of\ Google\ Inc.\ nor\ the\ names\ of\ its}}
\DoxyCodeLine{00015\ \textcolor{comment}{//\ contributors\ may\ be\ used\ to\ endorse\ or\ promote\ products\ derived\ from}}
\DoxyCodeLine{00016\ \textcolor{comment}{//\ this\ software\ without\ specific\ prior\ written\ permission.}}
\DoxyCodeLine{00017\ \textcolor{comment}{//}}
\DoxyCodeLine{00018\ \textcolor{comment}{//\ THIS\ SOFTWARE\ IS\ PROVIDED\ BY\ THE\ COPYRIGHT\ HOLDERS\ AND\ CONTRIBUTORS}}
\DoxyCodeLine{00019\ \textcolor{comment}{//\ "{}AS\ IS"{}\ AND\ ANY\ EXPRESS\ OR\ IMPLIED\ WARRANTIES,\ INCLUDING,\ BUT\ NOT}}
\DoxyCodeLine{00020\ \textcolor{comment}{//\ LIMITED\ TO,\ THE\ IMPLIED\ WARRANTIES\ OF\ MERCHANTABILITY\ AND\ FITNESS\ FOR}}
\DoxyCodeLine{00021\ \textcolor{comment}{//\ A\ PARTICULAR\ PURPOSE\ ARE\ DISCLAIMED.\ IN\ NO\ EVENT\ SHALL\ THE\ COPYRIGHT}}
\DoxyCodeLine{00022\ \textcolor{comment}{//\ OWNER\ OR\ CONTRIBUTORS\ BE\ LIABLE\ FOR\ ANY\ DIRECT,\ INDIRECT,\ INCIDENTAL,}}
\DoxyCodeLine{00023\ \textcolor{comment}{//\ SPECIAL,\ EXEMPLARY,\ OR\ CONSEQUENTIAL\ DAMAGES\ (INCLUDING,\ BUT\ NOT}}
\DoxyCodeLine{00024\ \textcolor{comment}{//\ LIMITED\ TO,\ PROCUREMENT\ OF\ SUBSTITUTE\ GOODS\ OR\ SERVICES;\ LOSS\ OF\ USE,}}
\DoxyCodeLine{00025\ \textcolor{comment}{//\ DATA,\ OR\ PROFITS;\ OR\ BUSINESS\ INTERRUPTION)\ HOWEVER\ CAUSED\ AND\ ON\ ANY}}
\DoxyCodeLine{00026\ \textcolor{comment}{//\ THEORY\ OF\ LIABILITY,\ WHETHER\ IN\ CONTRACT,\ STRICT\ LIABILITY,\ OR\ TORT}}
\DoxyCodeLine{00027\ \textcolor{comment}{//\ (INCLUDING\ NEGLIGENCE\ OR\ OTHERWISE)\ ARISING\ IN\ ANY\ WAY\ OUT\ OF\ THE\ USE}}
\DoxyCodeLine{00028\ \textcolor{comment}{//\ OF\ THIS\ SOFTWARE,\ EVEN\ IF\ ADVISED\ OF\ THE\ POSSIBILITY\ OF\ SUCH\ DAMAGE.}}
\DoxyCodeLine{00029\ }
\DoxyCodeLine{00030\ }
\DoxyCodeLine{00031\ \textcolor{comment}{//\ Google\ Mock\ -\/\ a\ framework\ for\ writing\ C++\ mock\ classes.}}
\DoxyCodeLine{00032\ \textcolor{comment}{//}}
\DoxyCodeLine{00033\ \textcolor{comment}{//\ This\ file\ tests\ some\ commonly\ used\ argument\ matchers.}}
\DoxyCodeLine{00034\ }
\DoxyCodeLine{00035\ \textcolor{comment}{//\ Silence\ warning\ C4244:\ 'initializing':\ conversion\ from\ 'int'\ to\ 'short',}}
\DoxyCodeLine{00036\ \textcolor{comment}{//\ possible\ loss\ of\ data\ and\ C4100,\ unreferenced\ local\ parameter}}
\DoxyCodeLine{00037\ \textcolor{preprocessor}{\#ifdef\ \_MSC\_VER}}
\DoxyCodeLine{00038\ \textcolor{preprocessor}{\#\ pragma\ warning(push)}}
\DoxyCodeLine{00039\ \textcolor{preprocessor}{\#\ pragma\ warning(disable:4244)}}
\DoxyCodeLine{00040\ \textcolor{preprocessor}{\#\ pragma\ warning(disable:4100)}}
\DoxyCodeLine{00041\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00042\ }
\DoxyCodeLine{00043\ \textcolor{preprocessor}{\#include\ "{}gmock/gmock-\/matchers.h"{}}}
\DoxyCodeLine{00044\ }
\DoxyCodeLine{00045\ \textcolor{preprocessor}{\#include\ <string.h>}}
\DoxyCodeLine{00046\ \textcolor{preprocessor}{\#include\ <time.h>}}
\DoxyCodeLine{00047\ }
\DoxyCodeLine{00048\ \textcolor{preprocessor}{\#include\ <array>}}
\DoxyCodeLine{00049\ \textcolor{preprocessor}{\#include\ <cstdint>}}
\DoxyCodeLine{00050\ \textcolor{preprocessor}{\#include\ <deque>}}
\DoxyCodeLine{00051\ \textcolor{preprocessor}{\#include\ <forward\_list>}}
\DoxyCodeLine{00052\ \textcolor{preprocessor}{\#include\ <functional>}}
\DoxyCodeLine{00053\ \textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{00054\ \textcolor{preprocessor}{\#include\ <iterator>}}
\DoxyCodeLine{00055\ \textcolor{preprocessor}{\#include\ <limits>}}
\DoxyCodeLine{00056\ \textcolor{preprocessor}{\#include\ <list>}}
\DoxyCodeLine{00057\ \textcolor{preprocessor}{\#include\ <map>}}
\DoxyCodeLine{00058\ \textcolor{preprocessor}{\#include\ <memory>}}
\DoxyCodeLine{00059\ \textcolor{preprocessor}{\#include\ <set>}}
\DoxyCodeLine{00060\ \textcolor{preprocessor}{\#include\ <sstream>}}
\DoxyCodeLine{00061\ \textcolor{preprocessor}{\#include\ <string>}}
\DoxyCodeLine{00062\ \textcolor{preprocessor}{\#include\ <type\_traits>}}
\DoxyCodeLine{00063\ \textcolor{preprocessor}{\#include\ <unordered\_map>}}
\DoxyCodeLine{00064\ \textcolor{preprocessor}{\#include\ <unordered\_set>}}
\DoxyCodeLine{00065\ \textcolor{preprocessor}{\#include\ <utility>}}
\DoxyCodeLine{00066\ \textcolor{preprocessor}{\#include\ <vector>}}
\DoxyCodeLine{00067\ }
\DoxyCodeLine{00068\ \textcolor{preprocessor}{\#include\ "{}gmock/gmock-\/more-\/matchers.h"{}}}
\DoxyCodeLine{00069\ \textcolor{preprocessor}{\#include\ "{}gmock/gmock.h"{}}}
\DoxyCodeLine{00070\ \textcolor{preprocessor}{\#include\ "{}gtest/gtest-\/spi.h"{}}}
\DoxyCodeLine{00071\ \textcolor{preprocessor}{\#include\ "{}gtest/gtest.h"{}}}
\DoxyCodeLine{00072\ }
\DoxyCodeLine{00073\ \textcolor{keyword}{namespace\ }testing\ \{}
\DoxyCodeLine{00074\ \textcolor{keyword}{namespace\ }gmock\_matchers\_test\ \{}
\DoxyCodeLine{00075\ \textcolor{keyword}{namespace\ }\{}
\DoxyCodeLine{00076\ }
\DoxyCodeLine{00077\ \textcolor{keyword}{using\ }std::greater;}
\DoxyCodeLine{00078\ \textcolor{keyword}{using\ }std::less;}
\DoxyCodeLine{00079\ \textcolor{keyword}{using\ }std::list;}
\DoxyCodeLine{00080\ \textcolor{keyword}{using\ }std::make\_pair;}
\DoxyCodeLine{00081\ \textcolor{keyword}{using\ }std::map;}
\DoxyCodeLine{00082\ \textcolor{keyword}{using\ }std::multimap;}
\DoxyCodeLine{00083\ \textcolor{keyword}{using\ }std::multiset;}
\DoxyCodeLine{00084\ \textcolor{keyword}{using\ }std::ostream;}
\DoxyCodeLine{00085\ \textcolor{keyword}{using\ }std::pair;}
\DoxyCodeLine{00086\ \textcolor{keyword}{using\ }std::set;}
\DoxyCodeLine{00087\ \textcolor{keyword}{using\ }std::stringstream;}
\DoxyCodeLine{00088\ \textcolor{keyword}{using\ }std::vector;}
\DoxyCodeLine{00089\ \textcolor{keyword}{using\ }testing::internal::DummyMatchResultListener;}
\DoxyCodeLine{00090\ \textcolor{keyword}{using\ }testing::internal::ElementMatcherPair;}
\DoxyCodeLine{00091\ \textcolor{keyword}{using\ }testing::internal::ElementMatcherPairs;}
\DoxyCodeLine{00092\ \textcolor{keyword}{using\ }testing::internal::ElementsAreArrayMatcher;}
\DoxyCodeLine{00093\ \textcolor{keyword}{using\ }testing::internal::ExplainMatchFailureTupleTo;}
\DoxyCodeLine{00094\ \textcolor{keyword}{using\ }testing::internal::FloatingEqMatcher;}
\DoxyCodeLine{00095\ \textcolor{keyword}{using\ }testing::internal::FormatMatcherDescription;}
\DoxyCodeLine{00096\ \textcolor{keyword}{using\ }testing::internal::IsReadableTypeName;}
\DoxyCodeLine{00097\ \textcolor{keyword}{using\ }testing::internal::MatchMatrix;}
\DoxyCodeLine{00098\ \textcolor{keyword}{using\ }testing::internal::PredicateFormatterFromMatcher;}
\DoxyCodeLine{00099\ \textcolor{keyword}{using\ }\mbox{\hyperlink{classtesting_1_1internal_1_1_r_e}{testing::internal::RE}};}
\DoxyCodeLine{00100\ \textcolor{keyword}{using\ }testing::internal::StreamMatchResultListener;}
\DoxyCodeLine{00101\ \textcolor{keyword}{using\ }testing::internal::Strings;}
\DoxyCodeLine{00102\ }
\DoxyCodeLine{00103\ \textcolor{comment}{//\ Helper\ for\ testing\ container-\/valued\ matchers\ in\ mock\ method\ context.\ It\ is}}
\DoxyCodeLine{00104\ \textcolor{comment}{//\ important\ to\ test\ matchers\ in\ this\ context,\ since\ it\ requires\ additional\ type}}
\DoxyCodeLine{00105\ \textcolor{comment}{//\ deduction\ beyond\ what\ EXPECT\_THAT\ does,\ thus\ making\ it\ more\ restrictive.}}
\DoxyCodeLine{00106\ \textcolor{keyword}{struct\ }ContainerHelper\ \{}
\DoxyCodeLine{00107\ \ \ MOCK\_METHOD1(Call,\ \textcolor{keywordtype}{void}(std::vector<std::unique\_ptr<int>>));}
\DoxyCodeLine{00108\ \};}
\DoxyCodeLine{00109\ }
\DoxyCodeLine{00110\ std::vector<std::unique\_ptr<int>>\ MakeUniquePtrs(\textcolor{keyword}{const}\ std::vector<int>\&\ ints)\ \{}
\DoxyCodeLine{00111\ \ \ std::vector<std::unique\_ptr<int>>\ pointers;}
\DoxyCodeLine{00112\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ :\ ints)\ pointers.emplace\_back(new\ int(i));}
\DoxyCodeLine{00113\ \ \ \textcolor{keywordflow}{return}\ pointers;}
\DoxyCodeLine{00114\ \}}
\DoxyCodeLine{00115\ }
\DoxyCodeLine{00116\ \textcolor{comment}{//\ For\ testing\ ExplainMatchResultTo().}}
\DoxyCodeLine{00117\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ \textcolor{keywordtype}{int}>}
\DoxyCodeLine{00118\ \textcolor{keyword}{class\ }GreaterThanMatcher\ :\ \textcolor{keyword}{public}\ MatcherInterface<T>\ \{}
\DoxyCodeLine{00119\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00120\ \ \ \textcolor{keyword}{explicit}\ GreaterThanMatcher(T\ rhs)\ :\ rhs\_(rhs)\ \{\}}
\DoxyCodeLine{00121\ }
\DoxyCodeLine{00122\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ >\ "{}}\ <<\ rhs\_;\ \}}
\DoxyCodeLine{00123\ }
\DoxyCodeLine{00124\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(T\ lhs,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00125\ \ \ \ \ \textcolor{keywordflow}{if}\ (lhs\ >\ rhs\_)\ \{}
\DoxyCodeLine{00126\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ "{}}\ <<\ (lhs\ -\/\ rhs\_)\ <<\ \textcolor{stringliteral}{"{}\ more\ than\ "{}}\ <<\ rhs\_;}
\DoxyCodeLine{00127\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (lhs\ ==\ rhs\_)\ \{}
\DoxyCodeLine{00128\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ the\ same\ as\ "{}}\ <<\ rhs\_;}
\DoxyCodeLine{00129\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00130\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ "{}}\ <<\ (rhs\_\ -\/\ lhs)\ <<\ \textcolor{stringliteral}{"{}\ less\ than\ "{}}\ <<\ rhs\_;}
\DoxyCodeLine{00131\ \ \ \ \ \}}
\DoxyCodeLine{00132\ }
\DoxyCodeLine{00133\ \ \ \ \ \textcolor{keywordflow}{return}\ lhs\ >\ rhs\_;}
\DoxyCodeLine{00134\ \ \ \}}
\DoxyCodeLine{00135\ }
\DoxyCodeLine{00136\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00137\ \ \ \textcolor{keyword}{const}\ T\ rhs\_;}
\DoxyCodeLine{00138\ \};}
\DoxyCodeLine{00139\ }
\DoxyCodeLine{00140\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00141\ Matcher<T>\ GreaterThan(T\ n)\ \{}
\DoxyCodeLine{00142\ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ GreaterThanMatcher<T>(n));}
\DoxyCodeLine{00143\ \}}
\DoxyCodeLine{00144\ }
\DoxyCodeLine{00145\ std::string\ OfType(\textcolor{keyword}{const}\ std::string\&\ type\_name)\ \{}
\DoxyCodeLine{00146\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{00147\ \ \ \textcolor{keywordflow}{return}\ IsReadableTypeName(type\_name)\ ?\ \textcolor{stringliteral}{"{}\ (of\ type\ "{}}\ +\ type\_name\ +\ \textcolor{stringliteral}{"{})"{}}\ :\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{00148\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00149\ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{00150\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00151\ \}}
\DoxyCodeLine{00152\ }
\DoxyCodeLine{00153\ \textcolor{comment}{//\ Returns\ the\ description\ of\ the\ given\ matcher.}}
\DoxyCodeLine{00154\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00155\ std::string\ Describe(\textcolor{keyword}{const}\ Matcher<T>\&\ m)\ \{}
\DoxyCodeLine{00156\ \ \ \textcolor{keywordflow}{return}\ DescribeMatcher<T>(m);}
\DoxyCodeLine{00157\ \}}
\DoxyCodeLine{00158\ }
\DoxyCodeLine{00159\ \textcolor{comment}{//\ Returns\ the\ description\ of\ the\ negation\ of\ the\ given\ matcher.}}
\DoxyCodeLine{00160\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00161\ std::string\ DescribeNegation(\textcolor{keyword}{const}\ Matcher<T>\&\ m)\ \{}
\DoxyCodeLine{00162\ \ \ \textcolor{keywordflow}{return}\ DescribeMatcher<T>(m,\ \textcolor{keyword}{true});}
\DoxyCodeLine{00163\ \}}
\DoxyCodeLine{00164\ }
\DoxyCodeLine{00165\ \textcolor{comment}{//\ Returns\ the\ reason\ why\ x\ matches,\ or\ doesn't\ match,\ m.}}
\DoxyCodeLine{00166\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ MatcherType,\ \textcolor{keyword}{typename}\ Value>}
\DoxyCodeLine{00167\ std::string\ Explain(\textcolor{keyword}{const}\ MatcherType\&\ m,\ \textcolor{keyword}{const}\ Value\&\ x)\ \{}
\DoxyCodeLine{00168\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{00169\ \ \ ExplainMatchResult(m,\ x,\ \&listener);}
\DoxyCodeLine{00170\ \ \ \textcolor{keywordflow}{return}\ listener.str();}
\DoxyCodeLine{00171\ \}}
\DoxyCodeLine{00172\ }
\DoxyCodeLine{00173\ TEST(MonotonicMatcherTest,\ IsPrintable)\ \{}
\DoxyCodeLine{00174\ \ \ stringstream\ ss;}
\DoxyCodeLine{00175\ \ \ ss\ <<\ GreaterThan(5);}
\DoxyCodeLine{00176\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ >\ 5"{}},\ ss.str());}
\DoxyCodeLine{00177\ \}}
\DoxyCodeLine{00178\ }
\DoxyCodeLine{00179\ TEST(MatchResultListenerTest,\ StreamingWorks)\ \{}
\DoxyCodeLine{00180\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{00181\ \ \ listener\ <<\ \textcolor{stringliteral}{"{}hi"{}}\ <<\ 5;}
\DoxyCodeLine{00182\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}hi5"{}},\ listener.str());}
\DoxyCodeLine{00183\ }
\DoxyCodeLine{00184\ \ \ listener.Clear();}
\DoxyCodeLine{00185\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ listener.str());}
\DoxyCodeLine{00186\ }
\DoxyCodeLine{00187\ \ \ listener\ <<\ 42;}
\DoxyCodeLine{00188\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}42"{}},\ listener.str());}
\DoxyCodeLine{00189\ }
\DoxyCodeLine{00190\ \ \ \textcolor{comment}{//\ Streaming\ shouldn't\ crash\ when\ the\ underlying\ ostream\ is\ NULL.}}
\DoxyCodeLine{00191\ \ \ DummyMatchResultListener\ dummy;}
\DoxyCodeLine{00192\ \ \ dummy\ <<\ \textcolor{stringliteral}{"{}hi"{}}\ <<\ 5;}
\DoxyCodeLine{00193\ \}}
\DoxyCodeLine{00194\ }
\DoxyCodeLine{00195\ TEST(MatchResultListenerTest,\ CanAccessUnderlyingStream)\ \{}
\DoxyCodeLine{00196\ \ \ EXPECT\_TRUE(DummyMatchResultListener().stream()\ ==\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00197\ \ \ EXPECT\_TRUE(StreamMatchResultListener(\textcolor{keyword}{nullptr}).stream()\ ==\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00198\ }
\DoxyCodeLine{00199\ \ \ EXPECT\_EQ(\&std::cout,\ StreamMatchResultListener(\&std::cout).stream());}
\DoxyCodeLine{00200\ \}}
\DoxyCodeLine{00201\ }
\DoxyCodeLine{00202\ TEST(MatchResultListenerTest,\ IsInterestedWorks)\ \{}
\DoxyCodeLine{00203\ \ \ EXPECT\_TRUE(StringMatchResultListener().IsInterested());}
\DoxyCodeLine{00204\ \ \ EXPECT\_TRUE(StreamMatchResultListener(\&std::cout).IsInterested());}
\DoxyCodeLine{00205\ }
\DoxyCodeLine{00206\ \ \ EXPECT\_FALSE(DummyMatchResultListener().IsInterested());}
\DoxyCodeLine{00207\ \ \ EXPECT\_FALSE(StreamMatchResultListener(\textcolor{keyword}{nullptr}).IsInterested());}
\DoxyCodeLine{00208\ \}}
\DoxyCodeLine{00209\ }
\DoxyCodeLine{00210\ \textcolor{comment}{//\ Makes\ sure\ that\ the\ MatcherInterface<T>\ interface\ doesn't}}
\DoxyCodeLine{00211\ \textcolor{comment}{//\ change.}}
\DoxyCodeLine{00212\ \textcolor{keyword}{class\ }EvenMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<int>\ \{}
\DoxyCodeLine{00213\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00214\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keywordtype}{int}\ x,}
\DoxyCodeLine{00215\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00216\ \ \ \ \ \textcolor{keywordflow}{return}\ x\ \%\ 2\ ==\ 0;}
\DoxyCodeLine{00217\ \ \ \}}
\DoxyCodeLine{00218\ }
\DoxyCodeLine{00219\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ even\ number"{}};\ \}}
\DoxyCodeLine{00220\ }
\DoxyCodeLine{00221\ \ \ \textcolor{comment}{//\ We\ deliberately\ don't\ define\ DescribeNegationTo()\ and}}
\DoxyCodeLine{00222\ \ \ \textcolor{comment}{//\ ExplainMatchResultTo()\ here,\ to\ make\ sure\ the\ definition\ of\ these}}
\DoxyCodeLine{00223\ \ \ \textcolor{comment}{//\ two\ methods\ is\ optional.}}
\DoxyCodeLine{00224\ \};}
\DoxyCodeLine{00225\ }
\DoxyCodeLine{00226\ \textcolor{comment}{//\ Makes\ sure\ that\ the\ MatcherInterface\ API\ doesn't\ change.}}
\DoxyCodeLine{00227\ TEST(MatcherInterfaceTest,\ CanBeImplementedUsingPublishedAPI)\ \{}
\DoxyCodeLine{00228\ \ \ EvenMatcherImpl\ m;}
\DoxyCodeLine{00229\ \}}
\DoxyCodeLine{00230\ }
\DoxyCodeLine{00231\ \textcolor{comment}{//\ Tests\ implementing\ a\ monomorphic\ matcher\ using\ MatchAndExplain().}}
\DoxyCodeLine{00232\ }
\DoxyCodeLine{00233\ \textcolor{keyword}{class\ }NewEvenMatcherImpl\ :\ \textcolor{keyword}{public}\ MatcherInterface<int>\ \{}
\DoxyCodeLine{00234\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00235\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keywordtype}{int}\ x,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{00236\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ match\ =\ x\ \%\ 2\ ==\ 0;}
\DoxyCodeLine{00237\ \ \ \ \ \textcolor{comment}{//\ Verifies\ that\ we\ can\ stream\ to\ a\ listener\ directly.}}
\DoxyCodeLine{00238\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}value\ \%\ "{}}\ <<\ 2;}
\DoxyCodeLine{00239\ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>stream()\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00240\ \ \ \ \ \ \ \textcolor{comment}{//\ Verifies\ that\ we\ can\ stream\ to\ a\ listener's\ underlying\ stream}}
\DoxyCodeLine{00241\ \ \ \ \ \ \ \textcolor{comment}{//\ too.}}
\DoxyCodeLine{00242\ \ \ \ \ \ \ *listener-\/>stream()\ <<\ \textcolor{stringliteral}{"{}\ ==\ "{}}\ <<\ (x\ \%\ 2);}
\DoxyCodeLine{00243\ \ \ \ \ \}}
\DoxyCodeLine{00244\ \ \ \ \ \textcolor{keywordflow}{return}\ match;}
\DoxyCodeLine{00245\ \ \ \}}
\DoxyCodeLine{00246\ }
\DoxyCodeLine{00247\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ an\ even\ number"{}};\ \}}
\DoxyCodeLine{00248\ \};}
\DoxyCodeLine{00249\ }
\DoxyCodeLine{00250\ TEST(MatcherInterfaceTest,\ CanBeImplementedUsingNewAPI)\ \{}
\DoxyCodeLine{00251\ \ \ Matcher<int>\ m\ =\ MakeMatcher(\textcolor{keyword}{new}\ NewEvenMatcherImpl);}
\DoxyCodeLine{00252\ \ \ EXPECT\_TRUE(m.Matches(2));}
\DoxyCodeLine{00253\ \ \ EXPECT\_FALSE(m.Matches(3));}
\DoxyCodeLine{00254\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}value\ \%\ 2\ ==\ 0"{}},\ Explain(m,\ 2));}
\DoxyCodeLine{00255\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}value\ \%\ 2\ ==\ 1"{}},\ Explain(m,\ 3));}
\DoxyCodeLine{00256\ \}}
\DoxyCodeLine{00257\ }
\DoxyCodeLine{00258\ \textcolor{comment}{//\ Tests\ default-\/constructing\ a\ matcher.}}
\DoxyCodeLine{00259\ TEST(MatcherTest,\ CanBeDefaultConstructed)\ \{}
\DoxyCodeLine{00260\ \ \ Matcher<double>\ m;}
\DoxyCodeLine{00261\ \}}
\DoxyCodeLine{00262\ }
\DoxyCodeLine{00263\ \textcolor{comment}{//\ Tests\ that\ Matcher<T>\ can\ be\ constructed\ from\ a\ MatcherInterface<T>*.}}
\DoxyCodeLine{00264\ TEST(MatcherTest,\ CanBeConstructedFromMatcherInterface)\ \{}
\DoxyCodeLine{00265\ \ \ \textcolor{keyword}{const}\ MatcherInterface<int>*\ impl\ =\ \textcolor{keyword}{new}\ EvenMatcherImpl;}
\DoxyCodeLine{00266\ \ \ Matcher<int>\ m(impl);}
\DoxyCodeLine{00267\ \ \ EXPECT\_TRUE(m.Matches(4));}
\DoxyCodeLine{00268\ \ \ EXPECT\_FALSE(m.Matches(5));}
\DoxyCodeLine{00269\ \}}
\DoxyCodeLine{00270\ }
\DoxyCodeLine{00271\ \textcolor{comment}{//\ Tests\ that\ value\ can\ be\ used\ in\ place\ of\ Eq(value).}}
\DoxyCodeLine{00272\ TEST(MatcherTest,\ CanBeImplicitlyConstructedFromValue)\ \{}
\DoxyCodeLine{00273\ \ \ Matcher<int>\ m1\ =\ 5;}
\DoxyCodeLine{00274\ \ \ EXPECT\_TRUE(m1.Matches(5));}
\DoxyCodeLine{00275\ \ \ EXPECT\_FALSE(m1.Matches(6));}
\DoxyCodeLine{00276\ \}}
\DoxyCodeLine{00277\ }
\DoxyCodeLine{00278\ \textcolor{comment}{//\ Tests\ that\ NULL\ can\ be\ used\ in\ place\ of\ Eq(NULL).}}
\DoxyCodeLine{00279\ TEST(MatcherTest,\ CanBeImplicitlyConstructedFromNULL)\ \{}
\DoxyCodeLine{00280\ \ \ Matcher<int*>\ m1\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00281\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00282\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{00283\ \ \ EXPECT\_FALSE(m1.Matches(\&n));}
\DoxyCodeLine{00284\ \}}
\DoxyCodeLine{00285\ }
\DoxyCodeLine{00286\ \textcolor{comment}{//\ Tests\ that\ matchers\ can\ be\ constructed\ from\ a\ variable\ that\ is\ not\ properly}}
\DoxyCodeLine{00287\ \textcolor{comment}{//\ defined.\ This\ should\ be\ illegal,\ but\ many\ users\ rely\ on\ this\ accidentally.}}
\DoxyCodeLine{00288\ \textcolor{keyword}{struct\ }Undefined\ \{}
\DoxyCodeLine{00289\ \ \ \textcolor{keyword}{virtual}\ \string~Undefined()\ =\ 0;}
\DoxyCodeLine{00290\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ kInt\ =\ 1;}
\DoxyCodeLine{00291\ \};}
\DoxyCodeLine{00292\ }
\DoxyCodeLine{00293\ TEST(MatcherTest,\ CanBeConstructedFromUndefinedVariable)\ \{}
\DoxyCodeLine{00294\ \ \ Matcher<int>\ m1\ =\ Undefined::kInt;}
\DoxyCodeLine{00295\ \ \ EXPECT\_TRUE(m1.Matches(1));}
\DoxyCodeLine{00296\ \ \ EXPECT\_FALSE(m1.Matches(2));}
\DoxyCodeLine{00297\ \}}
\DoxyCodeLine{00298\ }
\DoxyCodeLine{00299\ \textcolor{comment}{//\ Test\ that\ a\ matcher\ parameterized\ with\ an\ abstract\ class\ compiles.}}
\DoxyCodeLine{00300\ TEST(MatcherTest,\ CanAcceptAbstractClass)\ \{\ Matcher<const\ Undefined\&>\ m\ =\ \_;\ \}}
\DoxyCodeLine{00301\ }
\DoxyCodeLine{00302\ \textcolor{comment}{//\ Tests\ that\ matchers\ are\ copyable.}}
\DoxyCodeLine{00303\ TEST(MatcherTest,\ IsCopyable)\ \{}
\DoxyCodeLine{00304\ \ \ \textcolor{comment}{//\ Tests\ the\ copy\ constructor.}}
\DoxyCodeLine{00305\ \ \ Matcher<bool>\ m1\ =\ Eq(\textcolor{keyword}{false});}
\DoxyCodeLine{00306\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{keyword}{false}));}
\DoxyCodeLine{00307\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{true}));}
\DoxyCodeLine{00308\ }
\DoxyCodeLine{00309\ \ \ \textcolor{comment}{//\ Tests\ the\ assignment\ operator.}}
\DoxyCodeLine{00310\ \ \ m1\ =\ Eq(\textcolor{keyword}{true});}
\DoxyCodeLine{00311\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{keyword}{true}));}
\DoxyCodeLine{00312\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{false}));}
\DoxyCodeLine{00313\ \}}
\DoxyCodeLine{00314\ }
\DoxyCodeLine{00315\ \textcolor{comment}{//\ Tests\ that\ Matcher<T>::DescribeTo()\ calls}}
\DoxyCodeLine{00316\ \textcolor{comment}{//\ MatcherInterface<T>::DescribeTo().}}
\DoxyCodeLine{00317\ TEST(MatcherTest,\ CanDescribeItself)\ \{}
\DoxyCodeLine{00318\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ even\ number"{}},}
\DoxyCodeLine{00319\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(Matcher<int>(\textcolor{keyword}{new}\ EvenMatcherImpl)));}
\DoxyCodeLine{00320\ \}}
\DoxyCodeLine{00321\ }
\DoxyCodeLine{00322\ \textcolor{comment}{//\ Tests\ Matcher<T>::MatchAndExplain().}}
\DoxyCodeLine{00323\ TEST(MatcherTest,\ MatchAndExplain)\ \{}
\DoxyCodeLine{00324\ \ \ Matcher<int>\ m\ =\ GreaterThan(0);}
\DoxyCodeLine{00325\ \ \ StringMatchResultListener\ listener1;}
\DoxyCodeLine{00326\ \ \ EXPECT\_TRUE(m.MatchAndExplain(42,\ \&listener1));}
\DoxyCodeLine{00327\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 42\ more\ than\ 0"{}},\ listener1.str());}
\DoxyCodeLine{00328\ }
\DoxyCodeLine{00329\ \ \ StringMatchResultListener\ listener2;}
\DoxyCodeLine{00330\ \ \ EXPECT\_FALSE(m.MatchAndExplain(-\/9,\ \&listener2));}
\DoxyCodeLine{00331\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 9\ less\ than\ 0"{}},\ listener2.str());}
\DoxyCodeLine{00332\ \}}
\DoxyCodeLine{00333\ }
\DoxyCodeLine{00334\ \textcolor{comment}{//\ Tests\ that\ a\ C-\/string\ literal\ can\ be\ implicitly\ converted\ to\ a}}
\DoxyCodeLine{00335\ \textcolor{comment}{//\ Matcher<std::string>\ or\ Matcher<const\ std::string\&>.}}
\DoxyCodeLine{00336\ TEST(StringMatcherTest,\ CanBeImplicitlyConstructedFromCStringLiteral)\ \{}
\DoxyCodeLine{00337\ \ \ Matcher<std::string>\ m1\ =\ \textcolor{stringliteral}{"{}hi"{}};}
\DoxyCodeLine{00338\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{00339\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{00340\ }
\DoxyCodeLine{00341\ \ \ Matcher<const\ std::string\&>\ m2\ =\ \textcolor{stringliteral}{"{}hi"{}};}
\DoxyCodeLine{00342\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{00343\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{00344\ \}}
\DoxyCodeLine{00345\ }
\DoxyCodeLine{00346\ \textcolor{comment}{//\ Tests\ that\ a\ string\ object\ can\ be\ implicitly\ converted\ to\ a}}
\DoxyCodeLine{00347\ \textcolor{comment}{//\ Matcher<std::string>\ or\ Matcher<const\ std::string\&>.}}
\DoxyCodeLine{00348\ TEST(StringMatcherTest,\ CanBeImplicitlyConstructedFromString)\ \{}
\DoxyCodeLine{00349\ \ \ Matcher<std::string>\ m1\ =\ std::string(\textcolor{stringliteral}{"{}hi"{}});}
\DoxyCodeLine{00350\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{00351\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{00352\ }
\DoxyCodeLine{00353\ \ \ Matcher<const\ std::string\&>\ m2\ =\ std::string(\textcolor{stringliteral}{"{}hi"{}});}
\DoxyCodeLine{00354\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{00355\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{00356\ \}}
\DoxyCodeLine{00357\ }
\DoxyCodeLine{00358\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00359\ \textcolor{comment}{//\ Tests\ that\ a\ C-\/string\ literal\ can\ be\ implicitly\ converted\ to\ a}}
\DoxyCodeLine{00360\ \textcolor{comment}{//\ Matcher<StringView>\ or\ Matcher<const\ StringView\&>.}}
\DoxyCodeLine{00361\ TEST(StringViewMatcherTest,\ CanBeImplicitlyConstructedFromCStringLiteral)\ \{}
\DoxyCodeLine{00362\ \ \ Matcher<internal::StringView>\ m1\ =\ \textcolor{stringliteral}{"{}cats"{}};}
\DoxyCodeLine{00363\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}cats"{}}));}
\DoxyCodeLine{00364\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}dogs"{}}));}
\DoxyCodeLine{00365\ }
\DoxyCodeLine{00366\ \ \ Matcher<const\ internal::StringView\&>\ m2\ =\ \textcolor{stringliteral}{"{}cats"{}};}
\DoxyCodeLine{00367\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}cats"{}}));}
\DoxyCodeLine{00368\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}dogs"{}}));}
\DoxyCodeLine{00369\ \}}
\DoxyCodeLine{00370\ }
\DoxyCodeLine{00371\ \textcolor{comment}{//\ Tests\ that\ a\ std::string\ object\ can\ be\ implicitly\ converted\ to\ a}}
\DoxyCodeLine{00372\ \textcolor{comment}{//\ Matcher<StringView>\ or\ Matcher<const\ StringView\&>.}}
\DoxyCodeLine{00373\ TEST(StringViewMatcherTest,\ CanBeImplicitlyConstructedFromString)\ \{}
\DoxyCodeLine{00374\ \ \ Matcher<internal::StringView>\ m1\ =\ std::string(\textcolor{stringliteral}{"{}cats"{}});}
\DoxyCodeLine{00375\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}cats"{}}));}
\DoxyCodeLine{00376\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}dogs"{}}));}
\DoxyCodeLine{00377\ }
\DoxyCodeLine{00378\ \ \ Matcher<const\ internal::StringView\&>\ m2\ =\ std::string(\textcolor{stringliteral}{"{}cats"{}});}
\DoxyCodeLine{00379\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}cats"{}}));}
\DoxyCodeLine{00380\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}dogs"{}}));}
\DoxyCodeLine{00381\ \}}
\DoxyCodeLine{00382\ }
\DoxyCodeLine{00383\ \textcolor{comment}{//\ Tests\ that\ a\ StringView\ object\ can\ be\ implicitly\ converted\ to\ a}}
\DoxyCodeLine{00384\ \textcolor{comment}{//\ Matcher<StringView>\ or\ Matcher<const\ StringView\&>.}}
\DoxyCodeLine{00385\ TEST(StringViewMatcherTest,\ CanBeImplicitlyConstructedFromStringView)\ \{}
\DoxyCodeLine{00386\ \ \ Matcher<internal::StringView>\ m1\ =\ internal::StringView(\textcolor{stringliteral}{"{}cats"{}});}
\DoxyCodeLine{00387\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}cats"{}}));}
\DoxyCodeLine{00388\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}dogs"{}}));}
\DoxyCodeLine{00389\ }
\DoxyCodeLine{00390\ \ \ Matcher<const\ internal::StringView\&>\ m2\ =\ internal::StringView(\textcolor{stringliteral}{"{}cats"{}});}
\DoxyCodeLine{00391\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}cats"{}}));}
\DoxyCodeLine{00392\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}dogs"{}}));}
\DoxyCodeLine{00393\ \}}
\DoxyCodeLine{00394\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{00395\ }
\DoxyCodeLine{00396\ \textcolor{comment}{//\ Tests\ that\ a\ std::reference\_wrapper<std::string>\ object\ can\ be\ implicitly}}
\DoxyCodeLine{00397\ \textcolor{comment}{//\ converted\ to\ a\ Matcher<std::string>\ or\ Matcher<const\ std::string\&>\ via\ Eq().}}
\DoxyCodeLine{00398\ TEST(StringMatcherTest,}
\DoxyCodeLine{00399\ \ \ \ \ \ CanBeImplicitlyConstructedFromEqReferenceWrapperString)\ \{}
\DoxyCodeLine{00400\ \ \ std::string\ value\ =\ \textcolor{stringliteral}{"{}cats"{}};}
\DoxyCodeLine{00401\ \ \ Matcher<std::string>\ m1\ =\ Eq(std::ref(value));}
\DoxyCodeLine{00402\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}cats"{}}));}
\DoxyCodeLine{00403\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}dogs"{}}));}
\DoxyCodeLine{00404\ }
\DoxyCodeLine{00405\ \ \ Matcher<const\ std::string\&>\ m2\ =\ Eq(std::ref(value));}
\DoxyCodeLine{00406\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}cats"{}}));}
\DoxyCodeLine{00407\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}dogs"{}}));}
\DoxyCodeLine{00408\ \}}
\DoxyCodeLine{00409\ }
\DoxyCodeLine{00410\ \textcolor{comment}{//\ Tests\ that\ MakeMatcher()\ constructs\ a\ Matcher<T>\ from\ a}}
\DoxyCodeLine{00411\ \textcolor{comment}{//\ MatcherInterface*\ without\ requiring\ the\ user\ to\ explicitly}}
\DoxyCodeLine{00412\ \textcolor{comment}{//\ write\ the\ type.}}
\DoxyCodeLine{00413\ TEST(MakeMatcherTest,\ ConstructsMatcherFromMatcherInterface)\ \{}
\DoxyCodeLine{00414\ \ \ \textcolor{keyword}{const}\ MatcherInterface<int>*\ dummy\_impl\ =\ \textcolor{keyword}{new}\ EvenMatcherImpl;}
\DoxyCodeLine{00415\ \ \ Matcher<int>\ m\ =\ MakeMatcher(dummy\_impl);}
\DoxyCodeLine{00416\ \}}
\DoxyCodeLine{00417\ }
\DoxyCodeLine{00418\ \textcolor{comment}{//\ Tests\ that\ MakePolymorphicMatcher()\ can\ construct\ a\ polymorphic}}
\DoxyCodeLine{00419\ \textcolor{comment}{//\ matcher\ from\ its\ implementation\ using\ the\ old\ API.}}
\DoxyCodeLine{00420\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ g\_bar\ =\ 1;}
\DoxyCodeLine{00421\ \textcolor{keyword}{class\ }ReferencesBarOrIsZeroImpl\ \{}
\DoxyCodeLine{00422\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00423\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00424\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ x,}
\DoxyCodeLine{00425\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ \textcolor{comment}{/*\ listener\ */})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00426\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{void}*\ p\ =\ \&x;}
\DoxyCodeLine{00427\ \ \ \ \ \textcolor{keywordflow}{return}\ p\ ==\ \&g\_bar\ ||\ x\ ==\ 0;}
\DoxyCodeLine{00428\ \ \ \}}
\DoxyCodeLine{00429\ }
\DoxyCodeLine{00430\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}g\_bar\ or\ zero"{}};\ \}}
\DoxyCodeLine{00431\ }
\DoxyCodeLine{00432\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00433\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}doesn't\ reference\ g\_bar\ and\ is\ not\ zero"{}};}
\DoxyCodeLine{00434\ \ \ \}}
\DoxyCodeLine{00435\ \};}
\DoxyCodeLine{00436\ }
\DoxyCodeLine{00437\ \textcolor{comment}{//\ This\ function\ verifies\ that\ MakePolymorphicMatcher()\ returns\ a}}
\DoxyCodeLine{00438\ \textcolor{comment}{//\ PolymorphicMatcher<T>\ where\ T\ is\ the\ argument's\ type.}}
\DoxyCodeLine{00439\ PolymorphicMatcher<ReferencesBarOrIsZeroImpl>\ ReferencesBarOrIsZero()\ \{}
\DoxyCodeLine{00440\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(ReferencesBarOrIsZeroImpl());}
\DoxyCodeLine{00441\ \}}
\DoxyCodeLine{00442\ }
\DoxyCodeLine{00443\ TEST(MakePolymorphicMatcherTest,\ ConstructsMatcherUsingOldAPI)\ \{}
\DoxyCodeLine{00444\ \ \ \textcolor{comment}{//\ Using\ a\ polymorphic\ matcher\ to\ match\ a\ reference\ type.}}
\DoxyCodeLine{00445\ \ \ Matcher<const\ int\&>\ m1\ =\ ReferencesBarOrIsZero();}
\DoxyCodeLine{00446\ \ \ EXPECT\_TRUE(m1.Matches(0));}
\DoxyCodeLine{00447\ \ \ \textcolor{comment}{//\ Verifies\ that\ the\ identity\ of\ a\ by-\/reference\ argument\ is\ preserved.}}
\DoxyCodeLine{00448\ \ \ EXPECT\_TRUE(m1.Matches(g\_bar));}
\DoxyCodeLine{00449\ \ \ EXPECT\_FALSE(m1.Matches(1));}
\DoxyCodeLine{00450\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}g\_bar\ or\ zero"{}},\ Describe(m1));}
\DoxyCodeLine{00451\ }
\DoxyCodeLine{00452\ \ \ \textcolor{comment}{//\ Using\ a\ polymorphic\ matcher\ to\ match\ a\ value\ type.}}
\DoxyCodeLine{00453\ \ \ Matcher<double>\ m2\ =\ ReferencesBarOrIsZero();}
\DoxyCodeLine{00454\ \ \ EXPECT\_TRUE(m2.Matches(0.0));}
\DoxyCodeLine{00455\ \ \ EXPECT\_FALSE(m2.Matches(0.1));}
\DoxyCodeLine{00456\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}g\_bar\ or\ zero"{}},\ Describe(m2));}
\DoxyCodeLine{00457\ \}}
\DoxyCodeLine{00458\ }
\DoxyCodeLine{00459\ \textcolor{comment}{//\ Tests\ implementing\ a\ polymorphic\ matcher\ using\ MatchAndExplain().}}
\DoxyCodeLine{00460\ }
\DoxyCodeLine{00461\ \textcolor{keyword}{class\ }PolymorphicIsEvenImpl\ \{}
\DoxyCodeLine{00462\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00463\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(ostream*\ os)\textcolor{keyword}{\ const\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}is\ even"{}};\ \}}
\DoxyCodeLine{00464\ }
\DoxyCodeLine{00465\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00466\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ odd"{}};}
\DoxyCodeLine{00467\ \ \ \}}
\DoxyCodeLine{00468\ }
\DoxyCodeLine{00469\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00470\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ x,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00471\ \ \ \ \ \textcolor{comment}{//\ Verifies\ that\ we\ can\ stream\ to\ the\ listener\ directly.}}
\DoxyCodeLine{00472\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}\%\ "{}}\ <<\ 2;}
\DoxyCodeLine{00473\ \ \ \ \ \textcolor{keywordflow}{if}\ (listener-\/>stream()\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00474\ \ \ \ \ \ \ \textcolor{comment}{//\ Verifies\ that\ we\ can\ stream\ to\ the\ listener's\ underlying\ stream}}
\DoxyCodeLine{00475\ \ \ \ \ \ \ \textcolor{comment}{//\ too.}}
\DoxyCodeLine{00476\ \ \ \ \ \ \ *listener-\/>stream()\ <<\ \textcolor{stringliteral}{"{}\ ==\ "{}}\ <<\ (x\ \%\ 2);}
\DoxyCodeLine{00477\ \ \ \ \ \}}
\DoxyCodeLine{00478\ \ \ \ \ \textcolor{keywordflow}{return}\ (x\ \%\ 2)\ ==\ 0;}
\DoxyCodeLine{00479\ \ \ \}}
\DoxyCodeLine{00480\ \};}
\DoxyCodeLine{00481\ }
\DoxyCodeLine{00482\ PolymorphicMatcher<PolymorphicIsEvenImpl>\ PolymorphicIsEven()\ \{}
\DoxyCodeLine{00483\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(PolymorphicIsEvenImpl());}
\DoxyCodeLine{00484\ \}}
\DoxyCodeLine{00485\ }
\DoxyCodeLine{00486\ TEST(MakePolymorphicMatcherTest,\ ConstructsMatcherUsingNewAPI)\ \{}
\DoxyCodeLine{00487\ \ \ \textcolor{comment}{//\ Using\ PolymorphicIsEven()\ as\ a\ Matcher<int>.}}
\DoxyCodeLine{00488\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m1\ =\ PolymorphicIsEven();}
\DoxyCodeLine{00489\ \ \ EXPECT\_TRUE(m1.Matches(42));}
\DoxyCodeLine{00490\ \ \ EXPECT\_FALSE(m1.Matches(43));}
\DoxyCodeLine{00491\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ even"{}},\ Describe(m1));}
\DoxyCodeLine{00492\ }
\DoxyCodeLine{00493\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ not\_m1\ =\ Not(m1);}
\DoxyCodeLine{00494\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ odd"{}},\ Describe(not\_m1));}
\DoxyCodeLine{00495\ }
\DoxyCodeLine{00496\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}\%\ 2\ ==\ 0"{}},\ Explain(m1,\ 42));}
\DoxyCodeLine{00497\ }
\DoxyCodeLine{00498\ \ \ \textcolor{comment}{//\ Using\ PolymorphicIsEven()\ as\ a\ Matcher<char>.}}
\DoxyCodeLine{00499\ \ \ \textcolor{keyword}{const}\ Matcher<char>\ m2\ =\ PolymorphicIsEven();}
\DoxyCodeLine{00500\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{'\(\backslash\)x42'}));}
\DoxyCodeLine{00501\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{'\(\backslash\)x43'}));}
\DoxyCodeLine{00502\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ even"{}},\ Describe(m2));}
\DoxyCodeLine{00503\ }
\DoxyCodeLine{00504\ \ \ \textcolor{keyword}{const}\ Matcher<char>\ not\_m2\ =\ Not(m2);}
\DoxyCodeLine{00505\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ odd"{}},\ Describe(not\_m2));}
\DoxyCodeLine{00506\ }
\DoxyCodeLine{00507\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}\%\ 2\ ==\ 0"{}},\ Explain(m2,\ \textcolor{stringliteral}{'\(\backslash\)x42'}));}
\DoxyCodeLine{00508\ \}}
\DoxyCodeLine{00509\ }
\DoxyCodeLine{00510\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T>(m)\ works\ when\ m\ is\ a\ polymorphic\ matcher.}}
\DoxyCodeLine{00511\ TEST(MatcherCastTest,\ FromPolymorphicMatcher)\ \{}
\DoxyCodeLine{00512\ \ \ Matcher<int>\ m\ =\ MatcherCast<int>(Eq(5));}
\DoxyCodeLine{00513\ \ \ EXPECT\_TRUE(m.Matches(5));}
\DoxyCodeLine{00514\ \ \ EXPECT\_FALSE(m.Matches(6));}
\DoxyCodeLine{00515\ \}}
\DoxyCodeLine{00516\ }
\DoxyCodeLine{00517\ \textcolor{comment}{//\ For\ testing\ casting\ matchers\ between\ compatible\ types.}}
\DoxyCodeLine{00518\ \textcolor{keyword}{class\ }IntValue\ \{}
\DoxyCodeLine{00519\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00520\ \ \ \textcolor{comment}{//\ An\ int\ can\ be\ statically\ (although\ not\ implicitly)\ cast\ to\ a}}
\DoxyCodeLine{00521\ \ \ \textcolor{comment}{//\ IntValue.}}
\DoxyCodeLine{00522\ \ \ \textcolor{keyword}{explicit}\ IntValue(\textcolor{keywordtype}{int}\ a\_value)\ :\ value\_(a\_value)\ \{\}}
\DoxyCodeLine{00523\ }
\DoxyCodeLine{00524\ \ \ \textcolor{keywordtype}{int}\ value()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ value\_;\ \}}
\DoxyCodeLine{00525\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00526\ \ \ \textcolor{keywordtype}{int}\ value\_;}
\DoxyCodeLine{00527\ \};}
\DoxyCodeLine{00528\ }
\DoxyCodeLine{00529\ \textcolor{comment}{//\ For\ testing\ casting\ matchers\ between\ compatible\ types.}}
\DoxyCodeLine{00530\ \textcolor{keywordtype}{bool}\ IsPositiveIntValue(\textcolor{keyword}{const}\ IntValue\&\ foo)\ \{}
\DoxyCodeLine{00531\ \ \ \textcolor{keywordflow}{return}\ foo.value()\ >\ 0;}
\DoxyCodeLine{00532\ \}}
\DoxyCodeLine{00533\ }
\DoxyCodeLine{00534\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T>(m)\ works\ when\ m\ is\ a\ Matcher<U>\ where\ T}}
\DoxyCodeLine{00535\ \textcolor{comment}{//\ can\ be\ statically\ converted\ to\ U.}}
\DoxyCodeLine{00536\ TEST(MatcherCastTest,\ FromCompatibleType)\ \{}
\DoxyCodeLine{00537\ \ \ Matcher<double>\ m1\ =\ Eq(2.0);}
\DoxyCodeLine{00538\ \ \ Matcher<int>\ m2\ =\ MatcherCast<int>(m1);}
\DoxyCodeLine{00539\ \ \ EXPECT\_TRUE(m2.Matches(2));}
\DoxyCodeLine{00540\ \ \ EXPECT\_FALSE(m2.Matches(3));}
\DoxyCodeLine{00541\ }
\DoxyCodeLine{00542\ \ \ Matcher<IntValue>\ m3\ =\ Truly(IsPositiveIntValue);}
\DoxyCodeLine{00543\ \ \ Matcher<int>\ m4\ =\ MatcherCast<int>(m3);}
\DoxyCodeLine{00544\ \ \ \textcolor{comment}{//\ In\ the\ following,\ the\ arguments\ 1\ and\ 0\ are\ statically\ converted}}
\DoxyCodeLine{00545\ \ \ \textcolor{comment}{//\ to\ IntValue\ objects,\ and\ then\ tested\ by\ the\ IsPositiveIntValue()}}
\DoxyCodeLine{00546\ \ \ \textcolor{comment}{//\ predicate.}}
\DoxyCodeLine{00547\ \ \ EXPECT\_TRUE(m4.Matches(1));}
\DoxyCodeLine{00548\ \ \ EXPECT\_FALSE(m4.Matches(0));}
\DoxyCodeLine{00549\ \}}
\DoxyCodeLine{00550\ }
\DoxyCodeLine{00551\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T>(m)\ works\ when\ m\ is\ a\ Matcher<const\ T\&>.}}
\DoxyCodeLine{00552\ TEST(MatcherCastTest,\ FromConstReferenceToNonReference)\ \{}
\DoxyCodeLine{00553\ \ \ Matcher<const\ int\&>\ m1\ =\ Eq(0);}
\DoxyCodeLine{00554\ \ \ Matcher<int>\ m2\ =\ MatcherCast<int>(m1);}
\DoxyCodeLine{00555\ \ \ EXPECT\_TRUE(m2.Matches(0));}
\DoxyCodeLine{00556\ \ \ EXPECT\_FALSE(m2.Matches(1));}
\DoxyCodeLine{00557\ \}}
\DoxyCodeLine{00558\ }
\DoxyCodeLine{00559\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T>(m)\ works\ when\ m\ is\ a\ Matcher<T\&>.}}
\DoxyCodeLine{00560\ TEST(MatcherCastTest,\ FromReferenceToNonReference)\ \{}
\DoxyCodeLine{00561\ \ \ Matcher<int\&>\ m1\ =\ Eq(0);}
\DoxyCodeLine{00562\ \ \ Matcher<int>\ m2\ =\ MatcherCast<int>(m1);}
\DoxyCodeLine{00563\ \ \ EXPECT\_TRUE(m2.Matches(0));}
\DoxyCodeLine{00564\ \ \ EXPECT\_FALSE(m2.Matches(1));}
\DoxyCodeLine{00565\ \}}
\DoxyCodeLine{00566\ }
\DoxyCodeLine{00567\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<const\ T\&>(m)\ works\ when\ m\ is\ a\ Matcher<T>.}}
\DoxyCodeLine{00568\ TEST(MatcherCastTest,\ FromNonReferenceToConstReference)\ \{}
\DoxyCodeLine{00569\ \ \ Matcher<int>\ m1\ =\ Eq(0);}
\DoxyCodeLine{00570\ \ \ Matcher<const\ int\&>\ m2\ =\ MatcherCast<const\ int\&>(m1);}
\DoxyCodeLine{00571\ \ \ EXPECT\_TRUE(m2.Matches(0));}
\DoxyCodeLine{00572\ \ \ EXPECT\_FALSE(m2.Matches(1));}
\DoxyCodeLine{00573\ \}}
\DoxyCodeLine{00574\ }
\DoxyCodeLine{00575\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T\&>(m)\ works\ when\ m\ is\ a\ Matcher<T>.}}
\DoxyCodeLine{00576\ TEST(MatcherCastTest,\ FromNonReferenceToReference)\ \{}
\DoxyCodeLine{00577\ \ \ Matcher<int>\ m1\ =\ Eq(0);}
\DoxyCodeLine{00578\ \ \ Matcher<int\&>\ m2\ =\ MatcherCast<int\&>(m1);}
\DoxyCodeLine{00579\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{00580\ \ \ EXPECT\_TRUE(m2.Matches(n));}
\DoxyCodeLine{00581\ \ \ n\ =\ 1;}
\DoxyCodeLine{00582\ \ \ EXPECT\_FALSE(m2.Matches(n));}
\DoxyCodeLine{00583\ \}}
\DoxyCodeLine{00584\ }
\DoxyCodeLine{00585\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T>(m)\ works\ when\ m\ is\ a\ Matcher<T>.}}
\DoxyCodeLine{00586\ TEST(MatcherCastTest,\ FromSameType)\ \{}
\DoxyCodeLine{00587\ \ \ Matcher<int>\ m1\ =\ Eq(0);}
\DoxyCodeLine{00588\ \ \ Matcher<int>\ m2\ =\ MatcherCast<int>(m1);}
\DoxyCodeLine{00589\ \ \ EXPECT\_TRUE(m2.Matches(0));}
\DoxyCodeLine{00590\ \ \ EXPECT\_FALSE(m2.Matches(1));}
\DoxyCodeLine{00591\ \}}
\DoxyCodeLine{00592\ }
\DoxyCodeLine{00593\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T>(m)\ works\ when\ m\ is\ a\ value\ of\ the\ same\ type\ as\ the}}
\DoxyCodeLine{00594\ \textcolor{comment}{//\ value\ type\ of\ the\ Matcher.}}
\DoxyCodeLine{00595\ TEST(MatcherCastTest,\ FromAValue)\ \{}
\DoxyCodeLine{00596\ \ \ Matcher<int>\ m\ =\ MatcherCast<int>(42);}
\DoxyCodeLine{00597\ \ \ EXPECT\_TRUE(m.Matches(42));}
\DoxyCodeLine{00598\ \ \ EXPECT\_FALSE(m.Matches(239));}
\DoxyCodeLine{00599\ \}}
\DoxyCodeLine{00600\ }
\DoxyCodeLine{00601\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T>(m)\ works\ when\ m\ is\ a\ value\ of\ the\ type\ implicitly}}
\DoxyCodeLine{00602\ \textcolor{comment}{//\ convertible\ to\ the\ value\ type\ of\ the\ Matcher.}}
\DoxyCodeLine{00603\ TEST(MatcherCastTest,\ FromAnImplicitlyConvertibleValue)\ \{}
\DoxyCodeLine{00604\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ kExpected\ =\ \textcolor{charliteral}{'c'};}
\DoxyCodeLine{00605\ \ \ Matcher<int>\ m\ =\ MatcherCast<int>(\textcolor{charliteral}{'c'});}
\DoxyCodeLine{00606\ \ \ EXPECT\_TRUE(m.Matches(kExpected));}
\DoxyCodeLine{00607\ \ \ EXPECT\_FALSE(m.Matches(kExpected\ +\ 1));}
\DoxyCodeLine{00608\ \}}
\DoxyCodeLine{00609\ }
\DoxyCodeLine{00610\ \textcolor{keyword}{struct\ }NonImplicitlyConstructibleTypeWithOperatorEq\ \{}
\DoxyCodeLine{00611\ \ \ \textcolor{keyword}{friend}\ \textcolor{keywordtype}{bool}\ operator==(}
\DoxyCodeLine{00612\ \ \ \ \ \ \ \textcolor{keyword}{const}\ NonImplicitlyConstructibleTypeWithOperatorEq\&\ \textcolor{comment}{/*\ ignored\ */},}
\DoxyCodeLine{00613\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ rhs)\ \{}
\DoxyCodeLine{00614\ \ \ \ \ \textcolor{keywordflow}{return}\ 42\ ==\ rhs;}
\DoxyCodeLine{00615\ \ \ \}}
\DoxyCodeLine{00616\ \ \ \textcolor{keyword}{friend}\ \textcolor{keywordtype}{bool}\ operator==(}
\DoxyCodeLine{00617\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ lhs,}
\DoxyCodeLine{00618\ \ \ \ \ \ \ \textcolor{keyword}{const}\ NonImplicitlyConstructibleTypeWithOperatorEq\&\ \textcolor{comment}{/*\ ignored\ */})\ \{}
\DoxyCodeLine{00619\ \ \ \ \ \textcolor{keywordflow}{return}\ lhs\ ==\ 42;}
\DoxyCodeLine{00620\ \ \ \}}
\DoxyCodeLine{00621\ \};}
\DoxyCodeLine{00622\ }
\DoxyCodeLine{00623\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<T>(m)\ works\ when\ m\ is\ a\ neither\ a\ matcher\ nor}}
\DoxyCodeLine{00624\ \textcolor{comment}{//\ implicitly\ convertible\ to\ the\ value\ type\ of\ the\ Matcher,\ but\ the\ value\ type}}
\DoxyCodeLine{00625\ \textcolor{comment}{//\ of\ the\ matcher\ has\ operator==()\ overload\ accepting\ m.}}
\DoxyCodeLine{00626\ TEST(MatcherCastTest,\ NonImplicitlyConstructibleTypeWithOperatorEq)\ \{}
\DoxyCodeLine{00627\ \ \ Matcher<NonImplicitlyConstructibleTypeWithOperatorEq>\ m1\ =}
\DoxyCodeLine{00628\ \ \ \ \ \ \ MatcherCast<NonImplicitlyConstructibleTypeWithOperatorEq>(42);}
\DoxyCodeLine{00629\ \ \ EXPECT\_TRUE(m1.Matches(NonImplicitlyConstructibleTypeWithOperatorEq()));}
\DoxyCodeLine{00630\ }
\DoxyCodeLine{00631\ \ \ Matcher<NonImplicitlyConstructibleTypeWithOperatorEq>\ m2\ =}
\DoxyCodeLine{00632\ \ \ \ \ \ \ MatcherCast<NonImplicitlyConstructibleTypeWithOperatorEq>(239);}
\DoxyCodeLine{00633\ \ \ EXPECT\_FALSE(m2.Matches(NonImplicitlyConstructibleTypeWithOperatorEq()));}
\DoxyCodeLine{00634\ }
\DoxyCodeLine{00635\ \ \ \textcolor{comment}{//\ When\ updating\ the\ following\ lines\ please\ also\ change\ the\ comment\ to}}
\DoxyCodeLine{00636\ \ \ \textcolor{comment}{//\ namespace\ convertible\_from\_any.}}
\DoxyCodeLine{00637\ \ \ Matcher<int>\ m3\ =}
\DoxyCodeLine{00638\ \ \ \ \ \ \ MatcherCast<int>(NonImplicitlyConstructibleTypeWithOperatorEq());}
\DoxyCodeLine{00639\ \ \ EXPECT\_TRUE(m3.Matches(42));}
\DoxyCodeLine{00640\ \ \ EXPECT\_FALSE(m3.Matches(239));}
\DoxyCodeLine{00641\ \}}
\DoxyCodeLine{00642\ }
\DoxyCodeLine{00643\ \textcolor{comment}{//\ ConvertibleFromAny\ does\ not\ work\ with\ MSVC.\ resulting\ in}}
\DoxyCodeLine{00644\ \textcolor{comment}{//\ error\ C2440:\ 'initializing':\ cannot\ convert\ from\ 'Eq'\ to\ 'M'}}
\DoxyCodeLine{00645\ \textcolor{comment}{//\ No\ constructor\ could\ take\ the\ source\ type,\ or\ constructor\ overload}}
\DoxyCodeLine{00646\ \textcolor{comment}{//\ resolution\ was\ ambiguous}}
\DoxyCodeLine{00647\ }
\DoxyCodeLine{00648\ \textcolor{preprocessor}{\#if\ !defined\ \_MSC\_VER}}
\DoxyCodeLine{00649\ }
\DoxyCodeLine{00650\ \textcolor{comment}{//\ The\ below\ ConvertibleFromAny\ struct\ is\ implicitly\ constructible\ from\ anything}}
\DoxyCodeLine{00651\ \textcolor{comment}{//\ and\ when\ in\ the\ same\ namespace\ can\ interact\ with\ other\ tests.\ In\ particular,}}
\DoxyCodeLine{00652\ \textcolor{comment}{//\ if\ it\ is\ in\ the\ same\ namespace\ as\ other\ tests\ and\ one\ removes}}
\DoxyCodeLine{00653\ \textcolor{comment}{//\ \ \ NonImplicitlyConstructibleTypeWithOperatorEq::operator==(int\ lhs,\ ...);}}
\DoxyCodeLine{00654\ \textcolor{comment}{//\ then\ the\ corresponding\ test\ still\ compiles\ (and\ it\ should\ not!)\ by\ implicitly}}
\DoxyCodeLine{00655\ \textcolor{comment}{//\ converting\ NonImplicitlyConstructibleTypeWithOperatorEq\ to\ ConvertibleFromAny}}
\DoxyCodeLine{00656\ \textcolor{comment}{//\ in\ m3.Matcher().}}
\DoxyCodeLine{00657\ \textcolor{keyword}{namespace\ }convertible\_from\_any\ \{}
\DoxyCodeLine{00658\ \textcolor{comment}{//\ Implicitly\ convertible\ from\ any\ type.}}
\DoxyCodeLine{00659\ \textcolor{keyword}{struct\ }ConvertibleFromAny\ \{}
\DoxyCodeLine{00660\ \ \ ConvertibleFromAny(\textcolor{keywordtype}{int}\ a\_value)\ :\ value(a\_value)\ \{\}}
\DoxyCodeLine{00661\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00662\ \ \ ConvertibleFromAny(\textcolor{keyword}{const}\ T\&\ \textcolor{comment}{/*a\_value*/})\ :\ value(-\/1)\ \{}
\DoxyCodeLine{00663\ \ \ \ \ ADD\_FAILURE()\ <<\ \textcolor{stringliteral}{"{}Conversion\ constructor\ called"{}};}
\DoxyCodeLine{00664\ \ \ \}}
\DoxyCodeLine{00665\ \ \ \textcolor{keywordtype}{int}\ value;}
\DoxyCodeLine{00666\ \};}
\DoxyCodeLine{00667\ }
\DoxyCodeLine{00668\ \textcolor{keywordtype}{bool}\ operator==(\textcolor{keyword}{const}\ ConvertibleFromAny\&\ a,\ \textcolor{keyword}{const}\ ConvertibleFromAny\&\ b)\ \{}
\DoxyCodeLine{00669\ \ \ \textcolor{keywordflow}{return}\ a.value\ ==\ b.value;}
\DoxyCodeLine{00670\ \}}
\DoxyCodeLine{00671\ }
\DoxyCodeLine{00672\ ostream\&\ operator<<(ostream\&\ os,\ \textcolor{keyword}{const}\ ConvertibleFromAny\&\ a)\ \{}
\DoxyCodeLine{00673\ \ \ \textcolor{keywordflow}{return}\ os\ <<\ a.value;}
\DoxyCodeLine{00674\ \}}
\DoxyCodeLine{00675\ }
\DoxyCodeLine{00676\ TEST(MatcherCastTest,\ ConversionConstructorIsUsed)\ \{}
\DoxyCodeLine{00677\ \ \ Matcher<ConvertibleFromAny>\ m\ =\ MatcherCast<ConvertibleFromAny>(1);}
\DoxyCodeLine{00678\ \ \ EXPECT\_TRUE(m.Matches(ConvertibleFromAny(1)));}
\DoxyCodeLine{00679\ \ \ EXPECT\_FALSE(m.Matches(ConvertibleFromAny(2)));}
\DoxyCodeLine{00680\ \}}
\DoxyCodeLine{00681\ }
\DoxyCodeLine{00682\ TEST(MatcherCastTest,\ FromConvertibleFromAny)\ \{}
\DoxyCodeLine{00683\ \ \ Matcher<ConvertibleFromAny>\ m\ =}
\DoxyCodeLine{00684\ \ \ \ \ \ \ MatcherCast<ConvertibleFromAny>(Eq(ConvertibleFromAny(1)));}
\DoxyCodeLine{00685\ \ \ EXPECT\_TRUE(m.Matches(ConvertibleFromAny(1)));}
\DoxyCodeLine{00686\ \ \ EXPECT\_FALSE(m.Matches(ConvertibleFromAny(2)));}
\DoxyCodeLine{00687\ \}}
\DoxyCodeLine{00688\ \}\ \ \textcolor{comment}{//\ namespace\ convertible\_from\_any}}
\DoxyCodeLine{00689\ }
\DoxyCodeLine{00690\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ !defined\ \_MSC\_VER}}
\DoxyCodeLine{00691\ }
\DoxyCodeLine{00692\ \textcolor{keyword}{struct\ }IntReferenceWrapper\ \{}
\DoxyCodeLine{00693\ \ \ IntReferenceWrapper(\textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\&\ a\_value)\ :\ value(\&a\_value)\ \{\}}
\DoxyCodeLine{00694\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ value;}
\DoxyCodeLine{00695\ \};}
\DoxyCodeLine{00696\ }
\DoxyCodeLine{00697\ \textcolor{keywordtype}{bool}\ operator==(\textcolor{keyword}{const}\ IntReferenceWrapper\&\ a,\ \textcolor{keyword}{const}\ IntReferenceWrapper\&\ b)\ \{}
\DoxyCodeLine{00698\ \ \ \textcolor{keywordflow}{return}\ a.value\ ==\ b.value;}
\DoxyCodeLine{00699\ \}}
\DoxyCodeLine{00700\ }
\DoxyCodeLine{00701\ TEST(MatcherCastTest,\ ValueIsNotCopied)\ \{}
\DoxyCodeLine{00702\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 42;}
\DoxyCodeLine{00703\ \ \ Matcher<IntReferenceWrapper>\ m\ =\ MatcherCast<IntReferenceWrapper>(n);}
\DoxyCodeLine{00704\ \ \ \textcolor{comment}{//\ Verify\ that\ the\ matcher\ holds\ a\ reference\ to\ n,\ not\ to\ its\ temporary\ copy.}}
\DoxyCodeLine{00705\ \ \ EXPECT\_TRUE(m.Matches(n));}
\DoxyCodeLine{00706\ \}}
\DoxyCodeLine{00707\ }
\DoxyCodeLine{00708\ \textcolor{keyword}{class\ }Base\ \{}
\DoxyCodeLine{00709\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00710\ \ \ \textcolor{keyword}{virtual}\ \string~Base()\ \{\}}
\DoxyCodeLine{00711\ \ \ Base()\ \{\}}
\DoxyCodeLine{00712\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00713\ \ \ GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(Base);}
\DoxyCodeLine{00714\ \};}
\DoxyCodeLine{00715\ }
\DoxyCodeLine{00716\ \textcolor{keyword}{class\ }Derived\ :\ \textcolor{keyword}{public}\ Base\ \{}
\DoxyCodeLine{00717\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00718\ \ \ Derived()\ :\ Base()\ \{\}}
\DoxyCodeLine{00719\ \ \ \textcolor{keywordtype}{int}\ i;}
\DoxyCodeLine{00720\ \};}
\DoxyCodeLine{00721\ }
\DoxyCodeLine{00722\ \textcolor{keyword}{class\ }OtherDerived\ :\ \textcolor{keyword}{public}\ Base\ \{\};}
\DoxyCodeLine{00723\ }
\DoxyCodeLine{00724\ \textcolor{comment}{//\ Tests\ that\ SafeMatcherCast<T>(m)\ works\ when\ m\ is\ a\ polymorphic\ matcher.}}
\DoxyCodeLine{00725\ TEST(SafeMatcherCastTest,\ FromPolymorphicMatcher)\ \{}
\DoxyCodeLine{00726\ \ \ Matcher<char>\ m2\ =\ SafeMatcherCast<char>(Eq(32));}
\DoxyCodeLine{00727\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{charliteral}{'\ '}));}
\DoxyCodeLine{00728\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{charliteral}{'\(\backslash\)n'}));}
\DoxyCodeLine{00729\ \}}
\DoxyCodeLine{00730\ }
\DoxyCodeLine{00731\ \textcolor{comment}{//\ Tests\ that\ SafeMatcherCast<T>(m)\ works\ when\ m\ is\ a\ Matcher<U>\ where}}
\DoxyCodeLine{00732\ \textcolor{comment}{//\ T\ and\ U\ are\ arithmetic\ types\ and\ T\ can\ be\ losslessly\ converted\ to}}
\DoxyCodeLine{00733\ \textcolor{comment}{//\ U.}}
\DoxyCodeLine{00734\ TEST(SafeMatcherCastTest,\ FromLosslesslyConvertibleArithmeticType)\ \{}
\DoxyCodeLine{00735\ \ \ Matcher<double>\ m1\ =\ DoubleEq(1.0);}
\DoxyCodeLine{00736\ \ \ Matcher<float>\ m2\ =\ SafeMatcherCast<float>(m1);}
\DoxyCodeLine{00737\ \ \ EXPECT\_TRUE(m2.Matches(1.0f));}
\DoxyCodeLine{00738\ \ \ EXPECT\_FALSE(m2.Matches(2.0f));}
\DoxyCodeLine{00739\ }
\DoxyCodeLine{00740\ \ \ Matcher<char>\ m3\ =\ SafeMatcherCast<char>(TypedEq<int>(\textcolor{charliteral}{'a'}));}
\DoxyCodeLine{00741\ \ \ EXPECT\_TRUE(m3.Matches(\textcolor{charliteral}{'a'}));}
\DoxyCodeLine{00742\ \ \ EXPECT\_FALSE(m3.Matches(\textcolor{charliteral}{'b'}));}
\DoxyCodeLine{00743\ \}}
\DoxyCodeLine{00744\ }
\DoxyCodeLine{00745\ \textcolor{comment}{//\ Tests\ that\ SafeMatcherCast<T>(m)\ works\ when\ m\ is\ a\ Matcher<U>\ where\ T\ and\ U}}
\DoxyCodeLine{00746\ \textcolor{comment}{//\ are\ pointers\ or\ references\ to\ a\ derived\ and\ a\ base\ class,\ correspondingly.}}
\DoxyCodeLine{00747\ TEST(SafeMatcherCastTest,\ FromBaseClass)\ \{}
\DoxyCodeLine{00748\ \ \ Derived\ d,\ d2;}
\DoxyCodeLine{00749\ \ \ Matcher<Base*>\ m1\ =\ Eq(\&d);}
\DoxyCodeLine{00750\ \ \ Matcher<Derived*>\ m2\ =\ SafeMatcherCast<Derived*>(m1);}
\DoxyCodeLine{00751\ \ \ EXPECT\_TRUE(m2.Matches(\&d));}
\DoxyCodeLine{00752\ \ \ EXPECT\_FALSE(m2.Matches(\&d2));}
\DoxyCodeLine{00753\ }
\DoxyCodeLine{00754\ \ \ Matcher<Base\&>\ m3\ =\ Ref(d);}
\DoxyCodeLine{00755\ \ \ Matcher<Derived\&>\ m4\ =\ SafeMatcherCast<Derived\&>(m3);}
\DoxyCodeLine{00756\ \ \ EXPECT\_TRUE(m4.Matches(d));}
\DoxyCodeLine{00757\ \ \ EXPECT\_FALSE(m4.Matches(d2));}
\DoxyCodeLine{00758\ \}}
\DoxyCodeLine{00759\ }
\DoxyCodeLine{00760\ \textcolor{comment}{//\ Tests\ that\ SafeMatcherCast<T\&>(m)\ works\ when\ m\ is\ a\ Matcher<const\ T\&>.}}
\DoxyCodeLine{00761\ TEST(SafeMatcherCastTest,\ FromConstReferenceToReference)\ \{}
\DoxyCodeLine{00762\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{00763\ \ \ Matcher<const\ int\&>\ m1\ =\ Ref(n);}
\DoxyCodeLine{00764\ \ \ Matcher<int\&>\ m2\ =\ SafeMatcherCast<int\&>(m1);}
\DoxyCodeLine{00765\ \ \ \textcolor{keywordtype}{int}\ n1\ =\ 0;}
\DoxyCodeLine{00766\ \ \ EXPECT\_TRUE(m2.Matches(n));}
\DoxyCodeLine{00767\ \ \ EXPECT\_FALSE(m2.Matches(n1));}
\DoxyCodeLine{00768\ \}}
\DoxyCodeLine{00769\ }
\DoxyCodeLine{00770\ \textcolor{comment}{//\ Tests\ that\ MatcherCast<const\ T\&>(m)\ works\ when\ m\ is\ a\ Matcher<T>.}}
\DoxyCodeLine{00771\ TEST(SafeMatcherCastTest,\ FromNonReferenceToConstReference)\ \{}
\DoxyCodeLine{00772\ \ \ Matcher<std::unique\_ptr<int>>\ m1\ =\ IsNull();}
\DoxyCodeLine{00773\ \ \ Matcher<const\ std::unique\_ptr<int>\&>\ m2\ =}
\DoxyCodeLine{00774\ \ \ \ \ \ \ SafeMatcherCast<const\ std::unique\_ptr<int>\&>(m1);}
\DoxyCodeLine{00775\ \ \ EXPECT\_TRUE(m2.Matches(std::unique\_ptr<int>()));}
\DoxyCodeLine{00776\ \ \ EXPECT\_FALSE(m2.Matches(std::unique\_ptr<int>(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int})));}
\DoxyCodeLine{00777\ \}}
\DoxyCodeLine{00778\ }
\DoxyCodeLine{00779\ \textcolor{comment}{//\ Tests\ that\ SafeMatcherCast<T\&>(m)\ works\ when\ m\ is\ a\ Matcher<T>.}}
\DoxyCodeLine{00780\ TEST(SafeMatcherCastTest,\ FromNonReferenceToReference)\ \{}
\DoxyCodeLine{00781\ \ \ Matcher<int>\ m1\ =\ Eq(0);}
\DoxyCodeLine{00782\ \ \ Matcher<int\&>\ m2\ =\ SafeMatcherCast<int\&>(m1);}
\DoxyCodeLine{00783\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{00784\ \ \ EXPECT\_TRUE(m2.Matches(n));}
\DoxyCodeLine{00785\ \ \ n\ =\ 1;}
\DoxyCodeLine{00786\ \ \ EXPECT\_FALSE(m2.Matches(n));}
\DoxyCodeLine{00787\ \}}
\DoxyCodeLine{00788\ }
\DoxyCodeLine{00789\ \textcolor{comment}{//\ Tests\ that\ SafeMatcherCast<T>(m)\ works\ when\ m\ is\ a\ Matcher<T>.}}
\DoxyCodeLine{00790\ TEST(SafeMatcherCastTest,\ FromSameType)\ \{}
\DoxyCodeLine{00791\ \ \ Matcher<int>\ m1\ =\ Eq(0);}
\DoxyCodeLine{00792\ \ \ Matcher<int>\ m2\ =\ SafeMatcherCast<int>(m1);}
\DoxyCodeLine{00793\ \ \ EXPECT\_TRUE(m2.Matches(0));}
\DoxyCodeLine{00794\ \ \ EXPECT\_FALSE(m2.Matches(1));}
\DoxyCodeLine{00795\ \}}
\DoxyCodeLine{00796\ }
\DoxyCodeLine{00797\ \textcolor{preprocessor}{\#if\ !defined\ \_MSC\_VER}}
\DoxyCodeLine{00798\ }
\DoxyCodeLine{00799\ \textcolor{keyword}{namespace\ }convertible\_from\_any\ \{}
\DoxyCodeLine{00800\ TEST(SafeMatcherCastTest,\ ConversionConstructorIsUsed)\ \{}
\DoxyCodeLine{00801\ \ \ Matcher<ConvertibleFromAny>\ m\ =\ SafeMatcherCast<ConvertibleFromAny>(1);}
\DoxyCodeLine{00802\ \ \ EXPECT\_TRUE(m.Matches(ConvertibleFromAny(1)));}
\DoxyCodeLine{00803\ \ \ EXPECT\_FALSE(m.Matches(ConvertibleFromAny(2)));}
\DoxyCodeLine{00804\ \}}
\DoxyCodeLine{00805\ }
\DoxyCodeLine{00806\ TEST(SafeMatcherCastTest,\ FromConvertibleFromAny)\ \{}
\DoxyCodeLine{00807\ \ \ Matcher<ConvertibleFromAny>\ m\ =}
\DoxyCodeLine{00808\ \ \ \ \ \ \ SafeMatcherCast<ConvertibleFromAny>(Eq(ConvertibleFromAny(1)));}
\DoxyCodeLine{00809\ \ \ EXPECT\_TRUE(m.Matches(ConvertibleFromAny(1)));}
\DoxyCodeLine{00810\ \ \ EXPECT\_FALSE(m.Matches(ConvertibleFromAny(2)));}
\DoxyCodeLine{00811\ \}}
\DoxyCodeLine{00812\ \}\ \ \textcolor{comment}{//\ namespace\ convertible\_from\_any}}
\DoxyCodeLine{00813\ }
\DoxyCodeLine{00814\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ !defined\ \_MSC\_VER}}
\DoxyCodeLine{00815\ }
\DoxyCodeLine{00816\ TEST(SafeMatcherCastTest,\ ValueIsNotCopied)\ \{}
\DoxyCodeLine{00817\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 42;}
\DoxyCodeLine{00818\ \ \ Matcher<IntReferenceWrapper>\ m\ =\ SafeMatcherCast<IntReferenceWrapper>(n);}
\DoxyCodeLine{00819\ \ \ \textcolor{comment}{//\ Verify\ that\ the\ matcher\ holds\ a\ reference\ to\ n,\ not\ to\ its\ temporary\ copy.}}
\DoxyCodeLine{00820\ \ \ EXPECT\_TRUE(m.Matches(n));}
\DoxyCodeLine{00821\ \}}
\DoxyCodeLine{00822\ }
\DoxyCodeLine{00823\ TEST(ExpectThat,\ TakesLiterals)\ \{}
\DoxyCodeLine{00824\ \ \ EXPECT\_THAT(1,\ 1);}
\DoxyCodeLine{00825\ \ \ EXPECT\_THAT(1.0,\ 1.0);}
\DoxyCodeLine{00826\ \ \ EXPECT\_THAT(std::string(),\ \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{00827\ \}}
\DoxyCodeLine{00828\ }
\DoxyCodeLine{00829\ TEST(ExpectThat,\ TakesFunctions)\ \{}
\DoxyCodeLine{00830\ \ \ \textcolor{keyword}{struct\ }Helper\ \{}
\DoxyCodeLine{00831\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ Func()\ \{\}}
\DoxyCodeLine{00832\ \ \ \};}
\DoxyCodeLine{00833\ \ \ void\ (*func)()\ =\ Helper::Func;}
\DoxyCodeLine{00834\ \ \ EXPECT\_THAT(func,\ Helper::Func);}
\DoxyCodeLine{00835\ \ \ EXPECT\_THAT(func,\ \&Helper::Func);}
\DoxyCodeLine{00836\ \}}
\DoxyCodeLine{00837\ }
\DoxyCodeLine{00838\ \textcolor{comment}{//\ Tests\ that\ A<T>()\ matches\ any\ value\ of\ type\ T.}}
\DoxyCodeLine{00839\ TEST(ATest,\ MatchesAnyValue)\ \{}
\DoxyCodeLine{00840\ \ \ \textcolor{comment}{//\ Tests\ a\ matcher\ for\ a\ value\ type.}}
\DoxyCodeLine{00841\ \ \ Matcher<double>\ m1\ =\ A<double>();}
\DoxyCodeLine{00842\ \ \ EXPECT\_TRUE(m1.Matches(91.43));}
\DoxyCodeLine{00843\ \ \ EXPECT\_TRUE(m1.Matches(-\/15.32));}
\DoxyCodeLine{00844\ }
\DoxyCodeLine{00845\ \ \ \textcolor{comment}{//\ Tests\ a\ matcher\ for\ a\ reference\ type.}}
\DoxyCodeLine{00846\ \ \ \textcolor{keywordtype}{int}\ a\ =\ 2;}
\DoxyCodeLine{00847\ \ \ \textcolor{keywordtype}{int}\ b\ =\ -\/6;}
\DoxyCodeLine{00848\ \ \ Matcher<int\&>\ m2\ =\ A<int\&>();}
\DoxyCodeLine{00849\ \ \ EXPECT\_TRUE(m2.Matches(a));}
\DoxyCodeLine{00850\ \ \ EXPECT\_TRUE(m2.Matches(b));}
\DoxyCodeLine{00851\ \}}
\DoxyCodeLine{00852\ }
\DoxyCodeLine{00853\ TEST(ATest,\ WorksForDerivedClass)\ \{}
\DoxyCodeLine{00854\ \ \ Base\ base;}
\DoxyCodeLine{00855\ \ \ Derived\ derived;}
\DoxyCodeLine{00856\ \ \ EXPECT\_THAT(\&base,\ A<Base*>());}
\DoxyCodeLine{00857\ \ \ \textcolor{comment}{//\ This\ shouldn't\ compile:\ EXPECT\_THAT(\&base,\ A<Derived*>());}}
\DoxyCodeLine{00858\ \ \ EXPECT\_THAT(\&derived,\ A<Base*>());}
\DoxyCodeLine{00859\ \ \ EXPECT\_THAT(\&derived,\ A<Derived*>());}
\DoxyCodeLine{00860\ \}}
\DoxyCodeLine{00861\ }
\DoxyCodeLine{00862\ \textcolor{comment}{//\ Tests\ that\ A<T>()\ describes\ itself\ properly.}}
\DoxyCodeLine{00863\ TEST(ATest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{00864\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ anything"{}},\ Describe(A<bool>()));}
\DoxyCodeLine{00865\ \}}
\DoxyCodeLine{00866\ }
\DoxyCodeLine{00867\ \textcolor{comment}{//\ Tests\ that\ An<T>()\ matches\ any\ value\ of\ type\ T.}}
\DoxyCodeLine{00868\ TEST(AnTest,\ MatchesAnyValue)\ \{}
\DoxyCodeLine{00869\ \ \ \textcolor{comment}{//\ Tests\ a\ matcher\ for\ a\ value\ type.}}
\DoxyCodeLine{00870\ \ \ Matcher<int>\ m1\ =\ An<int>();}
\DoxyCodeLine{00871\ \ \ EXPECT\_TRUE(m1.Matches(9143));}
\DoxyCodeLine{00872\ \ \ EXPECT\_TRUE(m1.Matches(-\/1532));}
\DoxyCodeLine{00873\ }
\DoxyCodeLine{00874\ \ \ \textcolor{comment}{//\ Tests\ a\ matcher\ for\ a\ reference\ type.}}
\DoxyCodeLine{00875\ \ \ \textcolor{keywordtype}{int}\ a\ =\ 2;}
\DoxyCodeLine{00876\ \ \ \textcolor{keywordtype}{int}\ b\ =\ -\/6;}
\DoxyCodeLine{00877\ \ \ Matcher<int\&>\ m2\ =\ An<int\&>();}
\DoxyCodeLine{00878\ \ \ EXPECT\_TRUE(m2.Matches(a));}
\DoxyCodeLine{00879\ \ \ EXPECT\_TRUE(m2.Matches(b));}
\DoxyCodeLine{00880\ \}}
\DoxyCodeLine{00881\ }
\DoxyCodeLine{00882\ \textcolor{comment}{//\ Tests\ that\ An<T>()\ describes\ itself\ properly.}}
\DoxyCodeLine{00883\ TEST(AnTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{00884\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ anything"{}},\ Describe(An<int>()));}
\DoxyCodeLine{00885\ \}}
\DoxyCodeLine{00886\ }
\DoxyCodeLine{00887\ \textcolor{comment}{//\ Tests\ that\ \_\ can\ be\ used\ as\ a\ matcher\ for\ any\ type\ and\ matches\ any}}
\DoxyCodeLine{00888\ \textcolor{comment}{//\ value\ of\ that\ type.}}
\DoxyCodeLine{00889\ TEST(UnderscoreTest,\ MatchesAnyValue)\ \{}
\DoxyCodeLine{00890\ \ \ \textcolor{comment}{//\ Uses\ \_\ as\ a\ matcher\ for\ a\ value\ type.}}
\DoxyCodeLine{00891\ \ \ Matcher<int>\ m1\ =\ \_;}
\DoxyCodeLine{00892\ \ \ EXPECT\_TRUE(m1.Matches(123));}
\DoxyCodeLine{00893\ \ \ EXPECT\_TRUE(m1.Matches(-\/242));}
\DoxyCodeLine{00894\ }
\DoxyCodeLine{00895\ \ \ \textcolor{comment}{//\ Uses\ \_\ as\ a\ matcher\ for\ a\ reference\ type.}}
\DoxyCodeLine{00896\ \ \ \textcolor{keywordtype}{bool}\ a\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00897\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ b\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00898\ \ \ Matcher<const\ bool\&>\ m2\ =\ \_;}
\DoxyCodeLine{00899\ \ \ EXPECT\_TRUE(m2.Matches(a));}
\DoxyCodeLine{00900\ \ \ EXPECT\_TRUE(m2.Matches(b));}
\DoxyCodeLine{00901\ \}}
\DoxyCodeLine{00902\ }
\DoxyCodeLine{00903\ \textcolor{comment}{//\ Tests\ that\ \_\ describes\ itself\ properly.}}
\DoxyCodeLine{00904\ TEST(UnderscoreTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{00905\ \ \ Matcher<int>\ m\ =\ \_;}
\DoxyCodeLine{00906\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ anything"{}},\ Describe(m));}
\DoxyCodeLine{00907\ \}}
\DoxyCodeLine{00908\ }
\DoxyCodeLine{00909\ \textcolor{comment}{//\ Tests\ that\ Eq(x)\ matches\ any\ value\ equal\ to\ x.}}
\DoxyCodeLine{00910\ TEST(EqTest,\ MatchesEqualValue)\ \{}
\DoxyCodeLine{00911\ \ \ \textcolor{comment}{//\ 2\ C-\/strings\ with\ same\ content\ but\ different\ addresses.}}
\DoxyCodeLine{00912\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ a1[]\ =\ \textcolor{stringliteral}{"{}hi"{}};}
\DoxyCodeLine{00913\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ a2[]\ =\ \textcolor{stringliteral}{"{}hi"{}};}
\DoxyCodeLine{00914\ }
\DoxyCodeLine{00915\ \ \ Matcher<const\ char*>\ m1\ =\ Eq(a1);}
\DoxyCodeLine{00916\ \ \ EXPECT\_TRUE(m1.Matches(a1));}
\DoxyCodeLine{00917\ \ \ EXPECT\_FALSE(m1.Matches(a2));}
\DoxyCodeLine{00918\ \}}
\DoxyCodeLine{00919\ }
\DoxyCodeLine{00920\ \textcolor{comment}{//\ Tests\ that\ Eq(v)\ describes\ itself\ properly.}}
\DoxyCodeLine{00921\ }
\DoxyCodeLine{00922\ \textcolor{keyword}{class\ }Unprintable\ \{}
\DoxyCodeLine{00923\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00924\ \ \ Unprintable()\ :\ c\_(\textcolor{stringliteral}{'a'})\ \{\}}
\DoxyCodeLine{00925\ }
\DoxyCodeLine{00926\ \ \ \textcolor{keywordtype}{bool}\ operator==(\textcolor{keyword}{const}\ Unprintable\&\ \textcolor{comment}{/*\ rhs\ */})\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{00927\ \ \ \textcolor{comment}{//\ -\/Wunused-\/private-\/field:\ dummy\ accessor\ for\ \`{}c\_`.}}
\DoxyCodeLine{00928\ \ \ \textcolor{keywordtype}{char}\ dummy\_c()\ \{\ \textcolor{keywordflow}{return}\ c\_;\ \}}
\DoxyCodeLine{00929\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00930\ \ \ \textcolor{keywordtype}{char}\ c\_;}
\DoxyCodeLine{00931\ \};}
\DoxyCodeLine{00932\ }
\DoxyCodeLine{00933\ TEST(EqTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{00934\ \ \ Matcher<Unprintable>\ m\ =\ Eq(Unprintable());}
\DoxyCodeLine{00935\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ 1-\/byte\ object\ <61>"{}},\ Describe(m));}
\DoxyCodeLine{00936\ \}}
\DoxyCodeLine{00937\ }
\DoxyCodeLine{00938\ \textcolor{comment}{//\ Tests\ that\ Eq(v)\ can\ be\ used\ to\ match\ any\ type\ that\ supports}}
\DoxyCodeLine{00939\ \textcolor{comment}{//\ comparing\ with\ type\ T,\ where\ T\ is\ v's\ type.}}
\DoxyCodeLine{00940\ TEST(EqTest,\ IsPolymorphic)\ \{}
\DoxyCodeLine{00941\ \ \ Matcher<int>\ m1\ =\ Eq(1);}
\DoxyCodeLine{00942\ \ \ EXPECT\_TRUE(m1.Matches(1));}
\DoxyCodeLine{00943\ \ \ EXPECT\_FALSE(m1.Matches(2));}
\DoxyCodeLine{00944\ }
\DoxyCodeLine{00945\ \ \ Matcher<char>\ m2\ =\ Eq(1);}
\DoxyCodeLine{00946\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{charliteral}{'\(\backslash\)1'}));}
\DoxyCodeLine{00947\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{charliteral}{'a'}));}
\DoxyCodeLine{00948\ \}}
\DoxyCodeLine{00949\ }
\DoxyCodeLine{00950\ \textcolor{comment}{//\ Tests\ that\ TypedEq<T>(v)\ matches\ values\ of\ type\ T\ that's\ equal\ to\ v.}}
\DoxyCodeLine{00951\ TEST(TypedEqTest,\ ChecksEqualityForGivenType)\ \{}
\DoxyCodeLine{00952\ \ \ Matcher<char>\ m1\ =\ TypedEq<char>(\textcolor{charliteral}{'a'});}
\DoxyCodeLine{00953\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{charliteral}{'a'}));}
\DoxyCodeLine{00954\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{charliteral}{'b'}));}
\DoxyCodeLine{00955\ }
\DoxyCodeLine{00956\ \ \ Matcher<int>\ m2\ =\ TypedEq<int>(6);}
\DoxyCodeLine{00957\ \ \ EXPECT\_TRUE(m2.Matches(6));}
\DoxyCodeLine{00958\ \ \ EXPECT\_FALSE(m2.Matches(7));}
\DoxyCodeLine{00959\ \}}
\DoxyCodeLine{00960\ }
\DoxyCodeLine{00961\ \textcolor{comment}{//\ Tests\ that\ TypedEq(v)\ describes\ itself\ properly.}}
\DoxyCodeLine{00962\ TEST(TypedEqTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{00963\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ 2"{}},\ Describe(TypedEq<int>(2)));}
\DoxyCodeLine{00964\ \}}
\DoxyCodeLine{00965\ }
\DoxyCodeLine{00966\ \textcolor{comment}{//\ Tests\ that\ TypedEq<T>(v)\ has\ type\ Matcher<T>.}}
\DoxyCodeLine{00967\ }
\DoxyCodeLine{00968\ \textcolor{comment}{//\ Type<T>::IsTypeOf(v)\ compiles\ if\ and\ only\ if\ the\ type\ of\ value\ v\ is\ T,\ where}}
\DoxyCodeLine{00969\ \textcolor{comment}{//\ T\ is\ a\ "{}bare"{}\ type\ (i.e.\ not\ in\ the\ form\ of\ const\ U\ or\ U\&).\ \ If\ v's\ type\ is}}
\DoxyCodeLine{00970\ \textcolor{comment}{//\ not\ T,\ the\ compiler\ will\ generate\ a\ message\ about\ "{}undefined\ reference"{}.}}
\DoxyCodeLine{00971\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00972\ \textcolor{keyword}{struct\ }Type\ \{}
\DoxyCodeLine{00973\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{bool}\ IsTypeOf(\textcolor{keyword}{const}\ T\&\ \textcolor{comment}{/*\ v\ */})\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{00974\ }
\DoxyCodeLine{00975\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{00976\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ IsTypeOf(T2\ v);}
\DoxyCodeLine{00977\ \};}
\DoxyCodeLine{00978\ }
\DoxyCodeLine{00979\ TEST(TypedEqTest,\ HasSpecifiedType)\ \{}
\DoxyCodeLine{00980\ \ \ \textcolor{comment}{//\ Verfies\ that\ the\ type\ of\ TypedEq<T>(v)\ is\ Matcher<T>.}}
\DoxyCodeLine{00981\ \ \ Type<Matcher<int>\ >::IsTypeOf(TypedEq<int>(5));}
\DoxyCodeLine{00982\ \ \ Type<Matcher<double>\ >::IsTypeOf(TypedEq<double>(5));}
\DoxyCodeLine{00983\ \}}
\DoxyCodeLine{00984\ }
\DoxyCodeLine{00985\ \textcolor{comment}{//\ Tests\ that\ Ge(v)\ matches\ anything\ >=\ v.}}
\DoxyCodeLine{00986\ TEST(GeTest,\ ImplementsGreaterThanOrEqual)\ \{}
\DoxyCodeLine{00987\ \ \ Matcher<int>\ m1\ =\ Ge(0);}
\DoxyCodeLine{00988\ \ \ EXPECT\_TRUE(m1.Matches(1));}
\DoxyCodeLine{00989\ \ \ EXPECT\_TRUE(m1.Matches(0));}
\DoxyCodeLine{00990\ \ \ EXPECT\_FALSE(m1.Matches(-\/1));}
\DoxyCodeLine{00991\ \}}
\DoxyCodeLine{00992\ }
\DoxyCodeLine{00993\ \textcolor{comment}{//\ Tests\ that\ Ge(v)\ describes\ itself\ properly.}}
\DoxyCodeLine{00994\ TEST(GeTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{00995\ \ \ Matcher<int>\ m\ =\ Ge(5);}
\DoxyCodeLine{00996\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ >=\ 5"{}},\ Describe(m));}
\DoxyCodeLine{00997\ \}}
\DoxyCodeLine{00998\ }
\DoxyCodeLine{00999\ \textcolor{comment}{//\ Tests\ that\ Gt(v)\ matches\ anything\ >\ v.}}
\DoxyCodeLine{01000\ TEST(GtTest,\ ImplementsGreaterThan)\ \{}
\DoxyCodeLine{01001\ \ \ Matcher<double>\ m1\ =\ Gt(0);}
\DoxyCodeLine{01002\ \ \ EXPECT\_TRUE(m1.Matches(1.0));}
\DoxyCodeLine{01003\ \ \ EXPECT\_FALSE(m1.Matches(0.0));}
\DoxyCodeLine{01004\ \ \ EXPECT\_FALSE(m1.Matches(-\/1.0));}
\DoxyCodeLine{01005\ \}}
\DoxyCodeLine{01006\ }
\DoxyCodeLine{01007\ \textcolor{comment}{//\ Tests\ that\ Gt(v)\ describes\ itself\ properly.}}
\DoxyCodeLine{01008\ TEST(GtTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01009\ \ \ Matcher<int>\ m\ =\ Gt(5);}
\DoxyCodeLine{01010\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ >\ 5"{}},\ Describe(m));}
\DoxyCodeLine{01011\ \}}
\DoxyCodeLine{01012\ }
\DoxyCodeLine{01013\ \textcolor{comment}{//\ Tests\ that\ Le(v)\ matches\ anything\ <=\ v.}}
\DoxyCodeLine{01014\ TEST(LeTest,\ ImplementsLessThanOrEqual)\ \{}
\DoxyCodeLine{01015\ \ \ Matcher<char>\ m1\ =\ Le(\textcolor{charliteral}{'b'});}
\DoxyCodeLine{01016\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{charliteral}{'a'}));}
\DoxyCodeLine{01017\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{charliteral}{'b'}));}
\DoxyCodeLine{01018\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{charliteral}{'c'}));}
\DoxyCodeLine{01019\ \}}
\DoxyCodeLine{01020\ }
\DoxyCodeLine{01021\ \textcolor{comment}{//\ Tests\ that\ Le(v)\ describes\ itself\ properly.}}
\DoxyCodeLine{01022\ TEST(LeTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01023\ \ \ Matcher<int>\ m\ =\ Le(5);}
\DoxyCodeLine{01024\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ <=\ 5"{}},\ Describe(m));}
\DoxyCodeLine{01025\ \}}
\DoxyCodeLine{01026\ }
\DoxyCodeLine{01027\ \textcolor{comment}{//\ Tests\ that\ Lt(v)\ matches\ anything\ <\ v.}}
\DoxyCodeLine{01028\ TEST(LtTest,\ ImplementsLessThan)\ \{}
\DoxyCodeLine{01029\ \ \ Matcher<const\ std::string\&>\ m1\ =\ Lt(\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{01030\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}Abc"{}}));}
\DoxyCodeLine{01031\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01032\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}Hello,\ world!"{}}));}
\DoxyCodeLine{01033\ \}}
\DoxyCodeLine{01034\ }
\DoxyCodeLine{01035\ \textcolor{comment}{//\ Tests\ that\ Lt(v)\ describes\ itself\ properly.}}
\DoxyCodeLine{01036\ TEST(LtTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01037\ \ \ Matcher<int>\ m\ =\ Lt(5);}
\DoxyCodeLine{01038\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ <\ 5"{}},\ Describe(m));}
\DoxyCodeLine{01039\ \}}
\DoxyCodeLine{01040\ }
\DoxyCodeLine{01041\ \textcolor{comment}{//\ Tests\ that\ Ne(v)\ matches\ anything\ !=\ v.}}
\DoxyCodeLine{01042\ TEST(NeTest,\ ImplementsNotEqual)\ \{}
\DoxyCodeLine{01043\ \ \ Matcher<int>\ m1\ =\ Ne(0);}
\DoxyCodeLine{01044\ \ \ EXPECT\_TRUE(m1.Matches(1));}
\DoxyCodeLine{01045\ \ \ EXPECT\_TRUE(m1.Matches(-\/1));}
\DoxyCodeLine{01046\ \ \ EXPECT\_FALSE(m1.Matches(0));}
\DoxyCodeLine{01047\ \}}
\DoxyCodeLine{01048\ }
\DoxyCodeLine{01049\ \textcolor{comment}{//\ Tests\ that\ Ne(v)\ describes\ itself\ properly.}}
\DoxyCodeLine{01050\ TEST(NeTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01051\ \ \ Matcher<int>\ m\ =\ Ne(5);}
\DoxyCodeLine{01052\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ equal\ to\ 5"{}},\ Describe(m));}
\DoxyCodeLine{01053\ \}}
\DoxyCodeLine{01054\ }
\DoxyCodeLine{01055\ \textcolor{keyword}{class\ }MoveOnly\ \{}
\DoxyCodeLine{01056\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{01057\ \ \ \textcolor{keyword}{explicit}\ MoveOnly(\textcolor{keywordtype}{int}\ i)\ :\ i\_(i)\ \{\}}
\DoxyCodeLine{01058\ \ \ MoveOnly(\textcolor{keyword}{const}\ MoveOnly\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{01059\ \ \ MoveOnly(MoveOnly\&\&)\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{01060\ \ \ MoveOnly\&\ operator=(\textcolor{keyword}{const}\ MoveOnly\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{01061\ \ \ MoveOnly\&\ operator=(MoveOnly\&\&)\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{01062\ }
\DoxyCodeLine{01063\ \ \ \textcolor{keywordtype}{bool}\ operator==(\textcolor{keyword}{const}\ MoveOnly\&\ other)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ i\_\ ==\ other.i\_;\ \}}
\DoxyCodeLine{01064\ \ \ \textcolor{keywordtype}{bool}\ operator!=(\textcolor{keyword}{const}\ MoveOnly\&\ other)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ i\_\ !=\ other.i\_;\ \}}
\DoxyCodeLine{01065\ \ \ \textcolor{keywordtype}{bool}\ operator<(\textcolor{keyword}{const}\ MoveOnly\&\ other)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ i\_\ <\ other.i\_;\ \}}
\DoxyCodeLine{01066\ \ \ \textcolor{keywordtype}{bool}\ operator<=(\textcolor{keyword}{const}\ MoveOnly\&\ other)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ i\_\ <=\ other.i\_;\ \}}
\DoxyCodeLine{01067\ \ \ \textcolor{keywordtype}{bool}\ operator>(\textcolor{keyword}{const}\ MoveOnly\&\ other)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ i\_\ >\ other.i\_;\ \}}
\DoxyCodeLine{01068\ \ \ \textcolor{keywordtype}{bool}\ operator>=(\textcolor{keyword}{const}\ MoveOnly\&\ other)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ i\_\ >=\ other.i\_;\ \}}
\DoxyCodeLine{01069\ }
\DoxyCodeLine{01070\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{01071\ \ \ \textcolor{keywordtype}{int}\ i\_;}
\DoxyCodeLine{01072\ \};}
\DoxyCodeLine{01073\ }
\DoxyCodeLine{01074\ \textcolor{keyword}{struct\ }MoveHelper\ \{}
\DoxyCodeLine{01075\ \ \ MOCK\_METHOD1(Call,\ \textcolor{keywordtype}{void}(MoveOnly));}
\DoxyCodeLine{01076\ \};}
\DoxyCodeLine{01077\ }
\DoxyCodeLine{01078\ \textcolor{comment}{//\ Disable\ this\ test\ in\ VS\ 2015\ (version\ 14),\ where\ it\ fails\ when\ SEH\ is\ enabled}}
\DoxyCodeLine{01079\ \textcolor{preprocessor}{\#if\ defined(\_MSC\_VER)\ \&\&\ (\_MSC\_VER\ <\ 1910)}}
\DoxyCodeLine{01080\ TEST(ComparisonBaseTest,\ DISABLED\_WorksWithMoveOnly)\ \{}
\DoxyCodeLine{01081\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01082\ TEST(ComparisonBaseTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{01083\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01084\ \ \ MoveOnly\ m\{0\};}
\DoxyCodeLine{01085\ \ \ MoveHelper\ helper;}
\DoxyCodeLine{01086\ }
\DoxyCodeLine{01087\ \ \ EXPECT\_CALL(helper,\ Call(Eq(ByRef(m))));}
\DoxyCodeLine{01088\ \ \ helper.Call(MoveOnly(0));}
\DoxyCodeLine{01089\ \ \ EXPECT\_CALL(helper,\ Call(Ne(ByRef(m))));}
\DoxyCodeLine{01090\ \ \ helper.Call(MoveOnly(1));}
\DoxyCodeLine{01091\ \ \ EXPECT\_CALL(helper,\ Call(Le(ByRef(m))));}
\DoxyCodeLine{01092\ \ \ helper.Call(MoveOnly(0));}
\DoxyCodeLine{01093\ \ \ EXPECT\_CALL(helper,\ Call(Lt(ByRef(m))));}
\DoxyCodeLine{01094\ \ \ helper.Call(MoveOnly(-\/1));}
\DoxyCodeLine{01095\ \ \ EXPECT\_CALL(helper,\ Call(Ge(ByRef(m))));}
\DoxyCodeLine{01096\ \ \ helper.Call(MoveOnly(0));}
\DoxyCodeLine{01097\ \ \ EXPECT\_CALL(helper,\ Call(Gt(ByRef(m))));}
\DoxyCodeLine{01098\ \ \ helper.Call(MoveOnly(1));}
\DoxyCodeLine{01099\ \}}
\DoxyCodeLine{01100\ }
\DoxyCodeLine{01101\ \textcolor{comment}{//\ Tests\ that\ IsNull()\ matches\ any\ NULL\ pointer\ of\ any\ type.}}
\DoxyCodeLine{01102\ TEST(IsNullTest,\ MatchesNullPointer)\ \{}
\DoxyCodeLine{01103\ \ \ Matcher<int*>\ m1\ =\ IsNull();}
\DoxyCodeLine{01104\ \ \ \textcolor{keywordtype}{int}*\ p1\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01105\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{01106\ \ \ EXPECT\_TRUE(m1.Matches(p1));}
\DoxyCodeLine{01107\ \ \ EXPECT\_FALSE(m1.Matches(\&n));}
\DoxyCodeLine{01108\ }
\DoxyCodeLine{01109\ \ \ Matcher<const\ char*>\ m2\ =\ IsNull();}
\DoxyCodeLine{01110\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ p2\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01111\ \ \ EXPECT\_TRUE(m2.Matches(p2));}
\DoxyCodeLine{01112\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{01113\ }
\DoxyCodeLine{01114\ \ \ Matcher<void*>\ m3\ =\ IsNull();}
\DoxyCodeLine{01115\ \ \ \textcolor{keywordtype}{void}*\ p3\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01116\ \ \ EXPECT\_TRUE(m3.Matches(p3));}
\DoxyCodeLine{01117\ \ \ EXPECT\_FALSE(m3.Matches(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(0xbeef)));}
\DoxyCodeLine{01118\ \}}
\DoxyCodeLine{01119\ }
\DoxyCodeLine{01120\ TEST(IsNullTest,\ StdFunction)\ \{}
\DoxyCodeLine{01121\ \ \ \textcolor{keyword}{const}\ Matcher<std::function<void()>>\ m\ =\ IsNull();}
\DoxyCodeLine{01122\ }
\DoxyCodeLine{01123\ \ \ EXPECT\_TRUE(m.Matches(std::function<\textcolor{keywordtype}{void}()>()));}
\DoxyCodeLine{01124\ \ \ EXPECT\_FALSE(m.Matches([]\{\}));}
\DoxyCodeLine{01125\ \}}
\DoxyCodeLine{01126\ }
\DoxyCodeLine{01127\ \textcolor{comment}{//\ Tests\ that\ IsNull()\ describes\ itself\ properly.}}
\DoxyCodeLine{01128\ TEST(IsNullTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01129\ \ \ Matcher<int*>\ m\ =\ IsNull();}
\DoxyCodeLine{01130\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ NULL"{}},\ Describe(m));}
\DoxyCodeLine{01131\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NULL"{}},\ DescribeNegation(m));}
\DoxyCodeLine{01132\ \}}
\DoxyCodeLine{01133\ }
\DoxyCodeLine{01134\ \textcolor{comment}{//\ Tests\ that\ NotNull()\ matches\ any\ non-\/NULL\ pointer\ of\ any\ type.}}
\DoxyCodeLine{01135\ TEST(NotNullTest,\ MatchesNonNullPointer)\ \{}
\DoxyCodeLine{01136\ \ \ Matcher<int*>\ m1\ =\ NotNull();}
\DoxyCodeLine{01137\ \ \ \textcolor{keywordtype}{int}*\ p1\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01138\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{01139\ \ \ EXPECT\_FALSE(m1.Matches(p1));}
\DoxyCodeLine{01140\ \ \ EXPECT\_TRUE(m1.Matches(\&n));}
\DoxyCodeLine{01141\ }
\DoxyCodeLine{01142\ \ \ Matcher<const\ char*>\ m2\ =\ NotNull();}
\DoxyCodeLine{01143\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ p2\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01144\ \ \ EXPECT\_FALSE(m2.Matches(p2));}
\DoxyCodeLine{01145\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{01146\ \}}
\DoxyCodeLine{01147\ }
\DoxyCodeLine{01148\ TEST(NotNullTest,\ LinkedPtr)\ \{}
\DoxyCodeLine{01149\ \ \ \textcolor{keyword}{const}\ Matcher<std::shared\_ptr<int>>\ m\ =\ NotNull();}
\DoxyCodeLine{01150\ \ \ \textcolor{keyword}{const}\ std::shared\_ptr<int>\ null\_p;}
\DoxyCodeLine{01151\ \ \ \textcolor{keyword}{const}\ std::shared\_ptr<int>\ non\_null\_p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int});}
\DoxyCodeLine{01152\ }
\DoxyCodeLine{01153\ \ \ EXPECT\_FALSE(m.Matches(null\_p));}
\DoxyCodeLine{01154\ \ \ EXPECT\_TRUE(m.Matches(non\_null\_p));}
\DoxyCodeLine{01155\ \}}
\DoxyCodeLine{01156\ }
\DoxyCodeLine{01157\ TEST(NotNullTest,\ ReferenceToConstLinkedPtr)\ \{}
\DoxyCodeLine{01158\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::shared\_ptr<double>\&>\ m\ =\ NotNull();}
\DoxyCodeLine{01159\ \ \ \textcolor{keyword}{const}\ std::shared\_ptr<double>\ null\_p;}
\DoxyCodeLine{01160\ \ \ \textcolor{keyword}{const}\ std::shared\_ptr<double>\ non\_null\_p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{double});}
\DoxyCodeLine{01161\ }
\DoxyCodeLine{01162\ \ \ EXPECT\_FALSE(m.Matches(null\_p));}
\DoxyCodeLine{01163\ \ \ EXPECT\_TRUE(m.Matches(non\_null\_p));}
\DoxyCodeLine{01164\ \}}
\DoxyCodeLine{01165\ }
\DoxyCodeLine{01166\ TEST(NotNullTest,\ StdFunction)\ \{}
\DoxyCodeLine{01167\ \ \ \textcolor{keyword}{const}\ Matcher<std::function<void()>>\ m\ =\ NotNull();}
\DoxyCodeLine{01168\ }
\DoxyCodeLine{01169\ \ \ EXPECT\_TRUE(m.Matches([]\{\}));}
\DoxyCodeLine{01170\ \ \ EXPECT\_FALSE(m.Matches(std::function<\textcolor{keywordtype}{void}()>()));}
\DoxyCodeLine{01171\ \}}
\DoxyCodeLine{01172\ }
\DoxyCodeLine{01173\ \textcolor{comment}{//\ Tests\ that\ NotNull()\ describes\ itself\ properly.}}
\DoxyCodeLine{01174\ TEST(NotNullTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01175\ \ \ Matcher<int*>\ m\ =\ NotNull();}
\DoxyCodeLine{01176\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NULL"{}},\ Describe(m));}
\DoxyCodeLine{01177\ \}}
\DoxyCodeLine{01178\ }
\DoxyCodeLine{01179\ \textcolor{comment}{//\ Tests\ that\ Ref(variable)\ matches\ an\ argument\ that\ references}}
\DoxyCodeLine{01180\ \textcolor{comment}{//\ 'variable'.}}
\DoxyCodeLine{01181\ TEST(RefTest,\ MatchesSameVariable)\ \{}
\DoxyCodeLine{01182\ \ \ \textcolor{keywordtype}{int}\ a\ =\ 0;}
\DoxyCodeLine{01183\ \ \ \textcolor{keywordtype}{int}\ b\ =\ 0;}
\DoxyCodeLine{01184\ \ \ Matcher<int\&>\ m\ =\ Ref(a);}
\DoxyCodeLine{01185\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{01186\ \ \ EXPECT\_FALSE(m.Matches(b));}
\DoxyCodeLine{01187\ \}}
\DoxyCodeLine{01188\ }
\DoxyCodeLine{01189\ \textcolor{comment}{//\ Tests\ that\ Ref(variable)\ describes\ itself\ properly.}}
\DoxyCodeLine{01190\ TEST(RefTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01191\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 5;}
\DoxyCodeLine{01192\ \ \ Matcher<int\&>\ m\ =\ Ref(n);}
\DoxyCodeLine{01193\ \ \ stringstream\ ss;}
\DoxyCodeLine{01194\ \ \ ss\ <<\ \textcolor{stringliteral}{"{}references\ the\ variable\ @"{}}\ <<\ \&n\ <<\ \textcolor{stringliteral}{"{}\ 5"{}};}
\DoxyCodeLine{01195\ \ \ EXPECT\_EQ(ss.str(),\ Describe(m));}
\DoxyCodeLine{01196\ \}}
\DoxyCodeLine{01197\ }
\DoxyCodeLine{01198\ \textcolor{comment}{//\ Test\ that\ Ref(non\_const\_varialbe)\ can\ be\ used\ as\ a\ matcher\ for\ a}}
\DoxyCodeLine{01199\ \textcolor{comment}{//\ const\ reference.}}
\DoxyCodeLine{01200\ TEST(RefTest,\ CanBeUsedAsMatcherForConstReference)\ \{}
\DoxyCodeLine{01201\ \ \ \textcolor{keywordtype}{int}\ a\ =\ 0;}
\DoxyCodeLine{01202\ \ \ \textcolor{keywordtype}{int}\ b\ =\ 0;}
\DoxyCodeLine{01203\ \ \ Matcher<const\ int\&>\ m\ =\ Ref(a);}
\DoxyCodeLine{01204\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{01205\ \ \ EXPECT\_FALSE(m.Matches(b));}
\DoxyCodeLine{01206\ \}}
\DoxyCodeLine{01207\ }
\DoxyCodeLine{01208\ \textcolor{comment}{//\ Tests\ that\ Ref(variable)\ is\ covariant,\ i.e.\ Ref(derived)\ can\ be}}
\DoxyCodeLine{01209\ \textcolor{comment}{//\ used\ wherever\ Ref(base)\ can\ be\ used\ (Ref(derived)\ is\ a\ sub-\/type}}
\DoxyCodeLine{01210\ \textcolor{comment}{//\ of\ Ref(base),\ but\ not\ vice\ versa.}}
\DoxyCodeLine{01211\ }
\DoxyCodeLine{01212\ TEST(RefTest,\ IsCovariant)\ \{}
\DoxyCodeLine{01213\ \ \ Base\ base,\ base2;}
\DoxyCodeLine{01214\ \ \ Derived\ derived;}
\DoxyCodeLine{01215\ \ \ Matcher<const\ Base\&>\ m1\ =\ Ref(base);}
\DoxyCodeLine{01216\ \ \ EXPECT\_TRUE(m1.Matches(base));}
\DoxyCodeLine{01217\ \ \ EXPECT\_FALSE(m1.Matches(base2));}
\DoxyCodeLine{01218\ \ \ EXPECT\_FALSE(m1.Matches(derived));}
\DoxyCodeLine{01219\ }
\DoxyCodeLine{01220\ \ \ m1\ =\ Ref(derived);}
\DoxyCodeLine{01221\ \ \ EXPECT\_TRUE(m1.Matches(derived));}
\DoxyCodeLine{01222\ \ \ EXPECT\_FALSE(m1.Matches(base));}
\DoxyCodeLine{01223\ \ \ EXPECT\_FALSE(m1.Matches(base2));}
\DoxyCodeLine{01224\ \}}
\DoxyCodeLine{01225\ }
\DoxyCodeLine{01226\ TEST(RefTest,\ ExplainsResult)\ \{}
\DoxyCodeLine{01227\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{01228\ \ \ EXPECT\_THAT(Explain(Matcher<const\ int\&>(Ref(n)),\ n),}
\DoxyCodeLine{01229\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ StartsWith(\textcolor{stringliteral}{"{}which\ is\ located\ @"{}}));}
\DoxyCodeLine{01230\ }
\DoxyCodeLine{01231\ \ \ \textcolor{keywordtype}{int}\ m\ =\ 0;}
\DoxyCodeLine{01232\ \ \ EXPECT\_THAT(Explain(Matcher<const\ int\&>(Ref(n)),\ m),}
\DoxyCodeLine{01233\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ StartsWith(\textcolor{stringliteral}{"{}which\ is\ located\ @"{}}));}
\DoxyCodeLine{01234\ \}}
\DoxyCodeLine{01235\ }
\DoxyCodeLine{01236\ \textcolor{comment}{//\ Tests\ string\ comparison\ matchers.}}
\DoxyCodeLine{01237\ }
\DoxyCodeLine{01238\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T\ =\ std::\textcolor{keywordtype}{string}>}
\DoxyCodeLine{01239\ std::string\ FromStringLike(internal::StringLike<T>\ str)\ \{}
\DoxyCodeLine{01240\ \ \ \textcolor{keywordflow}{return}\ std::string(str);}
\DoxyCodeLine{01241\ \}}
\DoxyCodeLine{01242\ }
\DoxyCodeLine{01243\ TEST(StringLike,\ TestConversions)\ \{}
\DoxyCodeLine{01244\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}foo"{}},\ FromStringLike(\textcolor{stringliteral}{"{}foo"{}}));}
\DoxyCodeLine{01245\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}foo"{}},\ FromStringLike(std::string(\textcolor{stringliteral}{"{}foo"{}})));}
\DoxyCodeLine{01246\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01247\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}foo"{}},\ FromStringLike(internal::StringView(\textcolor{stringliteral}{"{}foo"{}})));}
\DoxyCodeLine{01248\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01249\ }
\DoxyCodeLine{01250\ \ \ \textcolor{comment}{//\ Non\ deducible\ types.}}
\DoxyCodeLine{01251\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ FromStringLike(\{\}));}
\DoxyCodeLine{01252\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}foo"{}},\ FromStringLike(\{\textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'o'},\ \textcolor{charliteral}{'o'}\}));}
\DoxyCodeLine{01253\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ buf[]\ =\ \textcolor{stringliteral}{"{}foo"{}};}
\DoxyCodeLine{01254\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}foo"{}},\ FromStringLike(\{buf,\ buf\ +\ 3\}));}
\DoxyCodeLine{01255\ \}}
\DoxyCodeLine{01256\ }
\DoxyCodeLine{01257\ TEST(StrEqTest,\ MatchesEqualString)\ \{}
\DoxyCodeLine{01258\ \ \ Matcher<const\ char*>\ m\ =\ StrEq(std::string(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01259\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01260\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{01261\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01262\ }
\DoxyCodeLine{01263\ \ \ Matcher<const\ std::string\&>\ m2\ =\ StrEq(\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{01264\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01265\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01266\ }
\DoxyCodeLine{01267\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01268\ \ \ Matcher<const\ internal::StringView\&>\ m3\ =}
\DoxyCodeLine{01269\ \ \ \ \ \ \ StrEq(internal::StringView(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01270\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}Hello"{}})));}
\DoxyCodeLine{01271\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}hello"{}})));}
\DoxyCodeLine{01272\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView()));}
\DoxyCodeLine{01273\ }
\DoxyCodeLine{01274\ \ \ Matcher<const\ internal::StringView\&>\ m\_empty\ =\ StrEq(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{01275\ \ \ EXPECT\_TRUE(m\_empty.Matches(internal::StringView(\textcolor{stringliteral}{"{}"{}})));}
\DoxyCodeLine{01276\ \ \ EXPECT\_TRUE(m\_empty.Matches(internal::StringView()));}
\DoxyCodeLine{01277\ \ \ EXPECT\_FALSE(m\_empty.Matches(internal::StringView(\textcolor{stringliteral}{"{}hello"{}})));}
\DoxyCodeLine{01278\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01279\ \}}
\DoxyCodeLine{01280\ }
\DoxyCodeLine{01281\ TEST(StrEqTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01282\ \ \ Matcher<std::string>\ m\ =\ StrEq(\textcolor{stringliteral}{"{}Hi-\/\(\backslash\)'\(\backslash\)"{}?\(\backslash\)\(\backslash\)\(\backslash\)a\(\backslash\)b\(\backslash\)f\(\backslash\)n\(\backslash\)r\(\backslash\)t\(\backslash\)v\(\backslash\)xD3"{}});}
\DoxyCodeLine{01283\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ \(\backslash\)"{}Hi-\/\(\backslash\)'\(\backslash\)\(\backslash\)\(\backslash\)"{}?\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)f\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)r\(\backslash\)\(\backslash\)t\(\backslash\)\(\backslash\)v\(\backslash\)\(\backslash\)xD3\(\backslash\)"{}"{}},}
\DoxyCodeLine{01284\ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{01285\ }
\DoxyCodeLine{01286\ \ \ std::string\ str(\textcolor{stringliteral}{"{}01204500800"{}});}
\DoxyCodeLine{01287\ \ \ str[3]\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{01288\ \ \ Matcher<std::string>\ m2\ =\ StrEq(str);}
\DoxyCodeLine{01289\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ \(\backslash\)"{}012\(\backslash\)\(\backslash\)04500800\(\backslash\)"{}"{}},\ Describe(m2));}
\DoxyCodeLine{01290\ \ \ str[0]\ =\ str[6]\ =\ str[7]\ =\ str[9]\ =\ str[10]\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{01291\ \ \ Matcher<std::string>\ m3\ =\ StrEq(str);}
\DoxyCodeLine{01292\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ \(\backslash\)"{}\(\backslash\)\(\backslash\)012\(\backslash\)\(\backslash\)045\(\backslash\)\(\backslash\)0\(\backslash\)\(\backslash\)08\(\backslash\)\(\backslash\)0\(\backslash\)\(\backslash\)0\(\backslash\)"{}"{}},\ Describe(m3));}
\DoxyCodeLine{01293\ \}}
\DoxyCodeLine{01294\ }
\DoxyCodeLine{01295\ TEST(StrNeTest,\ MatchesUnequalString)\ \{}
\DoxyCodeLine{01296\ \ \ Matcher<const\ char*>\ m\ =\ StrNe(\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{01297\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01298\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01299\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01300\ }
\DoxyCodeLine{01301\ \ \ Matcher<std::string>\ m2\ =\ StrNe(std::string(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01302\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{01303\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01304\ }
\DoxyCodeLine{01305\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01306\ \ \ Matcher<const\ internal::StringView>\ m3\ =\ StrNe(internal::StringView(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01307\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}"{}})));}
\DoxyCodeLine{01308\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView()));}
\DoxyCodeLine{01309\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}Hello"{}})));}
\DoxyCodeLine{01310\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01311\ \}}
\DoxyCodeLine{01312\ }
\DoxyCodeLine{01313\ TEST(StrNeTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01314\ \ \ Matcher<const\ char*>\ m\ =\ StrNe(\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{01315\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ equal\ to\ \(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{01316\ \}}
\DoxyCodeLine{01317\ }
\DoxyCodeLine{01318\ TEST(StrCaseEqTest,\ MatchesEqualStringIgnoringCase)\ \{}
\DoxyCodeLine{01319\ \ \ Matcher<const\ char*>\ m\ =\ StrCaseEq(std::string(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01320\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01321\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{01322\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01323\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01324\ }
\DoxyCodeLine{01325\ \ \ Matcher<const\ std::string\&>\ m2\ =\ StrCaseEq(\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{01326\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{01327\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01328\ }
\DoxyCodeLine{01329\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01330\ \ \ Matcher<const\ internal::StringView\&>\ m3\ =}
\DoxyCodeLine{01331\ \ \ \ \ \ \ StrCaseEq(internal::StringView(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01332\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}Hello"{}})));}
\DoxyCodeLine{01333\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}hello"{}})));}
\DoxyCodeLine{01334\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}Hi"{}})));}
\DoxyCodeLine{01335\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView()));}
\DoxyCodeLine{01336\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01337\ \}}
\DoxyCodeLine{01338\ }
\DoxyCodeLine{01339\ TEST(StrCaseEqTest,\ MatchesEqualStringWith0IgnoringCase)\ \{}
\DoxyCodeLine{01340\ \ \ std::string\ str1(\textcolor{stringliteral}{"{}oabocdooeoo"{}});}
\DoxyCodeLine{01341\ \ \ std::string\ str2(\textcolor{stringliteral}{"{}OABOCDOOEOO"{}});}
\DoxyCodeLine{01342\ \ \ Matcher<const\ std::string\&>\ m0\ =\ StrCaseEq(str1);}
\DoxyCodeLine{01343\ \ \ EXPECT\_FALSE(m0.Matches(str2\ +\ std::string(1,\ \textcolor{charliteral}{'\(\backslash\)0'})));}
\DoxyCodeLine{01344\ }
\DoxyCodeLine{01345\ \ \ str1[3]\ =\ str2[3]\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{01346\ \ \ Matcher<const\ std::string\&>\ m1\ =\ StrCaseEq(str1);}
\DoxyCodeLine{01347\ \ \ EXPECT\_TRUE(m1.Matches(str2));}
\DoxyCodeLine{01348\ }
\DoxyCodeLine{01349\ \ \ str1[0]\ =\ str1[6]\ =\ str1[7]\ =\ str1[10]\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{01350\ \ \ str2[0]\ =\ str2[6]\ =\ str2[7]\ =\ str2[10]\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{01351\ \ \ Matcher<const\ std::string\&>\ m2\ =\ StrCaseEq(str1);}
\DoxyCodeLine{01352\ \ \ str1[9]\ =\ str2[9]\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{01353\ \ \ EXPECT\_FALSE(m2.Matches(str2));}
\DoxyCodeLine{01354\ }
\DoxyCodeLine{01355\ \ \ Matcher<const\ std::string\&>\ m3\ =\ StrCaseEq(str1);}
\DoxyCodeLine{01356\ \ \ EXPECT\_TRUE(m3.Matches(str2));}
\DoxyCodeLine{01357\ }
\DoxyCodeLine{01358\ \ \ EXPECT\_FALSE(m3.Matches(str2\ +\ \textcolor{stringliteral}{"{}x"{}}));}
\DoxyCodeLine{01359\ \ \ str2.append(1,\ \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{01360\ \ \ EXPECT\_FALSE(m3.Matches(str2));}
\DoxyCodeLine{01361\ \ \ EXPECT\_FALSE(m3.Matches(std::string(str2,\ 0,\ 9)));}
\DoxyCodeLine{01362\ \}}
\DoxyCodeLine{01363\ }
\DoxyCodeLine{01364\ TEST(StrCaseEqTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01365\ \ \ Matcher<std::string>\ m\ =\ StrCaseEq(\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{01366\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ (ignoring\ case)\ \(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{01367\ \}}
\DoxyCodeLine{01368\ }
\DoxyCodeLine{01369\ TEST(StrCaseNeTest,\ MatchesUnequalStringIgnoringCase)\ \{}
\DoxyCodeLine{01370\ \ \ Matcher<const\ char*>\ m\ =\ StrCaseNe(\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{01371\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01372\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01373\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01374\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{01375\ }
\DoxyCodeLine{01376\ \ \ Matcher<std::string>\ m2\ =\ StrCaseNe(std::string(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01377\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01378\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01379\ }
\DoxyCodeLine{01380\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01381\ \ \ Matcher<const\ internal::StringView>\ m3\ =}
\DoxyCodeLine{01382\ \ \ \ \ \ \ StrCaseNe(internal::StringView(\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01383\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}Hi"{}})));}
\DoxyCodeLine{01384\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView()));}
\DoxyCodeLine{01385\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}Hello"{}})));}
\DoxyCodeLine{01386\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}hello"{}})));}
\DoxyCodeLine{01387\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01388\ \}}
\DoxyCodeLine{01389\ }
\DoxyCodeLine{01390\ TEST(StrCaseNeTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01391\ \ \ Matcher<const\ char*>\ m\ =\ StrCaseNe(\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{01392\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ equal\ to\ (ignoring\ case)\ \(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{01393\ \}}
\DoxyCodeLine{01394\ }
\DoxyCodeLine{01395\ \textcolor{comment}{//\ Tests\ that\ HasSubstr()\ works\ for\ matching\ string-\/typed\ values.}}
\DoxyCodeLine{01396\ TEST(HasSubstrTest,\ WorksForStringClasses)\ \{}
\DoxyCodeLine{01397\ \ \ \textcolor{keyword}{const}\ Matcher<std::string>\ m1\ =\ HasSubstr(\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{01398\ \ \ EXPECT\_TRUE(m1.Matches(std::string(\textcolor{stringliteral}{"{}I\ love\ food."{}})));}
\DoxyCodeLine{01399\ \ \ EXPECT\_FALSE(m1.Matches(std::string(\textcolor{stringliteral}{"{}tofo"{}})));}
\DoxyCodeLine{01400\ }
\DoxyCodeLine{01401\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\ m2\ =\ HasSubstr(\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{01402\ \ \ EXPECT\_TRUE(m2.Matches(std::string(\textcolor{stringliteral}{"{}I\ love\ food."{}})));}
\DoxyCodeLine{01403\ \ \ EXPECT\_FALSE(m2.Matches(std::string(\textcolor{stringliteral}{"{}tofo"{}})));}
\DoxyCodeLine{01404\ }
\DoxyCodeLine{01405\ \ \ \textcolor{keyword}{const}\ Matcher<std::string>\ m\_empty\ =\ HasSubstr(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{01406\ \ \ EXPECT\_TRUE(m\_empty.Matches(std::string()));}
\DoxyCodeLine{01407\ \ \ EXPECT\_TRUE(m\_empty.Matches(std::string(\textcolor{stringliteral}{"{}not\ empty"{}})));}
\DoxyCodeLine{01408\ \}}
\DoxyCodeLine{01409\ }
\DoxyCodeLine{01410\ \textcolor{comment}{//\ Tests\ that\ HasSubstr()\ works\ for\ matching\ C-\/string-\/typed\ values.}}
\DoxyCodeLine{01411\ TEST(HasSubstrTest,\ WorksForCStrings)\ \{}
\DoxyCodeLine{01412\ \ \ \textcolor{keyword}{const}\ Matcher<char*>\ m1\ =\ HasSubstr(\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{01413\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\textcolor{stringliteral}{"{}I\ love\ food."{}})));}
\DoxyCodeLine{01414\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\textcolor{stringliteral}{"{}tofo"{}})));}
\DoxyCodeLine{01415\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01416\ }
\DoxyCodeLine{01417\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m2\ =\ HasSubstr(\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{01418\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}I\ love\ food."{}}));}
\DoxyCodeLine{01419\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}tofo"{}}));}
\DoxyCodeLine{01420\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01421\ }
\DoxyCodeLine{01422\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m\_empty\ =\ HasSubstr(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{01423\ \ \ EXPECT\_TRUE(m\_empty.Matches(\textcolor{stringliteral}{"{}not\ empty"{}}));}
\DoxyCodeLine{01424\ \ \ EXPECT\_TRUE(m\_empty.Matches(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01425\ \ \ EXPECT\_FALSE(m\_empty.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01426\ \}}
\DoxyCodeLine{01427\ }
\DoxyCodeLine{01428\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01429\ \textcolor{comment}{//\ Tests\ that\ HasSubstr()\ works\ for\ matching\ StringView-\/typed\ values.}}
\DoxyCodeLine{01430\ TEST(HasSubstrTest,\ WorksForStringViewClasses)\ \{}
\DoxyCodeLine{01431\ \ \ \textcolor{keyword}{const}\ Matcher<internal::StringView>\ m1\ =}
\DoxyCodeLine{01432\ \ \ \ \ \ \ HasSubstr(internal::StringView(\textcolor{stringliteral}{"{}foo"{}}));}
\DoxyCodeLine{01433\ \ \ EXPECT\_TRUE(m1.Matches(internal::StringView(\textcolor{stringliteral}{"{}I\ love\ food."{}})));}
\DoxyCodeLine{01434\ \ \ EXPECT\_FALSE(m1.Matches(internal::StringView(\textcolor{stringliteral}{"{}tofo"{}})));}
\DoxyCodeLine{01435\ \ \ EXPECT\_FALSE(m1.Matches(internal::StringView()));}
\DoxyCodeLine{01436\ }
\DoxyCodeLine{01437\ \ \ \textcolor{keyword}{const}\ Matcher<const\ internal::StringView\&>\ m2\ =\ HasSubstr(\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{01438\ \ \ EXPECT\_TRUE(m2.Matches(internal::StringView(\textcolor{stringliteral}{"{}I\ love\ food."{}})));}
\DoxyCodeLine{01439\ \ \ EXPECT\_FALSE(m2.Matches(internal::StringView(\textcolor{stringliteral}{"{}tofo"{}})));}
\DoxyCodeLine{01440\ \ \ EXPECT\_FALSE(m2.Matches(internal::StringView()));}
\DoxyCodeLine{01441\ }
\DoxyCodeLine{01442\ \ \ \textcolor{keyword}{const}\ Matcher<const\ internal::StringView\&>\ m3\ =\ HasSubstr(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{01443\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}foo"{}})));}
\DoxyCodeLine{01444\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}"{}})));}
\DoxyCodeLine{01445\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView()));}
\DoxyCodeLine{01446\ \}}
\DoxyCodeLine{01447\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01448\ }
\DoxyCodeLine{01449\ \textcolor{comment}{//\ Tests\ that\ HasSubstr(s)\ describes\ itself\ properly.}}
\DoxyCodeLine{01450\ TEST(HasSubstrTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01451\ \ \ Matcher<std::string>\ m\ =\ HasSubstr(\textcolor{stringliteral}{"{}foo\(\backslash\)n\(\backslash\)"{}"{}});}
\DoxyCodeLine{01452\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ substring\ \(\backslash\)"{}foo\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)\(\backslash\)"{}\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{01453\ \}}
\DoxyCodeLine{01454\ }
\DoxyCodeLine{01455\ TEST(KeyTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01456\ \ \ Matcher<const\ pair<std::string,\ int>\&>\ m\ =\ Key(\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{01457\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ a\ key\ that\ is\ equal\ to\ \(\backslash\)"{}foo\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{01458\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}doesn't\ have\ a\ key\ that\ is\ equal\ to\ \(\backslash\)"{}foo\(\backslash\)"{}"{}},\ DescribeNegation(m));}
\DoxyCodeLine{01459\ \}}
\DoxyCodeLine{01460\ }
\DoxyCodeLine{01461\ TEST(KeyTest,\ ExplainsResult)\ \{}
\DoxyCodeLine{01462\ \ \ Matcher<pair<int,\ bool>\ >\ m\ =\ Key(GreaterThan(10));}
\DoxyCodeLine{01463\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ first\ field\ is\ a\ value\ which\ is\ 5\ less\ than\ 10"{}},}
\DoxyCodeLine{01464\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ make\_pair(5,\ \textcolor{keyword}{true})));}
\DoxyCodeLine{01465\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ first\ field\ is\ a\ value\ which\ is\ 5\ more\ than\ 10"{}},}
\DoxyCodeLine{01466\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ make\_pair(15,\ \textcolor{keyword}{true})));}
\DoxyCodeLine{01467\ \}}
\DoxyCodeLine{01468\ }
\DoxyCodeLine{01469\ TEST(KeyTest,\ MatchesCorrectly)\ \{}
\DoxyCodeLine{01470\ \ \ pair<int,\ std::string>\ p(25,\ \textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{01471\ \ \ EXPECT\_THAT(p,\ Key(25));}
\DoxyCodeLine{01472\ \ \ EXPECT\_THAT(p,\ Not(Key(42)));}
\DoxyCodeLine{01473\ \ \ EXPECT\_THAT(p,\ Key(Ge(20)));}
\DoxyCodeLine{01474\ \ \ EXPECT\_THAT(p,\ Not(Key(Lt(25))));}
\DoxyCodeLine{01475\ \}}
\DoxyCodeLine{01476\ }
\DoxyCodeLine{01477\ TEST(KeyTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{01478\ \ \ pair<std::unique\_ptr<int>,\ std::unique\_ptr<int>>\ p;}
\DoxyCodeLine{01479\ \ \ EXPECT\_THAT(p,\ Key(Eq(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{01480\ \}}
\DoxyCodeLine{01481\ }
\DoxyCodeLine{01482\ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}\ I>}
\DoxyCodeLine{01483\ \textcolor{keyword}{struct\ }Tag\ \{\};}
\DoxyCodeLine{01484\ }
\DoxyCodeLine{01485\ \textcolor{keyword}{struct\ }PairWithGet\ \{}
\DoxyCodeLine{01486\ \ \ \textcolor{keywordtype}{int}\ member\_1;}
\DoxyCodeLine{01487\ \ \ std::string\ member\_2;}
\DoxyCodeLine{01488\ \ \ \textcolor{keyword}{using\ }first\_type\ =\ int;}
\DoxyCodeLine{01489\ \ \ \textcolor{keyword}{using\ }second\_type\ =\ std::string;}
\DoxyCodeLine{01490\ }
\DoxyCodeLine{01491\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\&\ GetImpl(Tag<0>)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ member\_1;\ \}}
\DoxyCodeLine{01492\ \ \ \textcolor{keyword}{const}\ std::string\&\ GetImpl(Tag<1>)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ member\_2;\ \}}
\DoxyCodeLine{01493\ \};}
\DoxyCodeLine{01494\ \textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}\ I>}
\DoxyCodeLine{01495\ \textcolor{keyword}{auto}\ get(\textcolor{keyword}{const}\ PairWithGet\&\ value)\ -\/>\ \textcolor{keyword}{decltype}(value.GetImpl(Tag<I>()))\ \{}
\DoxyCodeLine{01496\ \ \ \textcolor{keywordflow}{return}\ value.GetImpl(Tag<I>());}
\DoxyCodeLine{01497\ \}}
\DoxyCodeLine{01498\ TEST(PairTest,\ MatchesPairWithGetCorrectly)\ \{}
\DoxyCodeLine{01499\ \ \ PairWithGet\ p\{25,\ \textcolor{stringliteral}{"{}foo"{}}\};}
\DoxyCodeLine{01500\ \ \ EXPECT\_THAT(p,\ Key(25));}
\DoxyCodeLine{01501\ \ \ EXPECT\_THAT(p,\ Not(Key(42)));}
\DoxyCodeLine{01502\ \ \ EXPECT\_THAT(p,\ Key(Ge(20)));}
\DoxyCodeLine{01503\ \ \ EXPECT\_THAT(p,\ Not(Key(Lt(25))));}
\DoxyCodeLine{01504\ }
\DoxyCodeLine{01505\ \ \ std::vector<PairWithGet>\ v\ =\ \{\{11,\ \textcolor{stringliteral}{"{}Foo"{}}\},\ \{29,\ \textcolor{stringliteral}{"{}gMockIsBestMock"{}}\}\};}
\DoxyCodeLine{01506\ \ \ EXPECT\_THAT(v,\ Contains(Key(29)));}
\DoxyCodeLine{01507\ \}}
\DoxyCodeLine{01508\ }
\DoxyCodeLine{01509\ TEST(KeyTest,\ SafelyCastsInnerMatcher)\ \{}
\DoxyCodeLine{01510\ \ \ Matcher<int>\ is\_positive\ =\ Gt(0);}
\DoxyCodeLine{01511\ \ \ Matcher<int>\ is\_negative\ =\ Lt(0);}
\DoxyCodeLine{01512\ \ \ pair<char,\ bool>\ p(\textcolor{charliteral}{'a'},\ \textcolor{keyword}{true});}
\DoxyCodeLine{01513\ \ \ EXPECT\_THAT(p,\ Key(is\_positive));}
\DoxyCodeLine{01514\ \ \ EXPECT\_THAT(p,\ Not(Key(is\_negative)));}
\DoxyCodeLine{01515\ \}}
\DoxyCodeLine{01516\ }
\DoxyCodeLine{01517\ TEST(KeyTest,\ InsideContainsUsingMap)\ \{}
\DoxyCodeLine{01518\ \ \ map<int,\ char>\ container;}
\DoxyCodeLine{01519\ \ \ container.insert(make\_pair(1,\ \textcolor{charliteral}{'a'}));}
\DoxyCodeLine{01520\ \ \ container.insert(make\_pair(2,\ \textcolor{charliteral}{'b'}));}
\DoxyCodeLine{01521\ \ \ container.insert(make\_pair(4,\ \textcolor{charliteral}{'c'}));}
\DoxyCodeLine{01522\ \ \ EXPECT\_THAT(container,\ Contains(Key(1)));}
\DoxyCodeLine{01523\ \ \ EXPECT\_THAT(container,\ Not(Contains(Key(3))));}
\DoxyCodeLine{01524\ \}}
\DoxyCodeLine{01525\ }
\DoxyCodeLine{01526\ TEST(KeyTest,\ InsideContainsUsingMultimap)\ \{}
\DoxyCodeLine{01527\ \ \ multimap<int,\ char>\ container;}
\DoxyCodeLine{01528\ \ \ container.insert(make\_pair(1,\ \textcolor{charliteral}{'a'}));}
\DoxyCodeLine{01529\ \ \ container.insert(make\_pair(2,\ \textcolor{charliteral}{'b'}));}
\DoxyCodeLine{01530\ \ \ container.insert(make\_pair(4,\ \textcolor{charliteral}{'c'}));}
\DoxyCodeLine{01531\ }
\DoxyCodeLine{01532\ \ \ EXPECT\_THAT(container,\ Not(Contains(Key(25))));}
\DoxyCodeLine{01533\ \ \ container.insert(make\_pair(25,\ \textcolor{charliteral}{'d'}));}
\DoxyCodeLine{01534\ \ \ EXPECT\_THAT(container,\ Contains(Key(25)));}
\DoxyCodeLine{01535\ \ \ container.insert(make\_pair(25,\ \textcolor{charliteral}{'e'}));}
\DoxyCodeLine{01536\ \ \ EXPECT\_THAT(container,\ Contains(Key(25)));}
\DoxyCodeLine{01537\ }
\DoxyCodeLine{01538\ \ \ EXPECT\_THAT(container,\ Contains(Key(1)));}
\DoxyCodeLine{01539\ \ \ EXPECT\_THAT(container,\ Not(Contains(Key(3))));}
\DoxyCodeLine{01540\ \}}
\DoxyCodeLine{01541\ }
\DoxyCodeLine{01542\ TEST(PairTest,\ Typing)\ \{}
\DoxyCodeLine{01543\ \ \ \textcolor{comment}{//\ Test\ verifies\ the\ following\ type\ conversions\ can\ be\ compiled.}}
\DoxyCodeLine{01544\ \ \ Matcher<const\ pair<const\ char*,\ int>\&>\ m1\ =\ Pair(\textcolor{stringliteral}{"{}foo"{}},\ 42);}
\DoxyCodeLine{01545\ \ \ Matcher<const\ pair<const\ char*,\ int>\ >\ m2\ =\ Pair(\textcolor{stringliteral}{"{}foo"{}},\ 42);}
\DoxyCodeLine{01546\ \ \ Matcher<pair<const\ char*,\ int>\ >\ m3\ =\ Pair(\textcolor{stringliteral}{"{}foo"{}},\ 42);}
\DoxyCodeLine{01547\ }
\DoxyCodeLine{01548\ \ \ Matcher<pair<int,\ const\ std::string>\ >\ m4\ =\ Pair(25,\ \textcolor{stringliteral}{"{}42"{}});}
\DoxyCodeLine{01549\ \ \ Matcher<pair<const\ std::string,\ int>\ >\ m5\ =\ Pair(\textcolor{stringliteral}{"{}25"{}},\ 42);}
\DoxyCodeLine{01550\ \}}
\DoxyCodeLine{01551\ }
\DoxyCodeLine{01552\ TEST(PairTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01553\ \ \ Matcher<const\ pair<std::string,\ int>\&>\ m1\ =\ Pair(\textcolor{stringliteral}{"{}foo"{}},\ 42);}
\DoxyCodeLine{01554\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ a\ first\ field\ that\ is\ equal\ to\ \(\backslash\)"{}foo\(\backslash\)"{}"{}}}
\DoxyCodeLine{01555\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ and\ has\ a\ second\ field\ that\ is\ equal\ to\ 42"{}},}
\DoxyCodeLine{01556\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m1));}
\DoxyCodeLine{01557\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ a\ first\ field\ that\ isn't\ equal\ to\ \(\backslash\)"{}foo\(\backslash\)"{}"{}}}
\DoxyCodeLine{01558\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ or\ has\ a\ second\ field\ that\ isn't\ equal\ to\ 42"{}},}
\DoxyCodeLine{01559\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m1));}
\DoxyCodeLine{01560\ \ \ \textcolor{comment}{//\ Double\ and\ triple\ negation\ (1\ or\ 2\ times\ not\ and\ description\ of\ negation).}}
\DoxyCodeLine{01561\ \ \ Matcher<const\ pair<int,\ int>\&>\ m2\ =\ Not(Pair(Not(13),\ 42));}
\DoxyCodeLine{01562\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ a\ first\ field\ that\ isn't\ equal\ to\ 13"{}}}
\DoxyCodeLine{01563\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ and\ has\ a\ second\ field\ that\ is\ equal\ to\ 42"{}},}
\DoxyCodeLine{01564\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m2));}
\DoxyCodeLine{01565\ \}}
\DoxyCodeLine{01566\ }
\DoxyCodeLine{01567\ TEST(PairTest,\ CanExplainMatchResultTo)\ \{}
\DoxyCodeLine{01568\ \ \ \textcolor{comment}{//\ If\ neither\ field\ matches,\ Pair()\ should\ explain\ about\ the\ first}}
\DoxyCodeLine{01569\ \ \ \textcolor{comment}{//\ field.}}
\DoxyCodeLine{01570\ \ \ \textcolor{keyword}{const}\ Matcher<pair<int,\ int>\ >\ m\ =\ Pair(GreaterThan(0),\ GreaterThan(0));}
\DoxyCodeLine{01571\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ first\ field\ does\ not\ match,\ which\ is\ 1\ less\ than\ 0"{}},}
\DoxyCodeLine{01572\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ make\_pair(-\/1,\ -\/2)));}
\DoxyCodeLine{01573\ }
\DoxyCodeLine{01574\ \ \ \textcolor{comment}{//\ If\ the\ first\ field\ matches\ but\ the\ second\ doesn't,\ Pair()\ should}}
\DoxyCodeLine{01575\ \ \ \textcolor{comment}{//\ explain\ about\ the\ second\ field.}}
\DoxyCodeLine{01576\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ second\ field\ does\ not\ match,\ which\ is\ 2\ less\ than\ 0"{}},}
\DoxyCodeLine{01577\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ make\_pair(1,\ -\/2)));}
\DoxyCodeLine{01578\ }
\DoxyCodeLine{01579\ \ \ \textcolor{comment}{//\ If\ the\ first\ field\ doesn't\ match\ but\ the\ second\ does,\ Pair()}}
\DoxyCodeLine{01580\ \ \ \textcolor{comment}{//\ should\ explain\ about\ the\ first\ field.}}
\DoxyCodeLine{01581\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ first\ field\ does\ not\ match,\ which\ is\ 1\ less\ than\ 0"{}},}
\DoxyCodeLine{01582\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ make\_pair(-\/1,\ 2)));}
\DoxyCodeLine{01583\ }
\DoxyCodeLine{01584\ \ \ \textcolor{comment}{//\ If\ both\ fields\ match,\ Pair()\ should\ explain\ about\ them\ both.}}
\DoxyCodeLine{01585\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ both\ fields\ match,\ where\ the\ first\ field\ is\ a\ value\ "{}}}
\DoxyCodeLine{01586\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}which\ is\ 1\ more\ than\ 0,\ and\ the\ second\ field\ is\ a\ value\ "{}}}
\DoxyCodeLine{01587\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}which\ is\ 2\ more\ than\ 0"{}},}
\DoxyCodeLine{01588\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ make\_pair(1,\ 2)));}
\DoxyCodeLine{01589\ }
\DoxyCodeLine{01590\ \ \ \textcolor{comment}{//\ If\ only\ the\ first\ match\ has\ an\ explanation,\ only\ this\ explanation\ should}}
\DoxyCodeLine{01591\ \ \ \textcolor{comment}{//\ be\ printed.}}
\DoxyCodeLine{01592\ \ \ \textcolor{keyword}{const}\ Matcher<pair<int,\ int>\ >\ explain\_first\ =\ Pair(GreaterThan(0),\ 0);}
\DoxyCodeLine{01593\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ both\ fields\ match,\ where\ the\ first\ field\ is\ a\ value\ "{}}}
\DoxyCodeLine{01594\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{01595\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(explain\_first,\ make\_pair(1,\ 0)));}
\DoxyCodeLine{01596\ }
\DoxyCodeLine{01597\ \ \ \textcolor{comment}{//\ If\ only\ the\ second\ match\ has\ an\ explanation,\ only\ this\ explanation\ should}}
\DoxyCodeLine{01598\ \ \ \textcolor{comment}{//\ be\ printed.}}
\DoxyCodeLine{01599\ \ \ \textcolor{keyword}{const}\ Matcher<pair<int,\ int>\ >\ explain\_second\ =\ Pair(0,\ GreaterThan(0));}
\DoxyCodeLine{01600\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ both\ fields\ match,\ where\ the\ second\ field\ is\ a\ value\ "{}}}
\DoxyCodeLine{01601\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{01602\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(explain\_second,\ make\_pair(0,\ 1)));}
\DoxyCodeLine{01603\ \}}
\DoxyCodeLine{01604\ }
\DoxyCodeLine{01605\ TEST(PairTest,\ MatchesCorrectly)\ \{}
\DoxyCodeLine{01606\ \ \ pair<int,\ std::string>\ p(25,\ \textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{01607\ }
\DoxyCodeLine{01608\ \ \ \textcolor{comment}{//\ Both\ fields\ match.}}
\DoxyCodeLine{01609\ \ \ EXPECT\_THAT(p,\ Pair(25,\ \textcolor{stringliteral}{"{}foo"{}}));}
\DoxyCodeLine{01610\ \ \ EXPECT\_THAT(p,\ Pair(Ge(20),\ HasSubstr(\textcolor{stringliteral}{"{}o"{}})));}
\DoxyCodeLine{01611\ }
\DoxyCodeLine{01612\ \ \ \textcolor{comment}{//\ 'first'\ doesnt'\ match,\ but\ 'second'\ matches.}}
\DoxyCodeLine{01613\ \ \ EXPECT\_THAT(p,\ Not(Pair(42,\ \textcolor{stringliteral}{"{}foo"{}})));}
\DoxyCodeLine{01614\ \ \ EXPECT\_THAT(p,\ Not(Pair(Lt(25),\ \textcolor{stringliteral}{"{}foo"{}})));}
\DoxyCodeLine{01615\ }
\DoxyCodeLine{01616\ \ \ \textcolor{comment}{//\ 'first'\ matches,\ but\ 'second'\ doesn't\ match.}}
\DoxyCodeLine{01617\ \ \ EXPECT\_THAT(p,\ Not(Pair(25,\ \textcolor{stringliteral}{"{}bar"{}})));}
\DoxyCodeLine{01618\ \ \ EXPECT\_THAT(p,\ Not(Pair(25,\ Not(\textcolor{stringliteral}{"{}foo"{}}))));}
\DoxyCodeLine{01619\ }
\DoxyCodeLine{01620\ \ \ \textcolor{comment}{//\ Neither\ field\ matches.}}
\DoxyCodeLine{01621\ \ \ EXPECT\_THAT(p,\ Not(Pair(13,\ \textcolor{stringliteral}{"{}bar"{}})));}
\DoxyCodeLine{01622\ \ \ EXPECT\_THAT(p,\ Not(Pair(Lt(13),\ HasSubstr(\textcolor{stringliteral}{"{}a"{}}))));}
\DoxyCodeLine{01623\ \}}
\DoxyCodeLine{01624\ }
\DoxyCodeLine{01625\ TEST(PairTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{01626\ \ \ pair<std::unique\_ptr<int>,\ std::unique\_ptr<int>>\ p;}
\DoxyCodeLine{01627\ \ \ p.second.reset(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(7));}
\DoxyCodeLine{01628\ \ \ EXPECT\_THAT(p,\ Pair(Eq(\textcolor{keyword}{nullptr}),\ Ne(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{01629\ \}}
\DoxyCodeLine{01630\ }
\DoxyCodeLine{01631\ TEST(PairTest,\ SafelyCastsInnerMatchers)\ \{}
\DoxyCodeLine{01632\ \ \ Matcher<int>\ is\_positive\ =\ Gt(0);}
\DoxyCodeLine{01633\ \ \ Matcher<int>\ is\_negative\ =\ Lt(0);}
\DoxyCodeLine{01634\ \ \ pair<char,\ bool>\ p(\textcolor{charliteral}{'a'},\ \textcolor{keyword}{true});}
\DoxyCodeLine{01635\ \ \ EXPECT\_THAT(p,\ Pair(is\_positive,\ \_));}
\DoxyCodeLine{01636\ \ \ EXPECT\_THAT(p,\ Not(Pair(is\_negative,\ \_)));}
\DoxyCodeLine{01637\ \ \ EXPECT\_THAT(p,\ Pair(\_,\ is\_positive));}
\DoxyCodeLine{01638\ \ \ EXPECT\_THAT(p,\ Not(Pair(\_,\ is\_negative)));}
\DoxyCodeLine{01639\ \}}
\DoxyCodeLine{01640\ }
\DoxyCodeLine{01641\ TEST(PairTest,\ InsideContainsUsingMap)\ \{}
\DoxyCodeLine{01642\ \ \ map<int,\ char>\ container;}
\DoxyCodeLine{01643\ \ \ container.insert(make\_pair(1,\ \textcolor{charliteral}{'a'}));}
\DoxyCodeLine{01644\ \ \ container.insert(make\_pair(2,\ \textcolor{charliteral}{'b'}));}
\DoxyCodeLine{01645\ \ \ container.insert(make\_pair(4,\ \textcolor{charliteral}{'c'}));}
\DoxyCodeLine{01646\ \ \ EXPECT\_THAT(container,\ Contains(Pair(1,\ \textcolor{charliteral}{'a'})));}
\DoxyCodeLine{01647\ \ \ EXPECT\_THAT(container,\ Contains(Pair(1,\ \_)));}
\DoxyCodeLine{01648\ \ \ EXPECT\_THAT(container,\ Contains(Pair(\_,\ \textcolor{charliteral}{'a'})));}
\DoxyCodeLine{01649\ \ \ EXPECT\_THAT(container,\ Not(Contains(Pair(3,\ \_))));}
\DoxyCodeLine{01650\ \}}
\DoxyCodeLine{01651\ }
\DoxyCodeLine{01652\ TEST(FieldsAreTest,\ MatchesCorrectly)\ \{}
\DoxyCodeLine{01653\ \ \ std::tuple<int,\ std::string,\ double>\ p(25,\ \textcolor{stringliteral}{"{}foo"{}},\ .5);}
\DoxyCodeLine{01654\ }
\DoxyCodeLine{01655\ \ \ \textcolor{comment}{//\ All\ fields\ match.}}
\DoxyCodeLine{01656\ \ \ EXPECT\_THAT(p,\ FieldsAre(25,\ \textcolor{stringliteral}{"{}foo"{}},\ .5));}
\DoxyCodeLine{01657\ \ \ EXPECT\_THAT(p,\ FieldsAre(Ge(20),\ HasSubstr(\textcolor{stringliteral}{"{}o"{}}),\ DoubleEq(.5)));}
\DoxyCodeLine{01658\ }
\DoxyCodeLine{01659\ \ \ \textcolor{comment}{//\ Some\ don't\ match.}}
\DoxyCodeLine{01660\ \ \ EXPECT\_THAT(p,\ Not(FieldsAre(26,\ \textcolor{stringliteral}{"{}foo"{}},\ .5)));}
\DoxyCodeLine{01661\ \ \ EXPECT\_THAT(p,\ Not(FieldsAre(25,\ \textcolor{stringliteral}{"{}fo"{}},\ .5)));}
\DoxyCodeLine{01662\ \ \ EXPECT\_THAT(p,\ Not(FieldsAre(25,\ \textcolor{stringliteral}{"{}foo"{}},\ .6)));}
\DoxyCodeLine{01663\ \}}
\DoxyCodeLine{01664\ }
\DoxyCodeLine{01665\ TEST(FieldsAreTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01666\ \ \ Matcher<const\ pair<std::string,\ int>\&>\ m1\ =\ FieldsAre(\textcolor{stringliteral}{"{}foo"{}},\ 42);}
\DoxyCodeLine{01667\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{01668\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}has\ field\ \#0\ that\ is\ equal\ to\ \(\backslash\)"{}foo\(\backslash\)"{}"{}}}
\DoxyCodeLine{01669\ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ and\ has\ field\ \#1\ that\ is\ equal\ to\ 42"{}},}
\DoxyCodeLine{01670\ \ \ \ \ \ \ Describe(m1));}
\DoxyCodeLine{01671\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{01672\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}has\ field\ \#0\ that\ isn't\ equal\ to\ \(\backslash\)"{}foo\(\backslash\)"{}"{}}}
\DoxyCodeLine{01673\ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ or\ has\ field\ \#1\ that\ isn't\ equal\ to\ 42"{}},}
\DoxyCodeLine{01674\ \ \ \ \ \ \ DescribeNegation(m1));}
\DoxyCodeLine{01675\ \}}
\DoxyCodeLine{01676\ }
\DoxyCodeLine{01677\ TEST(FieldsAreTest,\ CanExplainMatchResultTo)\ \{}
\DoxyCodeLine{01678\ \ \ \textcolor{comment}{//\ The\ first\ one\ that\ fails\ is\ the\ one\ that\ gives\ the\ error.}}
\DoxyCodeLine{01679\ \ \ Matcher<std::tuple<int,\ int,\ int>>\ m\ =}
\DoxyCodeLine{01680\ \ \ \ \ \ \ FieldsAre(GreaterThan(0),\ GreaterThan(0),\ GreaterThan(0));}
\DoxyCodeLine{01681\ }
\DoxyCodeLine{01682\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ field\ \#0\ does\ not\ match,\ which\ is\ 1\ less\ than\ 0"{}},}
\DoxyCodeLine{01683\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(-\/1,\ -\/2,\ -\/3)));}
\DoxyCodeLine{01684\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ field\ \#1\ does\ not\ match,\ which\ is\ 2\ less\ than\ 0"{}},}
\DoxyCodeLine{01685\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(1,\ -\/2,\ -\/3)));}
\DoxyCodeLine{01686\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ field\ \#2\ does\ not\ match,\ which\ is\ 3\ less\ than\ 0"{}},}
\DoxyCodeLine{01687\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(1,\ 2,\ -\/3)));}
\DoxyCodeLine{01688\ }
\DoxyCodeLine{01689\ \ \ \textcolor{comment}{//\ If\ they\ all\ match,\ we\ get\ a\ long\ explanation\ of\ success.}}
\DoxyCodeLine{01690\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{01691\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ all\ elements\ match,\ "{}}}
\DoxyCodeLine{01692\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}where\ field\ \#0\ is\ a\ value\ which\ is\ 1\ more\ than\ 0"{}}}
\DoxyCodeLine{01693\ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ and\ field\ \#1\ is\ a\ value\ which\ is\ 2\ more\ than\ 0"{}}}
\DoxyCodeLine{01694\ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ and\ field\ \#2\ is\ a\ value\ which\ is\ 3\ more\ than\ 0"{}},}
\DoxyCodeLine{01695\ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(1,\ 2,\ 3)));}
\DoxyCodeLine{01696\ }
\DoxyCodeLine{01697\ \ \ \textcolor{comment}{//\ Only\ print\ those\ that\ have\ an\ explanation.}}
\DoxyCodeLine{01698\ \ \ m\ =\ FieldsAre(GreaterThan(0),\ 0,\ GreaterThan(0));}
\DoxyCodeLine{01699\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{01700\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ all\ elements\ match,\ "{}}}
\DoxyCodeLine{01701\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}where\ field\ \#0\ is\ a\ value\ which\ is\ 1\ more\ than\ 0"{}}}
\DoxyCodeLine{01702\ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ and\ field\ \#2\ is\ a\ value\ which\ is\ 3\ more\ than\ 0"{}},}
\DoxyCodeLine{01703\ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(1,\ 0,\ 3)));}
\DoxyCodeLine{01704\ }
\DoxyCodeLine{01705\ \ \ \textcolor{comment}{//\ If\ only\ one\ has\ an\ explanation,\ then\ print\ that\ one.}}
\DoxyCodeLine{01706\ \ \ m\ =\ FieldsAre(0,\ GreaterThan(0),\ 0);}
\DoxyCodeLine{01707\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{01708\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ all\ elements\ match,\ "{}}}
\DoxyCodeLine{01709\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}where\ field\ \#1\ is\ a\ value\ which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{01710\ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(0,\ 1,\ 0)));}
\DoxyCodeLine{01711\ \}}
\DoxyCodeLine{01712\ }
\DoxyCodeLine{01713\ \textcolor{preprocessor}{\#if\ defined(\_\_cpp\_structured\_bindings)\ \&\&\ \_\_cpp\_structured\_bindings\ >=\ 201606}}
\DoxyCodeLine{01714\ TEST(FieldsAreTest,\ StructuredBindings)\ \{}
\DoxyCodeLine{01715\ \ \ \textcolor{comment}{//\ testing::FieldsAre\ can\ also\ match\ aggregates\ and\ such\ with\ C++17\ and\ up.}}
\DoxyCodeLine{01716\ \ \ \textcolor{keyword}{struct\ }\mbox{\hyperlink{class_my_type}{MyType}}\ \{}
\DoxyCodeLine{01717\ \ \ \ \ \textcolor{keywordtype}{int}\ i;}
\DoxyCodeLine{01718\ \ \ \ \ std::string\ str;}
\DoxyCodeLine{01719\ \ \ \};}
\DoxyCodeLine{01720\ \ \ EXPECT\_THAT((\mbox{\hyperlink{class_my_type}{MyType}}\{17,\ \textcolor{stringliteral}{"{}foo"{}}\}),\ FieldsAre(Eq(17),\ HasSubstr(\textcolor{stringliteral}{"{}oo"{}})));}
\DoxyCodeLine{01721\ }
\DoxyCodeLine{01722\ \ \ \textcolor{comment}{//\ Test\ all\ the\ supported\ arities.}}
\DoxyCodeLine{01723\ \ \ \textcolor{keyword}{struct\ }MyVarType1\ \{}
\DoxyCodeLine{01724\ \ \ \ \ \textcolor{keywordtype}{int}\ a;}
\DoxyCodeLine{01725\ \ \ \};}
\DoxyCodeLine{01726\ \ \ EXPECT\_THAT(MyVarType1\{\},\ FieldsAre(0));}
\DoxyCodeLine{01727\ \ \ \textcolor{keyword}{struct\ }MyVarType2\ \{}
\DoxyCodeLine{01728\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b;}
\DoxyCodeLine{01729\ \ \ \};}
\DoxyCodeLine{01730\ \ \ EXPECT\_THAT(MyVarType2\{\},\ FieldsAre(0,\ 0));}
\DoxyCodeLine{01731\ \ \ \textcolor{keyword}{struct\ }MyVarType3\ \{}
\DoxyCodeLine{01732\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c;}
\DoxyCodeLine{01733\ \ \ \};}
\DoxyCodeLine{01734\ \ \ EXPECT\_THAT(MyVarType3\{\},\ FieldsAre(0,\ 0,\ 0));}
\DoxyCodeLine{01735\ \ \ \textcolor{keyword}{struct\ }MyVarType4\ \{}
\DoxyCodeLine{01736\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d;}
\DoxyCodeLine{01737\ \ \ \};}
\DoxyCodeLine{01738\ \ \ EXPECT\_THAT(MyVarType4\{\},\ FieldsAre(0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01739\ \ \ \textcolor{keyword}{struct\ }MyVarType5\ \{}
\DoxyCodeLine{01740\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e;}
\DoxyCodeLine{01741\ \ \ \};}
\DoxyCodeLine{01742\ \ \ EXPECT\_THAT(MyVarType5\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01743\ \ \ \textcolor{keyword}{struct\ }MyVarType6\ \{}
\DoxyCodeLine{01744\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f;}
\DoxyCodeLine{01745\ \ \ \};}
\DoxyCodeLine{01746\ \ \ EXPECT\_THAT(MyVarType6\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01747\ \ \ \textcolor{keyword}{struct\ }MyVarType7\ \{}
\DoxyCodeLine{01748\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g;}
\DoxyCodeLine{01749\ \ \ \};}
\DoxyCodeLine{01750\ \ \ EXPECT\_THAT(MyVarType7\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01751\ \ \ \textcolor{keyword}{struct\ }MyVarType8\ \{}
\DoxyCodeLine{01752\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h;}
\DoxyCodeLine{01753\ \ \ \};}
\DoxyCodeLine{01754\ \ \ EXPECT\_THAT(MyVarType8\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01755\ \ \ \textcolor{keyword}{struct\ }MyVarType9\ \{}
\DoxyCodeLine{01756\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i;}
\DoxyCodeLine{01757\ \ \ \};}
\DoxyCodeLine{01758\ \ \ EXPECT\_THAT(MyVarType9\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01759\ \ \ \textcolor{keyword}{struct\ }MyVarType10\ \{}
\DoxyCodeLine{01760\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j;}
\DoxyCodeLine{01761\ \ \ \};}
\DoxyCodeLine{01762\ \ \ EXPECT\_THAT(MyVarType10\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01763\ \ \ \textcolor{keyword}{struct\ }MyVarType11\ \{}
\DoxyCodeLine{01764\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k;}
\DoxyCodeLine{01765\ \ \ \};}
\DoxyCodeLine{01766\ \ \ EXPECT\_THAT(MyVarType11\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01767\ \ \ \textcolor{keyword}{struct\ }MyVarType12\ \{}
\DoxyCodeLine{01768\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l;}
\DoxyCodeLine{01769\ \ \ \};}
\DoxyCodeLine{01770\ \ \ EXPECT\_THAT(MyVarType12\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01771\ \ \ \textcolor{keyword}{struct\ }MyVarType13\ \{}
\DoxyCodeLine{01772\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m;}
\DoxyCodeLine{01773\ \ \ \};}
\DoxyCodeLine{01774\ \ \ EXPECT\_THAT(MyVarType13\{\},\ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01775\ \ \ \textcolor{keyword}{struct\ }MyVarType14\ \{}
\DoxyCodeLine{01776\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n;}
\DoxyCodeLine{01777\ \ \ \};}
\DoxyCodeLine{01778\ \ \ EXPECT\_THAT(MyVarType14\{\},}
\DoxyCodeLine{01779\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01780\ \ \ \textcolor{keyword}{struct\ }MyVarType15\ \{}
\DoxyCodeLine{01781\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o;}
\DoxyCodeLine{01782\ \ \ \};}
\DoxyCodeLine{01783\ \ \ EXPECT\_THAT(MyVarType15\{\},}
\DoxyCodeLine{01784\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01785\ \ \ \textcolor{keyword}{struct\ }MyVarType16\ \{}
\DoxyCodeLine{01786\ \ \ \ \ \textcolor{keywordtype}{int}\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ k,\ l,\ m,\ n,\ o,\ p;}
\DoxyCodeLine{01787\ \ \ \};}
\DoxyCodeLine{01788\ \ \ EXPECT\_THAT(MyVarType16\{\},}
\DoxyCodeLine{01789\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FieldsAre(0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0));}
\DoxyCodeLine{01790\ \}}
\DoxyCodeLine{01791\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01792\ }
\DoxyCodeLine{01793\ TEST(ContainsTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{01794\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{01795\ \ \ EXPECT\_CALL(helper,\ Call(Contains(Pointee(2))));}
\DoxyCodeLine{01796\ \ \ helper.Call(MakeUniquePtrs(\{1,\ 2\}));}
\DoxyCodeLine{01797\ \}}
\DoxyCodeLine{01798\ }
\DoxyCodeLine{01799\ TEST(PairTest,\ UseGetInsteadOfMembers)\ \{}
\DoxyCodeLine{01800\ \ \ PairWithGet\ pair\{7,\ \textcolor{stringliteral}{"{}ABC"{}}\};}
\DoxyCodeLine{01801\ \ \ EXPECT\_THAT(pair,\ Pair(7,\ \textcolor{stringliteral}{"{}ABC"{}}));}
\DoxyCodeLine{01802\ \ \ EXPECT\_THAT(pair,\ Pair(Ge(7),\ HasSubstr(\textcolor{stringliteral}{"{}AB"{}})));}
\DoxyCodeLine{01803\ \ \ EXPECT\_THAT(pair,\ Not(Pair(Lt(7),\ \textcolor{stringliteral}{"{}ABC"{}})));}
\DoxyCodeLine{01804\ }
\DoxyCodeLine{01805\ \ \ std::vector<PairWithGet>\ v\ =\ \{\{11,\ \textcolor{stringliteral}{"{}Foo"{}}\},\ \{29,\ \textcolor{stringliteral}{"{}gMockIsBestMock"{}}\}\};}
\DoxyCodeLine{01806\ \ \ EXPECT\_THAT(v,}
\DoxyCodeLine{01807\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(Pair(11,\ std::string(\textcolor{stringliteral}{"{}Foo"{}})),\ Pair(Ge(10),\ Not(\textcolor{stringliteral}{"{}"{}}))));}
\DoxyCodeLine{01808\ \}}
\DoxyCodeLine{01809\ }
\DoxyCodeLine{01810\ \textcolor{comment}{//\ Tests\ StartsWith(s).}}
\DoxyCodeLine{01811\ }
\DoxyCodeLine{01812\ TEST(StartsWithTest,\ MatchesStringWithGivenPrefix)\ \{}
\DoxyCodeLine{01813\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m1\ =\ StartsWith(std::string(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01814\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01815\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01816\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01817\ }
\DoxyCodeLine{01818\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\ m2\ =\ StartsWith(\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{01819\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01820\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}Hi\ Hi!"{}}));}
\DoxyCodeLine{01821\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}High"{}}));}
\DoxyCodeLine{01822\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}H"{}}));}
\DoxyCodeLine{01823\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}\ Hi"{}}));}
\DoxyCodeLine{01824\ }
\DoxyCodeLine{01825\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01826\ \ \ \textcolor{keyword}{const}\ Matcher<internal::StringView>\ m\_empty\ =}
\DoxyCodeLine{01827\ \ \ \ \ \ \ StartsWith(internal::StringView(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01828\ \ \ EXPECT\_TRUE(m\_empty.Matches(internal::StringView()));}
\DoxyCodeLine{01829\ \ \ EXPECT\_TRUE(m\_empty.Matches(internal::StringView(\textcolor{stringliteral}{"{}"{}})));}
\DoxyCodeLine{01830\ \ \ EXPECT\_TRUE(m\_empty.Matches(internal::StringView(\textcolor{stringliteral}{"{}not\ empty"{}})));}
\DoxyCodeLine{01831\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01832\ \}}
\DoxyCodeLine{01833\ }
\DoxyCodeLine{01834\ TEST(StartsWithTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01835\ \ \ Matcher<const\ std::string>\ m\ =\ StartsWith(\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{01836\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}starts\ with\ \(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{01837\ \}}
\DoxyCodeLine{01838\ }
\DoxyCodeLine{01839\ \textcolor{comment}{//\ Tests\ EndsWith(s).}}
\DoxyCodeLine{01840\ }
\DoxyCodeLine{01841\ TEST(EndsWithTest,\ MatchesStringWithGivenSuffix)\ \{}
\DoxyCodeLine{01842\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m1\ =\ EndsWith(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{01843\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01844\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01845\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01846\ }
\DoxyCodeLine{01847\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\ m2\ =\ EndsWith(std::string(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01848\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01849\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}Wow\ Hi\ Hi"{}}));}
\DoxyCodeLine{01850\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}Super\ Hi"{}}));}
\DoxyCodeLine{01851\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}i"{}}));}
\DoxyCodeLine{01852\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}Hi\ "{}}));}
\DoxyCodeLine{01853\ }
\DoxyCodeLine{01854\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01855\ \ \ \textcolor{keyword}{const}\ Matcher<const\ internal::StringView\&>\ m4\ =}
\DoxyCodeLine{01856\ \ \ \ \ \ \ EndsWith(internal::StringView(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01857\ \ \ EXPECT\_TRUE(m4.Matches(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01858\ \ \ EXPECT\_TRUE(m4.Matches(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01859\ \ \ EXPECT\_TRUE(m4.Matches(internal::StringView()));}
\DoxyCodeLine{01860\ \ \ EXPECT\_TRUE(m4.Matches(internal::StringView(\textcolor{stringliteral}{"{}"{}})));}
\DoxyCodeLine{01861\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01862\ \}}
\DoxyCodeLine{01863\ }
\DoxyCodeLine{01864\ TEST(EndsWithTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01865\ \ \ Matcher<const\ std::string>\ m\ =\ EndsWith(\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{01866\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}ends\ with\ \(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{01867\ \}}
\DoxyCodeLine{01868\ }
\DoxyCodeLine{01869\ \textcolor{comment}{//\ Tests\ WhenBase64Unescaped.}}
\DoxyCodeLine{01870\ }
\DoxyCodeLine{01871\ TEST(WhenBase64UnescapedTest,\ MatchesUnescapedBase64Strings)\ \{}
\DoxyCodeLine{01872\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m1\ =\ WhenBase64Unescaped(EndsWith(\textcolor{stringliteral}{"{}!"{}}));}
\DoxyCodeLine{01873\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}invalid\ base64"{}}));}
\DoxyCodeLine{01874\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{stringliteral}{"{}aGVsbG8gd29ybGQ="{}}));\ \ \textcolor{comment}{//\ hello\ world}}
\DoxyCodeLine{01875\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}aGVsbG8gd29ybGQh"{}}));\ \ \ \textcolor{comment}{//\ hello\ world!}}
\DoxyCodeLine{01876\ }
\DoxyCodeLine{01877\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\ m2\ =\ WhenBase64Unescaped(EndsWith(\textcolor{stringliteral}{"{}!"{}}));}
\DoxyCodeLine{01878\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}invalid\ base64"{}}));}
\DoxyCodeLine{01879\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}aGVsbG8gd29ybGQ="{}}));\ \ \textcolor{comment}{//\ hello\ world}}
\DoxyCodeLine{01880\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}aGVsbG8gd29ybGQh"{}}));\ \ \ \textcolor{comment}{//\ hello\ world!}}
\DoxyCodeLine{01881\ }
\DoxyCodeLine{01882\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01883\ \ \ \textcolor{keyword}{const}\ Matcher<const\ internal::StringView\&>\ m3\ =}
\DoxyCodeLine{01884\ \ \ \ \ \ \ WhenBase64Unescaped(EndsWith(\textcolor{stringliteral}{"{}!"{}}));}
\DoxyCodeLine{01885\ \ \ EXPECT\_FALSE(m3.Matches(\textcolor{stringliteral}{"{}invalid\ base64"{}}));}
\DoxyCodeLine{01886\ \ \ EXPECT\_FALSE(m3.Matches(\textcolor{stringliteral}{"{}aGVsbG8gd29ybGQ="{}}));\ \ \textcolor{comment}{//\ hello\ world}}
\DoxyCodeLine{01887\ \ \ EXPECT\_TRUE(m3.Matches(\textcolor{stringliteral}{"{}aGVsbG8gd29ybGQh"{}}));\ \ \ \textcolor{comment}{//\ hello\ world!}}
\DoxyCodeLine{01888\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01889\ \}}
\DoxyCodeLine{01890\ }
\DoxyCodeLine{01891\ TEST(WhenBase64UnescapedTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01892\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m\ =\ WhenBase64Unescaped(EndsWith(\textcolor{stringliteral}{"{}!"{}}));}
\DoxyCodeLine{01893\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}matches\ after\ Base64Unescape\ ends\ with\ \(\backslash\)"{}!\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{01894\ \}}
\DoxyCodeLine{01895\ }
\DoxyCodeLine{01896\ \textcolor{comment}{//\ Tests\ MatchesRegex().}}
\DoxyCodeLine{01897\ }
\DoxyCodeLine{01898\ TEST(MatchesRegexTest,\ MatchesStringMatchingGivenRegex)\ \{}
\DoxyCodeLine{01899\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m1\ =\ MatchesRegex(\textcolor{stringliteral}{"{}a.*z"{}});}
\DoxyCodeLine{01900\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}az"{}}));}
\DoxyCodeLine{01901\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}abcz"{}}));}
\DoxyCodeLine{01902\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01903\ }
\DoxyCodeLine{01904\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\ m2\ =\ MatchesRegex(\textcolor{keyword}{new}\ RE(\textcolor{stringliteral}{"{}a.*z"{}}));}
\DoxyCodeLine{01905\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}azbz"{}}));}
\DoxyCodeLine{01906\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}az1"{}}));}
\DoxyCodeLine{01907\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}1az"{}}));}
\DoxyCodeLine{01908\ }
\DoxyCodeLine{01909\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01910\ \ \ \textcolor{keyword}{const}\ Matcher<const\ internal::StringView\&>\ m3\ =\ MatchesRegex(\textcolor{stringliteral}{"{}a.*z"{}});}
\DoxyCodeLine{01911\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}az"{}})));}
\DoxyCodeLine{01912\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}abcz"{}})));}
\DoxyCodeLine{01913\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}1az"{}})));}
\DoxyCodeLine{01914\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView()));}
\DoxyCodeLine{01915\ \ \ \textcolor{keyword}{const}\ Matcher<const\ internal::StringView\&>\ m4\ =}
\DoxyCodeLine{01916\ \ \ \ \ \ \ MatchesRegex(internal::StringView(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01917\ \ \ EXPECT\_TRUE(m4.Matches(internal::StringView(\textcolor{stringliteral}{"{}"{}})));}
\DoxyCodeLine{01918\ \ \ EXPECT\_TRUE(m4.Matches(internal::StringView()));}
\DoxyCodeLine{01919\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01920\ \}}
\DoxyCodeLine{01921\ }
\DoxyCodeLine{01922\ TEST(MatchesRegexTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01923\ \ \ Matcher<const\ std::string>\ m1\ =\ MatchesRegex(std::string(\textcolor{stringliteral}{"{}Hi.*"{}}));}
\DoxyCodeLine{01924\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}matches\ regular\ expression\ \(\backslash\)"{}Hi.*\(\backslash\)"{}"{}},\ Describe(m1));}
\DoxyCodeLine{01925\ }
\DoxyCodeLine{01926\ \ \ Matcher<const\ char*>\ m2\ =\ MatchesRegex(\textcolor{keyword}{new}\ RE(\textcolor{stringliteral}{"{}a.*"{}}));}
\DoxyCodeLine{01927\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}matches\ regular\ expression\ \(\backslash\)"{}a.*\(\backslash\)"{}"{}},\ Describe(m2));}
\DoxyCodeLine{01928\ }
\DoxyCodeLine{01929\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01930\ \ \ Matcher<const\ internal::StringView>\ m3\ =\ MatchesRegex(\textcolor{keyword}{new}\ RE(\textcolor{stringliteral}{"{}0.*"{}}));}
\DoxyCodeLine{01931\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}matches\ regular\ expression\ \(\backslash\)"{}0.*\(\backslash\)"{}"{}},\ Describe(m3));}
\DoxyCodeLine{01932\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01933\ \}}
\DoxyCodeLine{01934\ }
\DoxyCodeLine{01935\ \textcolor{comment}{//\ Tests\ ContainsRegex().}}
\DoxyCodeLine{01936\ }
\DoxyCodeLine{01937\ TEST(ContainsRegexTest,\ MatchesStringContainingGivenRegex)\ \{}
\DoxyCodeLine{01938\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m1\ =\ ContainsRegex(std::string(\textcolor{stringliteral}{"{}a.*z"{}}));}
\DoxyCodeLine{01939\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}az"{}}));}
\DoxyCodeLine{01940\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}0abcz1"{}}));}
\DoxyCodeLine{01941\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01942\ }
\DoxyCodeLine{01943\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string\&>\ m2\ =\ ContainsRegex(\textcolor{keyword}{new}\ RE(\textcolor{stringliteral}{"{}a.*z"{}}));}
\DoxyCodeLine{01944\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}azbz"{}}));}
\DoxyCodeLine{01945\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}az1"{}}));}
\DoxyCodeLine{01946\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{stringliteral}{"{}1a"{}}));}
\DoxyCodeLine{01947\ }
\DoxyCodeLine{01948\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01949\ \ \ \textcolor{keyword}{const}\ Matcher<const\ internal::StringView\&>\ m3\ =}
\DoxyCodeLine{01950\ \ \ \ \ \ \ ContainsRegex(\textcolor{keyword}{new}\ RE(\textcolor{stringliteral}{"{}a.*z"{}}));}
\DoxyCodeLine{01951\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}azbz"{}})));}
\DoxyCodeLine{01952\ \ \ EXPECT\_TRUE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}az1"{}})));}
\DoxyCodeLine{01953\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView(\textcolor{stringliteral}{"{}1a"{}})));}
\DoxyCodeLine{01954\ \ \ EXPECT\_FALSE(m3.Matches(internal::StringView()));}
\DoxyCodeLine{01955\ \ \ \textcolor{keyword}{const}\ Matcher<const\ internal::StringView\&>\ m4\ =}
\DoxyCodeLine{01956\ \ \ \ \ \ \ ContainsRegex(internal::StringView(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{01957\ \ \ EXPECT\_TRUE(m4.Matches(internal::StringView(\textcolor{stringliteral}{"{}"{}})));}
\DoxyCodeLine{01958\ \ \ EXPECT\_TRUE(m4.Matches(internal::StringView()));}
\DoxyCodeLine{01959\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01960\ \}}
\DoxyCodeLine{01961\ }
\DoxyCodeLine{01962\ TEST(ContainsRegexTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{01963\ \ \ Matcher<const\ std::string>\ m1\ =\ ContainsRegex(\textcolor{stringliteral}{"{}Hi.*"{}});}
\DoxyCodeLine{01964\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}contains\ regular\ expression\ \(\backslash\)"{}Hi.*\(\backslash\)"{}"{}},\ Describe(m1));}
\DoxyCodeLine{01965\ }
\DoxyCodeLine{01966\ \ \ Matcher<const\ char*>\ m2\ =\ ContainsRegex(\textcolor{keyword}{new}\ RE(\textcolor{stringliteral}{"{}a.*"{}}));}
\DoxyCodeLine{01967\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}contains\ regular\ expression\ \(\backslash\)"{}a.*\(\backslash\)"{}"{}},\ Describe(m2));}
\DoxyCodeLine{01968\ }
\DoxyCodeLine{01969\ \textcolor{preprocessor}{\#if\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01970\ \ \ Matcher<const\ internal::StringView>\ m3\ =\ ContainsRegex(\textcolor{keyword}{new}\ RE(\textcolor{stringliteral}{"{}0.*"{}}));}
\DoxyCodeLine{01971\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}contains\ regular\ expression\ \(\backslash\)"{}0.*\(\backslash\)"{}"{}},\ Describe(m3));}
\DoxyCodeLine{01972\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_INTERNAL\_HAS\_STRING\_VIEW}}
\DoxyCodeLine{01973\ \}}
\DoxyCodeLine{01974\ }
\DoxyCodeLine{01975\ \textcolor{comment}{//\ Tests\ for\ wide\ strings.}}
\DoxyCodeLine{01976\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{01977\ TEST(StdWideStrEqTest,\ MatchesEqual)\ \{}
\DoxyCodeLine{01978\ \ \ Matcher<const\ wchar\_t*>\ m\ =\ StrEq(::std::wstring(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01979\ \ \ EXPECT\_TRUE(m.Matches(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01980\ \ \ EXPECT\_FALSE(m.Matches(L\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{01981\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{01982\ }
\DoxyCodeLine{01983\ \ \ Matcher<const\ ::std::wstring\&>\ m2\ =\ StrEq(L\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{01984\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{01985\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{01986\ }
\DoxyCodeLine{01987\ \ \ Matcher<const\ ::std::wstring\&>\ m3\ =\ StrEq(L\textcolor{stringliteral}{"{}\(\backslash\)xD3\(\backslash\)x576\(\backslash\)x8D3\(\backslash\)xC74D"{}});}
\DoxyCodeLine{01988\ \ \ EXPECT\_TRUE(m3.Matches(L\textcolor{stringliteral}{"{}\(\backslash\)xD3\(\backslash\)x576\(\backslash\)x8D3\(\backslash\)xC74D"{}}));}
\DoxyCodeLine{01989\ \ \ EXPECT\_FALSE(m3.Matches(L\textcolor{stringliteral}{"{}\(\backslash\)xD3\(\backslash\)x576\(\backslash\)x8D3\(\backslash\)xC74E"{}}));}
\DoxyCodeLine{01990\ }
\DoxyCodeLine{01991\ \ \ ::std::wstring\ str(L\textcolor{stringliteral}{"{}01204500800"{}});}
\DoxyCodeLine{01992\ \ \ str[3]\ =\ L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{01993\ \ \ Matcher<const\ ::std::wstring\&>\ m4\ =\ StrEq(str);}
\DoxyCodeLine{01994\ \ \ EXPECT\_TRUE(m4.Matches(str));}
\DoxyCodeLine{01995\ \ \ str[0]\ =\ str[6]\ =\ str[7]\ =\ str[9]\ =\ str[10]\ =\ L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{01996\ \ \ Matcher<const\ ::std::wstring\&>\ m5\ =\ StrEq(str);}
\DoxyCodeLine{01997\ \ \ EXPECT\_TRUE(m5.Matches(str));}
\DoxyCodeLine{01998\ \}}
\DoxyCodeLine{01999\ }
\DoxyCodeLine{02000\ TEST(StdWideStrEqTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02001\ \ \ Matcher<\ ::std::wstring>\ m\ =\ StrEq(L\textcolor{stringliteral}{"{}Hi-\/\(\backslash\)'\(\backslash\)"{}?\(\backslash\)\(\backslash\)\(\backslash\)a\(\backslash\)b\(\backslash\)f\(\backslash\)n\(\backslash\)r\(\backslash\)t\(\backslash\)v"{}});}
\DoxyCodeLine{02002\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ L\(\backslash\)"{}Hi-\/\(\backslash\)'\(\backslash\)\(\backslash\)\(\backslash\)"{}?\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)f\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)r\(\backslash\)\(\backslash\)t\(\backslash\)\(\backslash\)v\(\backslash\)"{}"{}},}
\DoxyCodeLine{02003\ \ \ \ \ Describe(m));}
\DoxyCodeLine{02004\ }
\DoxyCodeLine{02005\ \ \ Matcher<\ ::std::wstring>\ m2\ =\ StrEq(L\textcolor{stringliteral}{"{}\(\backslash\)xD3\(\backslash\)x576\(\backslash\)x8D3\(\backslash\)xC74D"{}});}
\DoxyCodeLine{02006\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ L\(\backslash\)"{}\(\backslash\)\(\backslash\)xD3\(\backslash\)\(\backslash\)x576\(\backslash\)\(\backslash\)x8D3\(\backslash\)\(\backslash\)xC74D\(\backslash\)"{}"{}},}
\DoxyCodeLine{02007\ \ \ \ \ Describe(m2));}
\DoxyCodeLine{02008\ }
\DoxyCodeLine{02009\ \ \ ::std::wstring\ str(L\textcolor{stringliteral}{"{}01204500800"{}});}
\DoxyCodeLine{02010\ \ \ str[3]\ =\ L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{02011\ \ \ Matcher<const\ ::std::wstring\&>\ m4\ =\ StrEq(str);}
\DoxyCodeLine{02012\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ L\(\backslash\)"{}012\(\backslash\)\(\backslash\)04500800\(\backslash\)"{}"{}},\ Describe(m4));}
\DoxyCodeLine{02013\ \ \ str[0]\ =\ str[6]\ =\ str[7]\ =\ str[9]\ =\ str[10]\ =\ L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{02014\ \ \ Matcher<const\ ::std::wstring\&>\ m5\ =\ StrEq(str);}
\DoxyCodeLine{02015\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ L\(\backslash\)"{}\(\backslash\)\(\backslash\)012\(\backslash\)\(\backslash\)045\(\backslash\)\(\backslash\)0\(\backslash\)\(\backslash\)08\(\backslash\)\(\backslash\)0\(\backslash\)\(\backslash\)0\(\backslash\)"{}"{}},\ Describe(m5));}
\DoxyCodeLine{02016\ \}}
\DoxyCodeLine{02017\ }
\DoxyCodeLine{02018\ TEST(StdWideStrNeTest,\ MatchesUnequalString)\ \{}
\DoxyCodeLine{02019\ \ \ Matcher<const\ wchar\_t*>\ m\ =\ StrNe(L\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{02020\ \ \ EXPECT\_TRUE(m.Matches(L\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{02021\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{02022\ \ \ EXPECT\_FALSE(m.Matches(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{02023\ }
\DoxyCodeLine{02024\ \ \ Matcher<\ ::std::wstring>\ m2\ =\ StrNe(::std::wstring(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{02025\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{02026\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{02027\ \}}
\DoxyCodeLine{02028\ }
\DoxyCodeLine{02029\ TEST(StdWideStrNeTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02030\ \ \ Matcher<const\ wchar\_t*>\ m\ =\ StrNe(L\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{02031\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ equal\ to\ L\(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{02032\ \}}
\DoxyCodeLine{02033\ }
\DoxyCodeLine{02034\ TEST(StdWideStrCaseEqTest,\ MatchesEqualStringIgnoringCase)\ \{}
\DoxyCodeLine{02035\ \ \ Matcher<const\ wchar\_t*>\ m\ =\ StrCaseEq(::std::wstring(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{02036\ \ \ EXPECT\_TRUE(m.Matches(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{02037\ \ \ EXPECT\_TRUE(m.Matches(L\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{02038\ \ \ EXPECT\_FALSE(m.Matches(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{02039\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{02040\ }
\DoxyCodeLine{02041\ \ \ Matcher<const\ ::std::wstring\&>\ m2\ =\ StrCaseEq(L\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{02042\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{02043\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{02044\ \}}
\DoxyCodeLine{02045\ }
\DoxyCodeLine{02046\ TEST(StdWideStrCaseEqTest,\ MatchesEqualStringWith0IgnoringCase)\ \{}
\DoxyCodeLine{02047\ \ \ ::std::wstring\ str1(L\textcolor{stringliteral}{"{}oabocdooeoo"{}});}
\DoxyCodeLine{02048\ \ \ ::std::wstring\ str2(L\textcolor{stringliteral}{"{}OABOCDOOEOO"{}});}
\DoxyCodeLine{02049\ \ \ Matcher<const\ ::std::wstring\&>\ m0\ =\ StrCaseEq(str1);}
\DoxyCodeLine{02050\ \ \ EXPECT\_FALSE(m0.Matches(str2\ +\ ::std::wstring(1,\ L\textcolor{charliteral}{'\(\backslash\)0'})));}
\DoxyCodeLine{02051\ }
\DoxyCodeLine{02052\ \ \ str1[3]\ =\ str2[3]\ =\ L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{02053\ \ \ Matcher<const\ ::std::wstring\&>\ m1\ =\ StrCaseEq(str1);}
\DoxyCodeLine{02054\ \ \ EXPECT\_TRUE(m1.Matches(str2));}
\DoxyCodeLine{02055\ }
\DoxyCodeLine{02056\ \ \ str1[0]\ =\ str1[6]\ =\ str1[7]\ =\ str1[10]\ =\ L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{02057\ \ \ str2[0]\ =\ str2[6]\ =\ str2[7]\ =\ str2[10]\ =\ L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{02058\ \ \ Matcher<const\ ::std::wstring\&>\ m2\ =\ StrCaseEq(str1);}
\DoxyCodeLine{02059\ \ \ str1[9]\ =\ str2[9]\ =\ L\textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{02060\ \ \ EXPECT\_FALSE(m2.Matches(str2));}
\DoxyCodeLine{02061\ }
\DoxyCodeLine{02062\ \ \ Matcher<const\ ::std::wstring\&>\ m3\ =\ StrCaseEq(str1);}
\DoxyCodeLine{02063\ \ \ EXPECT\_TRUE(m3.Matches(str2));}
\DoxyCodeLine{02064\ }
\DoxyCodeLine{02065\ \ \ EXPECT\_FALSE(m3.Matches(str2\ +\ L\textcolor{stringliteral}{"{}x"{}}));}
\DoxyCodeLine{02066\ \ \ str2.append(1,\ L\textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{02067\ \ \ EXPECT\_FALSE(m3.Matches(str2));}
\DoxyCodeLine{02068\ \ \ EXPECT\_FALSE(m3.Matches(::std::wstring(str2,\ 0,\ 9)));}
\DoxyCodeLine{02069\ \}}
\DoxyCodeLine{02070\ }
\DoxyCodeLine{02071\ TEST(StdWideStrCaseEqTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02072\ \ \ Matcher<\ ::std::wstring>\ m\ =\ StrCaseEq(L\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{02073\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ (ignoring\ case)\ L\(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{02074\ \}}
\DoxyCodeLine{02075\ }
\DoxyCodeLine{02076\ TEST(StdWideStrCaseNeTest,\ MatchesUnequalStringIgnoringCase)\ \{}
\DoxyCodeLine{02077\ \ \ Matcher<const\ wchar\_t*>\ m\ =\ StrCaseNe(L\textcolor{stringliteral}{"{}Hello"{}});}
\DoxyCodeLine{02078\ \ \ EXPECT\_TRUE(m.Matches(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{02079\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{02080\ \ \ EXPECT\_FALSE(m.Matches(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{02081\ \ \ EXPECT\_FALSE(m.Matches(L\textcolor{stringliteral}{"{}hello"{}}));}
\DoxyCodeLine{02082\ }
\DoxyCodeLine{02083\ \ \ Matcher<\ ::std::wstring>\ m2\ =\ StrCaseNe(::std::wstring(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{02084\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{02085\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}Hello"{}}));}
\DoxyCodeLine{02086\ \}}
\DoxyCodeLine{02087\ }
\DoxyCodeLine{02088\ TEST(StdWideStrCaseNeTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02089\ \ \ Matcher<const\ wchar\_t*>\ m\ =\ StrCaseNe(L\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{02090\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ equal\ to\ (ignoring\ case)\ L\(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{02091\ \}}
\DoxyCodeLine{02092\ }
\DoxyCodeLine{02093\ \textcolor{comment}{//\ Tests\ that\ HasSubstr()\ works\ for\ matching\ wstring-\/typed\ values.}}
\DoxyCodeLine{02094\ TEST(StdWideHasSubstrTest,\ WorksForStringClasses)\ \{}
\DoxyCodeLine{02095\ \ \ \textcolor{keyword}{const}\ Matcher<\ ::std::wstring>\ m1\ =\ HasSubstr(L\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{02096\ \ \ EXPECT\_TRUE(m1.Matches(::std::wstring(L\textcolor{stringliteral}{"{}I\ love\ food."{}})));}
\DoxyCodeLine{02097\ \ \ EXPECT\_FALSE(m1.Matches(::std::wstring(L\textcolor{stringliteral}{"{}tofo"{}})));}
\DoxyCodeLine{02098\ }
\DoxyCodeLine{02099\ \ \ \textcolor{keyword}{const}\ Matcher<const\ ::std::wstring\&>\ m2\ =\ HasSubstr(L\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{02100\ \ \ EXPECT\_TRUE(m2.Matches(::std::wstring(L\textcolor{stringliteral}{"{}I\ love\ food."{}})));}
\DoxyCodeLine{02101\ \ \ EXPECT\_FALSE(m2.Matches(::std::wstring(L\textcolor{stringliteral}{"{}tofo"{}})));}
\DoxyCodeLine{02102\ \}}
\DoxyCodeLine{02103\ }
\DoxyCodeLine{02104\ \textcolor{comment}{//\ Tests\ that\ HasSubstr()\ works\ for\ matching\ C-\/wide-\/string-\/typed\ values.}}
\DoxyCodeLine{02105\ TEST(StdWideHasSubstrTest,\ WorksForCStrings)\ \{}
\DoxyCodeLine{02106\ \ \ \textcolor{keyword}{const}\ Matcher<wchar\_t*>\ m1\ =\ HasSubstr(L\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{02107\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{wchar\_t}*\textcolor{keyword}{>}(L\textcolor{stringliteral}{"{}I\ love\ food."{}})));}
\DoxyCodeLine{02108\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{wchar\_t}*\textcolor{keyword}{>}(L\textcolor{stringliteral}{"{}tofo"{}})));}
\DoxyCodeLine{02109\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{02110\ }
\DoxyCodeLine{02111\ \ \ \textcolor{keyword}{const}\ Matcher<const\ wchar\_t*>\ m2\ =\ HasSubstr(L\textcolor{stringliteral}{"{}foo"{}});}
\DoxyCodeLine{02112\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}I\ love\ food."{}}));}
\DoxyCodeLine{02113\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}tofo"{}}));}
\DoxyCodeLine{02114\ \ \ EXPECT\_FALSE(m2.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{02115\ \}}
\DoxyCodeLine{02116\ }
\DoxyCodeLine{02117\ \textcolor{comment}{//\ Tests\ that\ HasSubstr(s)\ describes\ itself\ properly.}}
\DoxyCodeLine{02118\ TEST(StdWideHasSubstrTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02119\ \ \ Matcher<\ ::std::wstring>\ m\ =\ HasSubstr(L\textcolor{stringliteral}{"{}foo\(\backslash\)n\(\backslash\)"{}"{}});}
\DoxyCodeLine{02120\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ substring\ L\(\backslash\)"{}foo\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)\(\backslash\)"{}\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{02121\ \}}
\DoxyCodeLine{02122\ }
\DoxyCodeLine{02123\ \textcolor{comment}{//\ Tests\ StartsWith(s).}}
\DoxyCodeLine{02124\ }
\DoxyCodeLine{02125\ TEST(StdWideStartsWithTest,\ MatchesStringWithGivenPrefix)\ \{}
\DoxyCodeLine{02126\ \ \ \textcolor{keyword}{const}\ Matcher<const\ wchar\_t*>\ m1\ =\ StartsWith(::std::wstring(L\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{02127\ \ \ EXPECT\_TRUE(m1.Matches(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{02128\ \ \ EXPECT\_TRUE(m1.Matches(L\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{02129\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{02130\ }
\DoxyCodeLine{02131\ \ \ \textcolor{keyword}{const}\ Matcher<const\ ::std::wstring\&>\ m2\ =\ StartsWith(L\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{02132\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{02133\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}Hi\ Hi!"{}}));}
\DoxyCodeLine{02134\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}High"{}}));}
\DoxyCodeLine{02135\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}H"{}}));}
\DoxyCodeLine{02136\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}\ Hi"{}}));}
\DoxyCodeLine{02137\ \}}
\DoxyCodeLine{02138\ }
\DoxyCodeLine{02139\ TEST(StdWideStartsWithTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02140\ \ \ Matcher<const\ ::std::wstring>\ m\ =\ StartsWith(L\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{02141\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}starts\ with\ L\(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{02142\ \}}
\DoxyCodeLine{02143\ }
\DoxyCodeLine{02144\ \textcolor{comment}{//\ Tests\ EndsWith(s).}}
\DoxyCodeLine{02145\ }
\DoxyCodeLine{02146\ TEST(StdWideEndsWithTest,\ MatchesStringWithGivenSuffix)\ \{}
\DoxyCodeLine{02147\ \ \ \textcolor{keyword}{const}\ Matcher<const\ wchar\_t*>\ m1\ =\ EndsWith(L\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{02148\ \ \ EXPECT\_TRUE(m1.Matches(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{02149\ \ \ EXPECT\_TRUE(m1.Matches(L\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{02150\ \ \ EXPECT\_FALSE(m1.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{02151\ }
\DoxyCodeLine{02152\ \ \ \textcolor{keyword}{const}\ Matcher<const\ ::std::wstring\&>\ m2\ =\ EndsWith(::std::wstring(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{02153\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{02154\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}Wow\ Hi\ Hi"{}}));}
\DoxyCodeLine{02155\ \ \ EXPECT\_TRUE(m2.Matches(L\textcolor{stringliteral}{"{}Super\ Hi"{}}));}
\DoxyCodeLine{02156\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}i"{}}));}
\DoxyCodeLine{02157\ \ \ EXPECT\_FALSE(m2.Matches(L\textcolor{stringliteral}{"{}Hi\ "{}}));}
\DoxyCodeLine{02158\ \}}
\DoxyCodeLine{02159\ }
\DoxyCodeLine{02160\ TEST(StdWideEndsWithTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02161\ \ \ Matcher<const\ ::std::wstring>\ m\ =\ EndsWith(L\textcolor{stringliteral}{"{}Hi"{}});}
\DoxyCodeLine{02162\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}ends\ with\ L\(\backslash\)"{}Hi\(\backslash\)"{}"{}},\ Describe(m));}
\DoxyCodeLine{02163\ \}}
\DoxyCodeLine{02164\ }
\DoxyCodeLine{02165\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{02166\ }
\DoxyCodeLine{02167\ typedef\ ::std::tuple<long,\ int>\ Tuple2;\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{02168\ }
\DoxyCodeLine{02169\ \textcolor{comment}{//\ Tests\ that\ Eq()\ matches\ a\ 2-\/tuple\ where\ the\ first\ field\ ==\ the}}
\DoxyCodeLine{02170\ \textcolor{comment}{//\ second\ field.}}
\DoxyCodeLine{02171\ TEST(Eq2Test,\ MatchesEqualArguments)\ \{}
\DoxyCodeLine{02172\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Eq();}
\DoxyCodeLine{02173\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 5)));}
\DoxyCodeLine{02174\ \ \ EXPECT\_FALSE(m.Matches(Tuple2(5L,\ 6)));}
\DoxyCodeLine{02175\ \}}
\DoxyCodeLine{02176\ }
\DoxyCodeLine{02177\ \textcolor{comment}{//\ Tests\ that\ Eq()\ describes\ itself\ properly.}}
\DoxyCodeLine{02178\ TEST(Eq2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02179\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Eq();}
\DoxyCodeLine{02180\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02181\ \}}
\DoxyCodeLine{02182\ }
\DoxyCodeLine{02183\ \textcolor{comment}{//\ Tests\ that\ Ge()\ matches\ a\ 2-\/tuple\ where\ the\ first\ field\ >=\ the}}
\DoxyCodeLine{02184\ \textcolor{comment}{//\ second\ field.}}
\DoxyCodeLine{02185\ TEST(Ge2Test,\ MatchesGreaterThanOrEqualArguments)\ \{}
\DoxyCodeLine{02186\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Ge();}
\DoxyCodeLine{02187\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 4)));}
\DoxyCodeLine{02188\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 5)));}
\DoxyCodeLine{02189\ \ \ EXPECT\_FALSE(m.Matches(Tuple2(5L,\ 6)));}
\DoxyCodeLine{02190\ \}}
\DoxyCodeLine{02191\ }
\DoxyCodeLine{02192\ \textcolor{comment}{//\ Tests\ that\ Ge()\ describes\ itself\ properly.}}
\DoxyCodeLine{02193\ TEST(Ge2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02194\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Ge();}
\DoxyCodeLine{02195\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ a\ pair\ where\ the\ first\ >=\ the\ second"{}},\ Describe(m));}
\DoxyCodeLine{02196\ \}}
\DoxyCodeLine{02197\ }
\DoxyCodeLine{02198\ \textcolor{comment}{//\ Tests\ that\ Gt()\ matches\ a\ 2-\/tuple\ where\ the\ first\ field\ >\ the}}
\DoxyCodeLine{02199\ \textcolor{comment}{//\ second\ field.}}
\DoxyCodeLine{02200\ TEST(Gt2Test,\ MatchesGreaterThanArguments)\ \{}
\DoxyCodeLine{02201\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Gt();}
\DoxyCodeLine{02202\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 4)));}
\DoxyCodeLine{02203\ \ \ EXPECT\_FALSE(m.Matches(Tuple2(5L,\ 5)));}
\DoxyCodeLine{02204\ \ \ EXPECT\_FALSE(m.Matches(Tuple2(5L,\ 6)));}
\DoxyCodeLine{02205\ \}}
\DoxyCodeLine{02206\ }
\DoxyCodeLine{02207\ \textcolor{comment}{//\ Tests\ that\ Gt()\ describes\ itself\ properly.}}
\DoxyCodeLine{02208\ TEST(Gt2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02209\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Gt();}
\DoxyCodeLine{02210\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ a\ pair\ where\ the\ first\ >\ the\ second"{}},\ Describe(m));}
\DoxyCodeLine{02211\ \}}
\DoxyCodeLine{02212\ }
\DoxyCodeLine{02213\ \textcolor{comment}{//\ Tests\ that\ Le()\ matches\ a\ 2-\/tuple\ where\ the\ first\ field\ <=\ the}}
\DoxyCodeLine{02214\ \textcolor{comment}{//\ second\ field.}}
\DoxyCodeLine{02215\ TEST(Le2Test,\ MatchesLessThanOrEqualArguments)\ \{}
\DoxyCodeLine{02216\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Le();}
\DoxyCodeLine{02217\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 6)));}
\DoxyCodeLine{02218\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 5)));}
\DoxyCodeLine{02219\ \ \ EXPECT\_FALSE(m.Matches(Tuple2(5L,\ 4)));}
\DoxyCodeLine{02220\ \}}
\DoxyCodeLine{02221\ }
\DoxyCodeLine{02222\ \textcolor{comment}{//\ Tests\ that\ Le()\ describes\ itself\ properly.}}
\DoxyCodeLine{02223\ TEST(Le2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02224\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Le();}
\DoxyCodeLine{02225\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ a\ pair\ where\ the\ first\ <=\ the\ second"{}},\ Describe(m));}
\DoxyCodeLine{02226\ \}}
\DoxyCodeLine{02227\ }
\DoxyCodeLine{02228\ \textcolor{comment}{//\ Tests\ that\ Lt()\ matches\ a\ 2-\/tuple\ where\ the\ first\ field\ <\ the}}
\DoxyCodeLine{02229\ \textcolor{comment}{//\ second\ field.}}
\DoxyCodeLine{02230\ TEST(Lt2Test,\ MatchesLessThanArguments)\ \{}
\DoxyCodeLine{02231\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Lt();}
\DoxyCodeLine{02232\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 6)));}
\DoxyCodeLine{02233\ \ \ EXPECT\_FALSE(m.Matches(Tuple2(5L,\ 5)));}
\DoxyCodeLine{02234\ \ \ EXPECT\_FALSE(m.Matches(Tuple2(5L,\ 4)));}
\DoxyCodeLine{02235\ \}}
\DoxyCodeLine{02236\ }
\DoxyCodeLine{02237\ \textcolor{comment}{//\ Tests\ that\ Lt()\ describes\ itself\ properly.}}
\DoxyCodeLine{02238\ TEST(Lt2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02239\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Lt();}
\DoxyCodeLine{02240\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ a\ pair\ where\ the\ first\ <\ the\ second"{}},\ Describe(m));}
\DoxyCodeLine{02241\ \}}
\DoxyCodeLine{02242\ }
\DoxyCodeLine{02243\ \textcolor{comment}{//\ Tests\ that\ Ne()\ matches\ a\ 2-\/tuple\ where\ the\ first\ field\ !=\ the}}
\DoxyCodeLine{02244\ \textcolor{comment}{//\ second\ field.}}
\DoxyCodeLine{02245\ TEST(Ne2Test,\ MatchesUnequalArguments)\ \{}
\DoxyCodeLine{02246\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Ne();}
\DoxyCodeLine{02247\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 6)));}
\DoxyCodeLine{02248\ \ \ EXPECT\_TRUE(m.Matches(Tuple2(5L,\ 4)));}
\DoxyCodeLine{02249\ \ \ EXPECT\_FALSE(m.Matches(Tuple2(5L,\ 5)));}
\DoxyCodeLine{02250\ \}}
\DoxyCodeLine{02251\ }
\DoxyCodeLine{02252\ \textcolor{comment}{//\ Tests\ that\ Ne()\ describes\ itself\ properly.}}
\DoxyCodeLine{02253\ TEST(Ne2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02254\ \ \ Matcher<const\ Tuple2\&>\ m\ =\ Ne();}
\DoxyCodeLine{02255\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ unequal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02256\ \}}
\DoxyCodeLine{02257\ }
\DoxyCodeLine{02258\ TEST(PairMatchBaseTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{02259\ \ \ \textcolor{keyword}{using\ }Pointers\ =\ std::tuple<std::unique\_ptr<int>,\ std::unique\_ptr<int>>;}
\DoxyCodeLine{02260\ \ \ Matcher<Pointers>\ matcher\ =\ Eq();}
\DoxyCodeLine{02261\ \ \ Pointers\ pointers;}
\DoxyCodeLine{02262\ \ \ \textcolor{comment}{//\ Tested\ values\ don't\ matter;\ the\ point\ is\ that\ matcher\ does\ not\ copy\ the}}
\DoxyCodeLine{02263\ \ \ \textcolor{comment}{//\ matched\ values.}}
\DoxyCodeLine{02264\ \ \ EXPECT\_TRUE(matcher.Matches(pointers));}
\DoxyCodeLine{02265\ \}}
\DoxyCodeLine{02266\ }
\DoxyCodeLine{02267\ \textcolor{comment}{//\ Tests\ that\ IsNan()\ matches\ a\ NaN,\ with\ float.}}
\DoxyCodeLine{02268\ TEST(IsNan,\ FloatMatchesNan)\ \{}
\DoxyCodeLine{02269\ \ \ \textcolor{keywordtype}{float}\ quiet\_nan\ =\ std::numeric\_limits<float>::quiet\_NaN();}
\DoxyCodeLine{02270\ \ \ \textcolor{keywordtype}{float}\ other\_nan\ =\ std::nanf(\textcolor{stringliteral}{"{}1"{}});}
\DoxyCodeLine{02271\ \ \ \textcolor{keywordtype}{float}\ real\_value\ =\ 1.0f;}
\DoxyCodeLine{02272\ }
\DoxyCodeLine{02273\ \ \ Matcher<float>\ m\ =\ IsNan();}
\DoxyCodeLine{02274\ \ \ EXPECT\_TRUE(m.Matches(quiet\_nan));}
\DoxyCodeLine{02275\ \ \ EXPECT\_TRUE(m.Matches(other\_nan));}
\DoxyCodeLine{02276\ \ \ EXPECT\_FALSE(m.Matches(real\_value));}
\DoxyCodeLine{02277\ }
\DoxyCodeLine{02278\ \ \ Matcher<float\&>\ m\_ref\ =\ IsNan();}
\DoxyCodeLine{02279\ \ \ EXPECT\_TRUE(m\_ref.Matches(quiet\_nan));}
\DoxyCodeLine{02280\ \ \ EXPECT\_TRUE(m\_ref.Matches(other\_nan));}
\DoxyCodeLine{02281\ \ \ EXPECT\_FALSE(m\_ref.Matches(real\_value));}
\DoxyCodeLine{02282\ }
\DoxyCodeLine{02283\ \ \ Matcher<const\ float\&>\ m\_cref\ =\ IsNan();}
\DoxyCodeLine{02284\ \ \ EXPECT\_TRUE(m\_cref.Matches(quiet\_nan));}
\DoxyCodeLine{02285\ \ \ EXPECT\_TRUE(m\_cref.Matches(other\_nan));}
\DoxyCodeLine{02286\ \ \ EXPECT\_FALSE(m\_cref.Matches(real\_value));}
\DoxyCodeLine{02287\ \}}
\DoxyCodeLine{02288\ }
\DoxyCodeLine{02289\ \textcolor{comment}{//\ Tests\ that\ IsNan()\ matches\ a\ NaN,\ with\ double.}}
\DoxyCodeLine{02290\ TEST(IsNan,\ DoubleMatchesNan)\ \{}
\DoxyCodeLine{02291\ \ \ \textcolor{keywordtype}{double}\ quiet\_nan\ =\ std::numeric\_limits<double>::quiet\_NaN();}
\DoxyCodeLine{02292\ \ \ \textcolor{keywordtype}{double}\ other\_nan\ =\ std::nan(\textcolor{stringliteral}{"{}1"{}});}
\DoxyCodeLine{02293\ \ \ \textcolor{keywordtype}{double}\ real\_value\ =\ 1.0;}
\DoxyCodeLine{02294\ }
\DoxyCodeLine{02295\ \ \ Matcher<double>\ m\ =\ IsNan();}
\DoxyCodeLine{02296\ \ \ EXPECT\_TRUE(m.Matches(quiet\_nan));}
\DoxyCodeLine{02297\ \ \ EXPECT\_TRUE(m.Matches(other\_nan));}
\DoxyCodeLine{02298\ \ \ EXPECT\_FALSE(m.Matches(real\_value));}
\DoxyCodeLine{02299\ }
\DoxyCodeLine{02300\ \ \ Matcher<double\&>\ m\_ref\ =\ IsNan();}
\DoxyCodeLine{02301\ \ \ EXPECT\_TRUE(m\_ref.Matches(quiet\_nan));}
\DoxyCodeLine{02302\ \ \ EXPECT\_TRUE(m\_ref.Matches(other\_nan));}
\DoxyCodeLine{02303\ \ \ EXPECT\_FALSE(m\_ref.Matches(real\_value));}
\DoxyCodeLine{02304\ }
\DoxyCodeLine{02305\ \ \ Matcher<const\ double\&>\ m\_cref\ =\ IsNan();}
\DoxyCodeLine{02306\ \ \ EXPECT\_TRUE(m\_cref.Matches(quiet\_nan));}
\DoxyCodeLine{02307\ \ \ EXPECT\_TRUE(m\_cref.Matches(other\_nan));}
\DoxyCodeLine{02308\ \ \ EXPECT\_FALSE(m\_cref.Matches(real\_value));}
\DoxyCodeLine{02309\ \}}
\DoxyCodeLine{02310\ }
\DoxyCodeLine{02311\ \textcolor{comment}{//\ Tests\ that\ IsNan()\ matches\ a\ NaN,\ with\ long\ double.}}
\DoxyCodeLine{02312\ TEST(IsNan,\ LongDoubleMatchesNan)\ \{}
\DoxyCodeLine{02313\ \ \ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{double}\ quiet\_nan\ =\ std::numeric\_limits<long\ double>::quiet\_NaN();}
\DoxyCodeLine{02314\ \ \ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{double}\ other\_nan\ =\ std::nan(\textcolor{stringliteral}{"{}1"{}});}
\DoxyCodeLine{02315\ \ \ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{double}\ real\_value\ =\ 1.0;}
\DoxyCodeLine{02316\ }
\DoxyCodeLine{02317\ \ \ Matcher<long\ double>\ m\ =\ IsNan();}
\DoxyCodeLine{02318\ \ \ EXPECT\_TRUE(m.Matches(quiet\_nan));}
\DoxyCodeLine{02319\ \ \ EXPECT\_TRUE(m.Matches(other\_nan));}
\DoxyCodeLine{02320\ \ \ EXPECT\_FALSE(m.Matches(real\_value));}
\DoxyCodeLine{02321\ }
\DoxyCodeLine{02322\ \ \ Matcher<long\ double\&>\ m\_ref\ =\ IsNan();}
\DoxyCodeLine{02323\ \ \ EXPECT\_TRUE(m\_ref.Matches(quiet\_nan));}
\DoxyCodeLine{02324\ \ \ EXPECT\_TRUE(m\_ref.Matches(other\_nan));}
\DoxyCodeLine{02325\ \ \ EXPECT\_FALSE(m\_ref.Matches(real\_value));}
\DoxyCodeLine{02326\ }
\DoxyCodeLine{02327\ \ \ Matcher<const\ long\ double\&>\ m\_cref\ =\ IsNan();}
\DoxyCodeLine{02328\ \ \ EXPECT\_TRUE(m\_cref.Matches(quiet\_nan));}
\DoxyCodeLine{02329\ \ \ EXPECT\_TRUE(m\_cref.Matches(other\_nan));}
\DoxyCodeLine{02330\ \ \ EXPECT\_FALSE(m\_cref.Matches(real\_value));}
\DoxyCodeLine{02331\ \}}
\DoxyCodeLine{02332\ }
\DoxyCodeLine{02333\ \textcolor{comment}{//\ Tests\ that\ IsNan()\ works\ with\ Not.}}
\DoxyCodeLine{02334\ TEST(IsNan,\ NotMatchesNan)\ \{}
\DoxyCodeLine{02335\ \ \ Matcher<float>\ mf\ =\ Not(IsNan());}
\DoxyCodeLine{02336\ \ \ EXPECT\_FALSE(mf.Matches(std::numeric\_limits<float>::quiet\_NaN()));}
\DoxyCodeLine{02337\ \ \ EXPECT\_FALSE(mf.Matches(std::nanf(\textcolor{stringliteral}{"{}1"{}})));}
\DoxyCodeLine{02338\ \ \ EXPECT\_TRUE(mf.Matches(1.0));}
\DoxyCodeLine{02339\ }
\DoxyCodeLine{02340\ \ \ Matcher<double>\ md\ =\ Not(IsNan());}
\DoxyCodeLine{02341\ \ \ EXPECT\_FALSE(md.Matches(std::numeric\_limits<double>::quiet\_NaN()));}
\DoxyCodeLine{02342\ \ \ EXPECT\_FALSE(md.Matches(std::nan(\textcolor{stringliteral}{"{}1"{}})));}
\DoxyCodeLine{02343\ \ \ EXPECT\_TRUE(md.Matches(1.0));}
\DoxyCodeLine{02344\ }
\DoxyCodeLine{02345\ \ \ Matcher<long\ double>\ mld\ =\ Not(IsNan());}
\DoxyCodeLine{02346\ \ \ EXPECT\_FALSE(mld.Matches(std::numeric\_limits<long\ double>::quiet\_NaN()));}
\DoxyCodeLine{02347\ \ \ EXPECT\_FALSE(mld.Matches(std::nanl(\textcolor{stringliteral}{"{}1"{}})));}
\DoxyCodeLine{02348\ \ \ EXPECT\_TRUE(mld.Matches(1.0));}
\DoxyCodeLine{02349\ \}}
\DoxyCodeLine{02350\ }
\DoxyCodeLine{02351\ \textcolor{comment}{//\ Tests\ that\ IsNan()\ can\ describe\ itself.}}
\DoxyCodeLine{02352\ TEST(IsNan,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02353\ \ \ Matcher<float>\ mf\ =\ IsNan();}
\DoxyCodeLine{02354\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ NaN"{}},\ Describe(mf));}
\DoxyCodeLine{02355\ }
\DoxyCodeLine{02356\ \ \ Matcher<double>\ md\ =\ IsNan();}
\DoxyCodeLine{02357\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ NaN"{}},\ Describe(md));}
\DoxyCodeLine{02358\ }
\DoxyCodeLine{02359\ \ \ Matcher<long\ double>\ mld\ =\ IsNan();}
\DoxyCodeLine{02360\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ NaN"{}},\ Describe(mld));}
\DoxyCodeLine{02361\ \}}
\DoxyCodeLine{02362\ }
\DoxyCodeLine{02363\ \textcolor{comment}{//\ Tests\ that\ IsNan()\ can\ describe\ itself\ with\ Not.}}
\DoxyCodeLine{02364\ TEST(IsNan,\ CanDescribeSelfWithNot)\ \{}
\DoxyCodeLine{02365\ \ \ Matcher<float>\ mf\ =\ Not(IsNan());}
\DoxyCodeLine{02366\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NaN"{}},\ Describe(mf));}
\DoxyCodeLine{02367\ }
\DoxyCodeLine{02368\ \ \ Matcher<double>\ md\ =\ Not(IsNan());}
\DoxyCodeLine{02369\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NaN"{}},\ Describe(md));}
\DoxyCodeLine{02370\ }
\DoxyCodeLine{02371\ \ \ Matcher<long\ double>\ mld\ =\ Not(IsNan());}
\DoxyCodeLine{02372\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NaN"{}},\ Describe(mld));}
\DoxyCodeLine{02373\ \}}
\DoxyCodeLine{02374\ }
\DoxyCodeLine{02375\ \textcolor{comment}{//\ Tests\ that\ FloatEq()\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{02376\ \textcolor{comment}{//\ FloatEq(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{02377\ TEST(FloatEq2Test,\ MatchesEqualArguments)\ \{}
\DoxyCodeLine{02378\ \ \ typedef\ ::std::tuple<float,\ float>\ Tpl;}
\DoxyCodeLine{02379\ \ \ Matcher<const\ Tpl\&>\ m\ =\ FloatEq();}
\DoxyCodeLine{02380\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.0f,\ 1.0f)));}
\DoxyCodeLine{02381\ \ \ EXPECT\_TRUE(m.Matches(Tpl(0.3f,\ 0.1f\ +\ 0.1f\ +\ 0.1f)));}
\DoxyCodeLine{02382\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.1f,\ 1.0f)));}
\DoxyCodeLine{02383\ \}}
\DoxyCodeLine{02384\ }
\DoxyCodeLine{02385\ \textcolor{comment}{//\ Tests\ that\ FloatEq()\ describes\ itself\ properly.}}
\DoxyCodeLine{02386\ TEST(FloatEq2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02387\ \ \ Matcher<const\ ::std::tuple<float,\ float>\&>\ m\ =\ FloatEq();}
\DoxyCodeLine{02388\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ almost-\/equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02389\ \}}
\DoxyCodeLine{02390\ }
\DoxyCodeLine{02391\ \textcolor{comment}{//\ Tests\ that\ NanSensitiveFloatEq()\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{02392\ \textcolor{comment}{//\ NanSensitiveFloatEq(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{02393\ TEST(NanSensitiveFloatEqTest,\ MatchesEqualArgumentsWithNaN)\ \{}
\DoxyCodeLine{02394\ \ \ typedef\ ::std::tuple<float,\ float>\ Tpl;}
\DoxyCodeLine{02395\ \ \ Matcher<const\ Tpl\&>\ m\ =\ NanSensitiveFloatEq();}
\DoxyCodeLine{02396\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.0f,\ 1.0f)));}
\DoxyCodeLine{02397\ \ \ EXPECT\_TRUE(m.Matches(Tpl(std::numeric\_limits<float>::quiet\_NaN(),}
\DoxyCodeLine{02398\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::numeric\_limits<float>::quiet\_NaN())));}
\DoxyCodeLine{02399\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.1f,\ 1.0f)));}
\DoxyCodeLine{02400\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.0f,\ std::numeric\_limits<float>::quiet\_NaN())));}
\DoxyCodeLine{02401\ \ \ EXPECT\_FALSE(m.Matches(Tpl(std::numeric\_limits<float>::quiet\_NaN(),\ 1.0f)));}
\DoxyCodeLine{02402\ \}}
\DoxyCodeLine{02403\ }
\DoxyCodeLine{02404\ \textcolor{comment}{//\ Tests\ that\ NanSensitiveFloatEq()\ describes\ itself\ properly.}}
\DoxyCodeLine{02405\ TEST(NanSensitiveFloatEqTest,\ CanDescribeSelfWithNaNs)\ \{}
\DoxyCodeLine{02406\ \ \ Matcher<const\ ::std::tuple<float,\ float>\&>\ m\ =\ NanSensitiveFloatEq();}
\DoxyCodeLine{02407\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ almost-\/equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02408\ \}}
\DoxyCodeLine{02409\ }
\DoxyCodeLine{02410\ \textcolor{comment}{//\ Tests\ that\ DoubleEq()\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{02411\ \textcolor{comment}{//\ DoubleEq(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{02412\ TEST(DoubleEq2Test,\ MatchesEqualArguments)\ \{}
\DoxyCodeLine{02413\ \ \ typedef\ ::std::tuple<double,\ double>\ Tpl;}
\DoxyCodeLine{02414\ \ \ Matcher<const\ Tpl\&>\ m\ =\ DoubleEq();}
\DoxyCodeLine{02415\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.0,\ 1.0)));}
\DoxyCodeLine{02416\ \ \ EXPECT\_TRUE(m.Matches(Tpl(0.3,\ 0.1\ +\ 0.1\ +\ 0.1)));}
\DoxyCodeLine{02417\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.1,\ 1.0)));}
\DoxyCodeLine{02418\ \}}
\DoxyCodeLine{02419\ }
\DoxyCodeLine{02420\ \textcolor{comment}{//\ Tests\ that\ DoubleEq()\ describes\ itself\ properly.}}
\DoxyCodeLine{02421\ TEST(DoubleEq2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02422\ \ \ Matcher<const\ ::std::tuple<double,\ double>\&>\ m\ =\ DoubleEq();}
\DoxyCodeLine{02423\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ almost-\/equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02424\ \}}
\DoxyCodeLine{02425\ }
\DoxyCodeLine{02426\ \textcolor{comment}{//\ Tests\ that\ NanSensitiveDoubleEq()\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{02427\ \textcolor{comment}{//\ NanSensitiveDoubleEq(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{02428\ TEST(NanSensitiveDoubleEqTest,\ MatchesEqualArgumentsWithNaN)\ \{}
\DoxyCodeLine{02429\ \ \ typedef\ ::std::tuple<double,\ double>\ Tpl;}
\DoxyCodeLine{02430\ \ \ Matcher<const\ Tpl\&>\ m\ =\ NanSensitiveDoubleEq();}
\DoxyCodeLine{02431\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.0f,\ 1.0f)));}
\DoxyCodeLine{02432\ \ \ EXPECT\_TRUE(m.Matches(Tpl(std::numeric\_limits<double>::quiet\_NaN(),}
\DoxyCodeLine{02433\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::numeric\_limits<double>::quiet\_NaN())));}
\DoxyCodeLine{02434\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.1f,\ 1.0f)));}
\DoxyCodeLine{02435\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.0f,\ std::numeric\_limits<double>::quiet\_NaN())));}
\DoxyCodeLine{02436\ \ \ EXPECT\_FALSE(m.Matches(Tpl(std::numeric\_limits<double>::quiet\_NaN(),\ 1.0f)));}
\DoxyCodeLine{02437\ \}}
\DoxyCodeLine{02438\ }
\DoxyCodeLine{02439\ \textcolor{comment}{//\ Tests\ that\ DoubleEq()\ describes\ itself\ properly.}}
\DoxyCodeLine{02440\ TEST(NanSensitiveDoubleEqTest,\ CanDescribeSelfWithNaNs)\ \{}
\DoxyCodeLine{02441\ \ \ Matcher<const\ ::std::tuple<double,\ double>\&>\ m\ =\ NanSensitiveDoubleEq();}
\DoxyCodeLine{02442\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ almost-\/equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02443\ \}}
\DoxyCodeLine{02444\ }
\DoxyCodeLine{02445\ \textcolor{comment}{//\ Tests\ that\ FloatEq()\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{02446\ \textcolor{comment}{//\ FloatNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field.}}
\DoxyCodeLine{02447\ TEST(FloatNear2Test,\ MatchesEqualArguments)\ \{}
\DoxyCodeLine{02448\ \ \ typedef\ ::std::tuple<float,\ float>\ Tpl;}
\DoxyCodeLine{02449\ \ \ Matcher<const\ Tpl\&>\ m\ =\ FloatNear(0.5f);}
\DoxyCodeLine{02450\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.0f,\ 1.0f)));}
\DoxyCodeLine{02451\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.3f,\ 1.0f)));}
\DoxyCodeLine{02452\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.8f,\ 1.0f)));}
\DoxyCodeLine{02453\ \}}
\DoxyCodeLine{02454\ }
\DoxyCodeLine{02455\ \textcolor{comment}{//\ Tests\ that\ FloatNear()\ describes\ itself\ properly.}}
\DoxyCodeLine{02456\ TEST(FloatNear2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02457\ \ \ Matcher<const\ ::std::tuple<float,\ float>\&>\ m\ =\ FloatNear(0.5f);}
\DoxyCodeLine{02458\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ almost-\/equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02459\ \}}
\DoxyCodeLine{02460\ }
\DoxyCodeLine{02461\ \textcolor{comment}{//\ Tests\ that\ NanSensitiveFloatNear()\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{02462\ \textcolor{comment}{//\ NanSensitiveFloatNear(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{02463\ TEST(NanSensitiveFloatNearTest,\ MatchesNearbyArgumentsWithNaN)\ \{}
\DoxyCodeLine{02464\ \ \ typedef\ ::std::tuple<float,\ float>\ Tpl;}
\DoxyCodeLine{02465\ \ \ Matcher<const\ Tpl\&>\ m\ =\ NanSensitiveFloatNear(0.5f);}
\DoxyCodeLine{02466\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.0f,\ 1.0f)));}
\DoxyCodeLine{02467\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.1f,\ 1.0f)));}
\DoxyCodeLine{02468\ \ \ EXPECT\_TRUE(m.Matches(Tpl(std::numeric\_limits<float>::quiet\_NaN(),}
\DoxyCodeLine{02469\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::numeric\_limits<float>::quiet\_NaN())));}
\DoxyCodeLine{02470\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.6f,\ 1.0f)));}
\DoxyCodeLine{02471\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.0f,\ std::numeric\_limits<float>::quiet\_NaN())));}
\DoxyCodeLine{02472\ \ \ EXPECT\_FALSE(m.Matches(Tpl(std::numeric\_limits<float>::quiet\_NaN(),\ 1.0f)));}
\DoxyCodeLine{02473\ \}}
\DoxyCodeLine{02474\ }
\DoxyCodeLine{02475\ \textcolor{comment}{//\ Tests\ that\ NanSensitiveFloatNear()\ describes\ itself\ properly.}}
\DoxyCodeLine{02476\ TEST(NanSensitiveFloatNearTest,\ CanDescribeSelfWithNaNs)\ \{}
\DoxyCodeLine{02477\ \ \ Matcher<const\ ::std::tuple<float,\ float>\&>\ m\ =\ NanSensitiveFloatNear(0.5f);}
\DoxyCodeLine{02478\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ almost-\/equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02479\ \}}
\DoxyCodeLine{02480\ }
\DoxyCodeLine{02481\ \textcolor{comment}{//\ Tests\ that\ FloatEq()\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{02482\ \textcolor{comment}{//\ DoubleNear(first\ field,\ max\_abs\_error)\ matches\ the\ second\ field.}}
\DoxyCodeLine{02483\ TEST(DoubleNear2Test,\ MatchesEqualArguments)\ \{}
\DoxyCodeLine{02484\ \ \ typedef\ ::std::tuple<double,\ double>\ Tpl;}
\DoxyCodeLine{02485\ \ \ Matcher<const\ Tpl\&>\ m\ =\ DoubleNear(0.5);}
\DoxyCodeLine{02486\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.0,\ 1.0)));}
\DoxyCodeLine{02487\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.3,\ 1.0)));}
\DoxyCodeLine{02488\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.8,\ 1.0)));}
\DoxyCodeLine{02489\ \}}
\DoxyCodeLine{02490\ }
\DoxyCodeLine{02491\ \textcolor{comment}{//\ Tests\ that\ DoubleNear()\ describes\ itself\ properly.}}
\DoxyCodeLine{02492\ TEST(DoubleNear2Test,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02493\ \ \ Matcher<const\ ::std::tuple<double,\ double>\&>\ m\ =\ DoubleNear(0.5);}
\DoxyCodeLine{02494\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ almost-\/equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02495\ \}}
\DoxyCodeLine{02496\ }
\DoxyCodeLine{02497\ \textcolor{comment}{//\ Tests\ that\ NanSensitiveDoubleNear()\ matches\ a\ 2-\/tuple\ where}}
\DoxyCodeLine{02498\ \textcolor{comment}{//\ NanSensitiveDoubleNear(first\ field)\ matches\ the\ second\ field.}}
\DoxyCodeLine{02499\ TEST(NanSensitiveDoubleNearTest,\ MatchesNearbyArgumentsWithNaN)\ \{}
\DoxyCodeLine{02500\ \ \ typedef\ ::std::tuple<double,\ double>\ Tpl;}
\DoxyCodeLine{02501\ \ \ Matcher<const\ Tpl\&>\ m\ =\ NanSensitiveDoubleNear(0.5f);}
\DoxyCodeLine{02502\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.0f,\ 1.0f)));}
\DoxyCodeLine{02503\ \ \ EXPECT\_TRUE(m.Matches(Tpl(1.1f,\ 1.0f)));}
\DoxyCodeLine{02504\ \ \ EXPECT\_TRUE(m.Matches(Tpl(std::numeric\_limits<double>::quiet\_NaN(),}
\DoxyCodeLine{02505\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::numeric\_limits<double>::quiet\_NaN())));}
\DoxyCodeLine{02506\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.6f,\ 1.0f)));}
\DoxyCodeLine{02507\ \ \ EXPECT\_FALSE(m.Matches(Tpl(1.0f,\ std::numeric\_limits<double>::quiet\_NaN())));}
\DoxyCodeLine{02508\ \ \ EXPECT\_FALSE(m.Matches(Tpl(std::numeric\_limits<double>::quiet\_NaN(),\ 1.0f)));}
\DoxyCodeLine{02509\ \}}
\DoxyCodeLine{02510\ }
\DoxyCodeLine{02511\ \textcolor{comment}{//\ Tests\ that\ NanSensitiveDoubleNear()\ describes\ itself\ properly.}}
\DoxyCodeLine{02512\ TEST(NanSensitiveDoubleNearTest,\ CanDescribeSelfWithNaNs)\ \{}
\DoxyCodeLine{02513\ \ \ Matcher<const\ ::std::tuple<double,\ double>\&>\ m\ =\ NanSensitiveDoubleNear(0.5f);}
\DoxyCodeLine{02514\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ an\ almost-\/equal\ pair"{}},\ Describe(m));}
\DoxyCodeLine{02515\ \}}
\DoxyCodeLine{02516\ }
\DoxyCodeLine{02517\ \textcolor{comment}{//\ Tests\ that\ Not(m)\ matches\ any\ value\ that\ doesn't\ match\ m.}}
\DoxyCodeLine{02518\ TEST(NotTest,\ NegatesMatcher)\ \{}
\DoxyCodeLine{02519\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02520\ \ \ m\ =\ Not(Eq(2));}
\DoxyCodeLine{02521\ \ \ EXPECT\_TRUE(m.Matches(3));}
\DoxyCodeLine{02522\ \ \ EXPECT\_FALSE(m.Matches(2));}
\DoxyCodeLine{02523\ \}}
\DoxyCodeLine{02524\ }
\DoxyCodeLine{02525\ \textcolor{comment}{//\ Tests\ that\ Not(m)\ describes\ itself\ properly.}}
\DoxyCodeLine{02526\ TEST(NotTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02527\ \ \ Matcher<int>\ m\ =\ Not(Eq(5));}
\DoxyCodeLine{02528\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ equal\ to\ 5"{}},\ Describe(m));}
\DoxyCodeLine{02529\ \}}
\DoxyCodeLine{02530\ }
\DoxyCodeLine{02531\ \textcolor{comment}{//\ Tests\ that\ monomorphic\ matchers\ are\ safely\ cast\ by\ the\ Not\ matcher.}}
\DoxyCodeLine{02532\ TEST(NotTest,\ NotMatcherSafelyCastsMonomorphicMatchers)\ \{}
\DoxyCodeLine{02533\ \ \ \textcolor{comment}{//\ greater\_than\_5\ is\ a\ monomorphic\ matcher.}}
\DoxyCodeLine{02534\ \ \ Matcher<int>\ greater\_than\_5\ =\ Gt(5);}
\DoxyCodeLine{02535\ }
\DoxyCodeLine{02536\ \ \ Matcher<const\ int\&>\ m\ =\ Not(greater\_than\_5);}
\DoxyCodeLine{02537\ \ \ Matcher<int\&>\ m2\ =\ Not(greater\_than\_5);}
\DoxyCodeLine{02538\ \ \ Matcher<int\&>\ m3\ =\ Not(m);}
\DoxyCodeLine{02539\ \}}
\DoxyCodeLine{02540\ }
\DoxyCodeLine{02541\ \textcolor{comment}{//\ Helper\ to\ allow\ easy\ testing\ of\ AllOf\ matchers\ with\ num\ parameters.}}
\DoxyCodeLine{02542\ \textcolor{keywordtype}{void}\ AllOfMatches(\textcolor{keywordtype}{int}\ num,\ \textcolor{keyword}{const}\ Matcher<int>\&\ m)\ \{}
\DoxyCodeLine{02543\ \ \ SCOPED\_TRACE(Describe(m));}
\DoxyCodeLine{02544\ \ \ EXPECT\_TRUE(m.Matches(0));}
\DoxyCodeLine{02545\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 1;\ i\ <=\ num;\ ++i)\ \{}
\DoxyCodeLine{02546\ \ \ \ \ EXPECT\_FALSE(m.Matches(i));}
\DoxyCodeLine{02547\ \ \ \}}
\DoxyCodeLine{02548\ \ \ EXPECT\_TRUE(m.Matches(num\ +\ 1));}
\DoxyCodeLine{02549\ \}}
\DoxyCodeLine{02550\ }
\DoxyCodeLine{02551\ \textcolor{comment}{//\ Tests\ that\ AllOf(m1,\ ...,\ mn)\ matches\ any\ value\ that\ matches\ all\ of}}
\DoxyCodeLine{02552\ \textcolor{comment}{//\ the\ given\ matchers.}}
\DoxyCodeLine{02553\ TEST(AllOfTest,\ MatchesWhenAllMatch)\ \{}
\DoxyCodeLine{02554\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02555\ \ \ m\ =\ AllOf(Le(2),\ Ge(1));}
\DoxyCodeLine{02556\ \ \ EXPECT\_TRUE(m.Matches(1));}
\DoxyCodeLine{02557\ \ \ EXPECT\_TRUE(m.Matches(2));}
\DoxyCodeLine{02558\ \ \ EXPECT\_FALSE(m.Matches(0));}
\DoxyCodeLine{02559\ \ \ EXPECT\_FALSE(m.Matches(3));}
\DoxyCodeLine{02560\ }
\DoxyCodeLine{02561\ \ \ m\ =\ AllOf(Gt(0),\ Ne(1),\ Ne(2));}
\DoxyCodeLine{02562\ \ \ EXPECT\_TRUE(m.Matches(3));}
\DoxyCodeLine{02563\ \ \ EXPECT\_FALSE(m.Matches(2));}
\DoxyCodeLine{02564\ \ \ EXPECT\_FALSE(m.Matches(1));}
\DoxyCodeLine{02565\ \ \ EXPECT\_FALSE(m.Matches(0));}
\DoxyCodeLine{02566\ }
\DoxyCodeLine{02567\ \ \ m\ =\ AllOf(Gt(0),\ Ne(1),\ Ne(2),\ Ne(3));}
\DoxyCodeLine{02568\ \ \ EXPECT\_TRUE(m.Matches(4));}
\DoxyCodeLine{02569\ \ \ EXPECT\_FALSE(m.Matches(3));}
\DoxyCodeLine{02570\ \ \ EXPECT\_FALSE(m.Matches(2));}
\DoxyCodeLine{02571\ \ \ EXPECT\_FALSE(m.Matches(1));}
\DoxyCodeLine{02572\ \ \ EXPECT\_FALSE(m.Matches(0));}
\DoxyCodeLine{02573\ }
\DoxyCodeLine{02574\ \ \ m\ =\ AllOf(Ge(0),\ Lt(10),\ Ne(3),\ Ne(5),\ Ne(7));}
\DoxyCodeLine{02575\ \ \ EXPECT\_TRUE(m.Matches(0));}
\DoxyCodeLine{02576\ \ \ EXPECT\_TRUE(m.Matches(1));}
\DoxyCodeLine{02577\ \ \ EXPECT\_FALSE(m.Matches(3));}
\DoxyCodeLine{02578\ }
\DoxyCodeLine{02579\ \ \ \textcolor{comment}{//\ The\ following\ tests\ for\ varying\ number\ of\ sub-\/matchers.\ Due\ to\ the\ way}}
\DoxyCodeLine{02580\ \ \ \textcolor{comment}{//\ the\ sub-\/matchers\ are\ handled\ it\ is\ enough\ to\ test\ every\ sub-\/matcher\ once}}
\DoxyCodeLine{02581\ \ \ \textcolor{comment}{//\ with\ sub-\/matchers\ using\ the\ same\ matcher\ type.\ Varying\ matcher\ types\ are}}
\DoxyCodeLine{02582\ \ \ \textcolor{comment}{//\ checked\ for\ above.}}
\DoxyCodeLine{02583\ \ \ AllOfMatches(2,\ AllOf(Ne(1),\ Ne(2)));}
\DoxyCodeLine{02584\ \ \ AllOfMatches(3,\ AllOf(Ne(1),\ Ne(2),\ Ne(3)));}
\DoxyCodeLine{02585\ \ \ AllOfMatches(4,\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4)));}
\DoxyCodeLine{02586\ \ \ AllOfMatches(5,\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4),\ Ne(5)));}
\DoxyCodeLine{02587\ \ \ AllOfMatches(6,\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4),\ Ne(5),\ Ne(6)));}
\DoxyCodeLine{02588\ \ \ AllOfMatches(7,\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4),\ Ne(5),\ Ne(6),\ Ne(7)));}
\DoxyCodeLine{02589\ \ \ AllOfMatches(8,\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4),\ Ne(5),\ Ne(6),\ Ne(7),}
\DoxyCodeLine{02590\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(8)));}
\DoxyCodeLine{02591\ \ \ AllOfMatches(9,\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4),\ Ne(5),\ Ne(6),\ Ne(7),}
\DoxyCodeLine{02592\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(8),\ Ne(9)));}
\DoxyCodeLine{02593\ \ \ AllOfMatches(10,\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4),\ Ne(5),\ Ne(6),\ Ne(7),\ Ne(8),}
\DoxyCodeLine{02594\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(9),\ Ne(10)));}
\DoxyCodeLine{02595\ \ \ AllOfMatches(}
\DoxyCodeLine{02596\ \ \ \ \ \ \ 50,\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4),\ Ne(5),\ Ne(6),\ Ne(7),\ Ne(8),\ Ne(9),}
\DoxyCodeLine{02597\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(10),\ Ne(11),\ Ne(12),\ Ne(13),\ Ne(14),\ Ne(15),\ Ne(16),\ Ne(17),}
\DoxyCodeLine{02598\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(18),\ Ne(19),\ Ne(20),\ Ne(21),\ Ne(22),\ Ne(23),\ Ne(24),\ Ne(25),}
\DoxyCodeLine{02599\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(26),\ Ne(27),\ Ne(28),\ Ne(29),\ Ne(30),\ Ne(31),\ Ne(32),\ Ne(33),}
\DoxyCodeLine{02600\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(34),\ Ne(35),\ Ne(36),\ Ne(37),\ Ne(38),\ Ne(39),\ Ne(40),\ Ne(41),}
\DoxyCodeLine{02601\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(42),\ Ne(43),\ Ne(44),\ Ne(45),\ Ne(46),\ Ne(47),\ Ne(48),\ Ne(49),}
\DoxyCodeLine{02602\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Ne(50)));}
\DoxyCodeLine{02603\ \}}
\DoxyCodeLine{02604\ }
\DoxyCodeLine{02605\ }
\DoxyCodeLine{02606\ \textcolor{comment}{//\ Tests\ that\ AllOf(m1,\ ...,\ mn)\ describes\ itself\ properly.}}
\DoxyCodeLine{02607\ TEST(AllOfTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02608\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02609\ \ \ m\ =\ AllOf(Le(2),\ Ge(1));}
\DoxyCodeLine{02610\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(is\ <=\ 2)\ and\ (is\ >=\ 1)"{}},\ Describe(m));}
\DoxyCodeLine{02611\ }
\DoxyCodeLine{02612\ \ \ m\ =\ AllOf(Gt(0),\ Ne(1),\ Ne(2));}
\DoxyCodeLine{02613\ \ \ std::string\ expected\_descr1\ =}
\DoxyCodeLine{02614\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(is\ >\ 0)\ and\ (isn't\ equal\ to\ 1)\ and\ (isn't\ equal\ to\ 2)"{}};}
\DoxyCodeLine{02615\ \ \ EXPECT\_EQ(expected\_descr1,\ Describe(m));}
\DoxyCodeLine{02616\ }
\DoxyCodeLine{02617\ \ \ m\ =\ AllOf(Gt(0),\ Ne(1),\ Ne(2),\ Ne(3));}
\DoxyCodeLine{02618\ \ \ std::string\ expected\_descr2\ =}
\DoxyCodeLine{02619\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(is\ >\ 0)\ and\ (isn't\ equal\ to\ 1)\ and\ (isn't\ equal\ to\ 2)\ and\ (isn't\ equal\ "{}}}
\DoxyCodeLine{02620\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}to\ 3)"{}};}
\DoxyCodeLine{02621\ \ \ EXPECT\_EQ(expected\_descr2,\ Describe(m));}
\DoxyCodeLine{02622\ }
\DoxyCodeLine{02623\ \ \ m\ =\ AllOf(Ge(0),\ Lt(10),\ Ne(3),\ Ne(5),\ Ne(7));}
\DoxyCodeLine{02624\ \ \ std::string\ expected\_descr3\ =}
\DoxyCodeLine{02625\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(is\ >=\ 0)\ and\ (is\ <\ 10)\ and\ (isn't\ equal\ to\ 3)\ and\ (isn't\ equal\ to\ 5)\ "{}}}
\DoxyCodeLine{02626\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\ (isn't\ equal\ to\ 7)"{}};}
\DoxyCodeLine{02627\ \ \ EXPECT\_EQ(expected\_descr3,\ Describe(m));}
\DoxyCodeLine{02628\ \}}
\DoxyCodeLine{02629\ }
\DoxyCodeLine{02630\ \textcolor{comment}{//\ Tests\ that\ AllOf(m1,\ ...,\ mn)\ describes\ its\ negation\ properly.}}
\DoxyCodeLine{02631\ TEST(AllOfTest,\ CanDescribeNegation)\ \{}
\DoxyCodeLine{02632\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02633\ \ \ m\ =\ AllOf(Le(2),\ Ge(1));}
\DoxyCodeLine{02634\ \ \ std::string\ expected\_descr4\ =\ \textcolor{stringliteral}{"{}(isn't\ <=\ 2)\ or\ (isn't\ >=\ 1)"{}};}
\DoxyCodeLine{02635\ \ \ EXPECT\_EQ(expected\_descr4,\ DescribeNegation(m));}
\DoxyCodeLine{02636\ }
\DoxyCodeLine{02637\ \ \ m\ =\ AllOf(Gt(0),\ Ne(1),\ Ne(2));}
\DoxyCodeLine{02638\ \ \ std::string\ expected\_descr5\ =}
\DoxyCodeLine{02639\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(isn't\ >\ 0)\ or\ (is\ equal\ to\ 1)\ or\ (is\ equal\ to\ 2)"{}};}
\DoxyCodeLine{02640\ \ \ EXPECT\_EQ(expected\_descr5,\ DescribeNegation(m));}
\DoxyCodeLine{02641\ }
\DoxyCodeLine{02642\ \ \ m\ =\ AllOf(Gt(0),\ Ne(1),\ Ne(2),\ Ne(3));}
\DoxyCodeLine{02643\ \ \ std::string\ expected\_descr6\ =}
\DoxyCodeLine{02644\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(isn't\ >\ 0)\ or\ (is\ equal\ to\ 1)\ or\ (is\ equal\ to\ 2)\ or\ (is\ equal\ to\ 3)"{}};}
\DoxyCodeLine{02645\ \ \ EXPECT\_EQ(expected\_descr6,\ DescribeNegation(m));}
\DoxyCodeLine{02646\ }
\DoxyCodeLine{02647\ \ \ m\ =\ AllOf(Ge(0),\ Lt(10),\ Ne(3),\ Ne(5),\ Ne(7));}
\DoxyCodeLine{02648\ \ \ std::string\ expected\_desr7\ =}
\DoxyCodeLine{02649\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(isn't\ >=\ 0)\ or\ (isn't\ <\ 10)\ or\ (is\ equal\ to\ 3)\ or\ (is\ equal\ to\ 5)\ or\ "{}}}
\DoxyCodeLine{02650\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(is\ equal\ to\ 7)"{}};}
\DoxyCodeLine{02651\ \ \ EXPECT\_EQ(expected\_desr7,\ DescribeNegation(m));}
\DoxyCodeLine{02652\ }
\DoxyCodeLine{02653\ \ \ m\ =\ AllOf(Ne(1),\ Ne(2),\ Ne(3),\ Ne(4),\ Ne(5),\ Ne(6),\ Ne(7),\ Ne(8),\ Ne(9),}
\DoxyCodeLine{02654\ \ \ \ \ \ \ \ \ \ \ \ \ Ne(10),\ Ne(11));}
\DoxyCodeLine{02655\ \ \ AllOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ 10,\ 11);}
\DoxyCodeLine{02656\ \ \ EXPECT\_THAT(Describe(m),\ EndsWith(\textcolor{stringliteral}{"{}and\ (isn't\ equal\ to\ 11)"{}}));}
\DoxyCodeLine{02657\ \ \ AllOfMatches(11,\ m);}
\DoxyCodeLine{02658\ \}}
\DoxyCodeLine{02659\ }
\DoxyCodeLine{02660\ \textcolor{comment}{//\ Tests\ that\ monomorphic\ matchers\ are\ safely\ cast\ by\ the\ AllOf\ matcher.}}
\DoxyCodeLine{02661\ TEST(AllOfTest,\ AllOfMatcherSafelyCastsMonomorphicMatchers)\ \{}
\DoxyCodeLine{02662\ \ \ \textcolor{comment}{//\ greater\_than\_5\ and\ less\_than\_10\ are\ monomorphic\ matchers.}}
\DoxyCodeLine{02663\ \ \ Matcher<int>\ greater\_than\_5\ =\ Gt(5);}
\DoxyCodeLine{02664\ \ \ Matcher<int>\ less\_than\_10\ =\ Lt(10);}
\DoxyCodeLine{02665\ }
\DoxyCodeLine{02666\ \ \ Matcher<const\ int\&>\ m\ =\ AllOf(greater\_than\_5,\ less\_than\_10);}
\DoxyCodeLine{02667\ \ \ Matcher<int\&>\ m2\ =\ AllOf(greater\_than\_5,\ less\_than\_10);}
\DoxyCodeLine{02668\ \ \ Matcher<int\&>\ m3\ =\ AllOf(greater\_than\_5,\ m2);}
\DoxyCodeLine{02669\ }
\DoxyCodeLine{02670\ \ \ \textcolor{comment}{//\ Tests\ that\ BothOf\ works\ when\ composing\ itself.}}
\DoxyCodeLine{02671\ \ \ Matcher<const\ int\&>\ m4\ =\ AllOf(greater\_than\_5,\ less\_than\_10,\ less\_than\_10);}
\DoxyCodeLine{02672\ \ \ Matcher<int\&>\ m5\ =\ AllOf(greater\_than\_5,\ less\_than\_10,\ less\_than\_10);}
\DoxyCodeLine{02673\ \}}
\DoxyCodeLine{02674\ }
\DoxyCodeLine{02675\ TEST(AllOfTest,\ ExplainsResult)\ \{}
\DoxyCodeLine{02676\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02677\ }
\DoxyCodeLine{02678\ \ \ \textcolor{comment}{//\ Successful\ match.\ \ Both\ matchers\ need\ to\ explain.\ \ The\ second}}
\DoxyCodeLine{02679\ \ \ \textcolor{comment}{//\ matcher\ doesn't\ give\ an\ explanation,\ so\ only\ the\ first\ matcher's}}
\DoxyCodeLine{02680\ \ \ \textcolor{comment}{//\ explanation\ is\ printed.}}
\DoxyCodeLine{02681\ \ \ m\ =\ AllOf(GreaterThan(10),\ Lt(30));}
\DoxyCodeLine{02682\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 15\ more\ than\ 10"{}},\ Explain(m,\ 25));}
\DoxyCodeLine{02683\ }
\DoxyCodeLine{02684\ \ \ \textcolor{comment}{//\ Successful\ match.\ \ Both\ matchers\ need\ to\ explain.}}
\DoxyCodeLine{02685\ \ \ m\ =\ AllOf(GreaterThan(10),\ GreaterThan(20));}
\DoxyCodeLine{02686\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 20\ more\ than\ 10,\ and\ which\ is\ 10\ more\ than\ 20"{}},}
\DoxyCodeLine{02687\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ 30));}
\DoxyCodeLine{02688\ }
\DoxyCodeLine{02689\ \ \ \textcolor{comment}{//\ Successful\ match.\ \ All\ matchers\ need\ to\ explain.\ \ The\ second}}
\DoxyCodeLine{02690\ \ \ \textcolor{comment}{//\ matcher\ doesn't\ given\ an\ explanation.}}
\DoxyCodeLine{02691\ \ \ m\ =\ AllOf(GreaterThan(10),\ Lt(30),\ GreaterThan(20));}
\DoxyCodeLine{02692\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 15\ more\ than\ 10,\ and\ which\ is\ 5\ more\ than\ 20"{}},}
\DoxyCodeLine{02693\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ 25));}
\DoxyCodeLine{02694\ }
\DoxyCodeLine{02695\ \ \ \textcolor{comment}{//\ Successful\ match.\ \ All\ matchers\ need\ to\ explain.}}
\DoxyCodeLine{02696\ \ \ m\ =\ AllOf(GreaterThan(10),\ GreaterThan(20),\ GreaterThan(30));}
\DoxyCodeLine{02697\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 30\ more\ than\ 10,\ and\ which\ is\ 20\ more\ than\ 20,\ "{}}}
\DoxyCodeLine{02698\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\ which\ is\ 10\ more\ than\ 30"{}},}
\DoxyCodeLine{02699\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ 40));}
\DoxyCodeLine{02700\ }
\DoxyCodeLine{02701\ \ \ \textcolor{comment}{//\ Failed\ match.\ \ The\ first\ matcher,\ which\ failed,\ needs\ to}}
\DoxyCodeLine{02702\ \ \ \textcolor{comment}{//\ explain.}}
\DoxyCodeLine{02703\ \ \ m\ =\ AllOf(GreaterThan(10),\ GreaterThan(20));}
\DoxyCodeLine{02704\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 5\ less\ than\ 10"{}},\ Explain(m,\ 5));}
\DoxyCodeLine{02705\ }
\DoxyCodeLine{02706\ \ \ \textcolor{comment}{//\ Failed\ match.\ \ The\ second\ matcher,\ which\ failed,\ needs\ to}}
\DoxyCodeLine{02707\ \ \ \textcolor{comment}{//\ explain.\ \ Since\ it\ doesn't\ given\ an\ explanation,\ nothing\ is}}
\DoxyCodeLine{02708\ \ \ \textcolor{comment}{//\ printed.}}
\DoxyCodeLine{02709\ \ \ m\ =\ AllOf(GreaterThan(10),\ Lt(30));}
\DoxyCodeLine{02710\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 40));}
\DoxyCodeLine{02711\ }
\DoxyCodeLine{02712\ \ \ \textcolor{comment}{//\ Failed\ match.\ \ The\ second\ matcher,\ which\ failed,\ needs\ to}}
\DoxyCodeLine{02713\ \ \ \textcolor{comment}{//\ explain.}}
\DoxyCodeLine{02714\ \ \ m\ =\ AllOf(GreaterThan(10),\ GreaterThan(20));}
\DoxyCodeLine{02715\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 5\ less\ than\ 20"{}},\ Explain(m,\ 15));}
\DoxyCodeLine{02716\ \}}
\DoxyCodeLine{02717\ }
\DoxyCodeLine{02718\ \textcolor{comment}{//\ Helper\ to\ allow\ easy\ testing\ of\ AnyOf\ matchers\ with\ num\ parameters.}}
\DoxyCodeLine{02719\ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ AnyOfMatches(\textcolor{keywordtype}{int}\ num,\ \textcolor{keyword}{const}\ Matcher<int>\&\ m)\ \{}
\DoxyCodeLine{02720\ \ \ SCOPED\_TRACE(Describe(m));}
\DoxyCodeLine{02721\ \ \ EXPECT\_FALSE(m.Matches(0));}
\DoxyCodeLine{02722\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 1;\ i\ <=\ num;\ ++i)\ \{}
\DoxyCodeLine{02723\ \ \ \ \ EXPECT\_TRUE(m.Matches(i));}
\DoxyCodeLine{02724\ \ \ \}}
\DoxyCodeLine{02725\ \ \ EXPECT\_FALSE(m.Matches(num\ +\ 1));}
\DoxyCodeLine{02726\ \}}
\DoxyCodeLine{02727\ }
\DoxyCodeLine{02728\ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ AnyOfStringMatches(\textcolor{keywordtype}{int}\ num,\ \textcolor{keyword}{const}\ Matcher<std::string>\&\ m)\ \{}
\DoxyCodeLine{02729\ \ \ SCOPED\_TRACE(Describe(m));}
\DoxyCodeLine{02730\ \ \ EXPECT\_FALSE(m.Matches(std::to\_string(0)));}
\DoxyCodeLine{02731\ }
\DoxyCodeLine{02732\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 1;\ i\ <=\ num;\ ++i)\ \{}
\DoxyCodeLine{02733\ \ \ \ \ EXPECT\_TRUE(m.Matches(std::to\_string(i)));}
\DoxyCodeLine{02734\ \ \ \}}
\DoxyCodeLine{02735\ \ \ EXPECT\_FALSE(m.Matches(std::to\_string(num\ +\ 1)));}
\DoxyCodeLine{02736\ \}}
\DoxyCodeLine{02737\ }
\DoxyCodeLine{02738\ \textcolor{comment}{//\ Tests\ that\ AnyOf(m1,\ ...,\ mn)\ matches\ any\ value\ that\ matches\ at}}
\DoxyCodeLine{02739\ \textcolor{comment}{//\ least\ one\ of\ the\ given\ matchers.}}
\DoxyCodeLine{02740\ TEST(AnyOfTest,\ MatchesWhenAnyMatches)\ \{}
\DoxyCodeLine{02741\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02742\ \ \ m\ =\ AnyOf(Le(1),\ Ge(3));}
\DoxyCodeLine{02743\ \ \ EXPECT\_TRUE(m.Matches(1));}
\DoxyCodeLine{02744\ \ \ EXPECT\_TRUE(m.Matches(4));}
\DoxyCodeLine{02745\ \ \ EXPECT\_FALSE(m.Matches(2));}
\DoxyCodeLine{02746\ }
\DoxyCodeLine{02747\ \ \ m\ =\ AnyOf(Lt(0),\ Eq(1),\ Eq(2));}
\DoxyCodeLine{02748\ \ \ EXPECT\_TRUE(m.Matches(-\/1));}
\DoxyCodeLine{02749\ \ \ EXPECT\_TRUE(m.Matches(1));}
\DoxyCodeLine{02750\ \ \ EXPECT\_TRUE(m.Matches(2));}
\DoxyCodeLine{02751\ \ \ EXPECT\_FALSE(m.Matches(0));}
\DoxyCodeLine{02752\ }
\DoxyCodeLine{02753\ \ \ m\ =\ AnyOf(Lt(0),\ Eq(1),\ Eq(2),\ Eq(3));}
\DoxyCodeLine{02754\ \ \ EXPECT\_TRUE(m.Matches(-\/1));}
\DoxyCodeLine{02755\ \ \ EXPECT\_TRUE(m.Matches(1));}
\DoxyCodeLine{02756\ \ \ EXPECT\_TRUE(m.Matches(2));}
\DoxyCodeLine{02757\ \ \ EXPECT\_TRUE(m.Matches(3));}
\DoxyCodeLine{02758\ \ \ EXPECT\_FALSE(m.Matches(0));}
\DoxyCodeLine{02759\ }
\DoxyCodeLine{02760\ \ \ m\ =\ AnyOf(Le(0),\ Gt(10),\ 3,\ 5,\ 7);}
\DoxyCodeLine{02761\ \ \ EXPECT\_TRUE(m.Matches(0));}
\DoxyCodeLine{02762\ \ \ EXPECT\_TRUE(m.Matches(11));}
\DoxyCodeLine{02763\ \ \ EXPECT\_TRUE(m.Matches(3));}
\DoxyCodeLine{02764\ \ \ EXPECT\_FALSE(m.Matches(2));}
\DoxyCodeLine{02765\ }
\DoxyCodeLine{02766\ \ \ \textcolor{comment}{//\ The\ following\ tests\ for\ varying\ number\ of\ sub-\/matchers.\ Due\ to\ the\ way}}
\DoxyCodeLine{02767\ \ \ \textcolor{comment}{//\ the\ sub-\/matchers\ are\ handled\ it\ is\ enough\ to\ test\ every\ sub-\/matcher\ once}}
\DoxyCodeLine{02768\ \ \ \textcolor{comment}{//\ with\ sub-\/matchers\ using\ the\ same\ matcher\ type.\ Varying\ matcher\ types\ are}}
\DoxyCodeLine{02769\ \ \ \textcolor{comment}{//\ checked\ for\ above.}}
\DoxyCodeLine{02770\ \ \ AnyOfMatches(2,\ AnyOf(1,\ 2));}
\DoxyCodeLine{02771\ \ \ AnyOfMatches(3,\ AnyOf(1,\ 2,\ 3));}
\DoxyCodeLine{02772\ \ \ AnyOfMatches(4,\ AnyOf(1,\ 2,\ 3,\ 4));}
\DoxyCodeLine{02773\ \ \ AnyOfMatches(5,\ AnyOf(1,\ 2,\ 3,\ 4,\ 5));}
\DoxyCodeLine{02774\ \ \ AnyOfMatches(6,\ AnyOf(1,\ 2,\ 3,\ 4,\ 5,\ 6));}
\DoxyCodeLine{02775\ \ \ AnyOfMatches(7,\ AnyOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7));}
\DoxyCodeLine{02776\ \ \ AnyOfMatches(8,\ AnyOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8));}
\DoxyCodeLine{02777\ \ \ AnyOfMatches(9,\ AnyOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9));}
\DoxyCodeLine{02778\ \ \ AnyOfMatches(10,\ AnyOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ 10));}
\DoxyCodeLine{02779\ \}}
\DoxyCodeLine{02780\ }
\DoxyCodeLine{02781\ \textcolor{comment}{//\ Tests\ the\ variadic\ version\ of\ the\ AnyOfMatcher.}}
\DoxyCodeLine{02782\ TEST(AnyOfTest,\ VariadicMatchesWhenAnyMatches)\ \{}
\DoxyCodeLine{02783\ \ \ \textcolor{comment}{//\ Also\ make\ sure\ AnyOf\ is\ defined\ in\ the\ right\ namespace\ and\ does\ not\ depend}}
\DoxyCodeLine{02784\ \ \ \textcolor{comment}{//\ on\ ADL.}}
\DoxyCodeLine{02785\ \ \ Matcher<int>\ m\ =\ ::testing::AnyOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ 10,\ 11);}
\DoxyCodeLine{02786\ }
\DoxyCodeLine{02787\ \ \ EXPECT\_THAT(Describe(m),\ EndsWith(\textcolor{stringliteral}{"{}or\ (is\ equal\ to\ 11)"{}}));}
\DoxyCodeLine{02788\ \ \ AnyOfMatches(11,\ m);}
\DoxyCodeLine{02789\ \ \ AnyOfMatches(50,\ AnyOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ 10,}
\DoxyCodeLine{02790\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 11,\ 12,\ 13,\ 14,\ 15,\ 16,\ 17,\ 18,\ 19,\ 20,}
\DoxyCodeLine{02791\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 21,\ 22,\ 23,\ 24,\ 25,\ 26,\ 27,\ 28,\ 29,\ 30,}
\DoxyCodeLine{02792\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 31,\ 32,\ 33,\ 34,\ 35,\ 36,\ 37,\ 38,\ 39,\ 40,}
\DoxyCodeLine{02793\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 41,\ 42,\ 43,\ 44,\ 45,\ 46,\ 47,\ 48,\ 49,\ 50));}
\DoxyCodeLine{02794\ \ \ AnyOfStringMatches(}
\DoxyCodeLine{02795\ \ \ \ \ \ \ 50,\ AnyOf(\textcolor{stringliteral}{"{}1"{}},\ \textcolor{stringliteral}{"{}2"{}},\ \textcolor{stringliteral}{"{}3"{}},\ \textcolor{stringliteral}{"{}4"{}},\ \textcolor{stringliteral}{"{}5"{}},\ \textcolor{stringliteral}{"{}6"{}},\ \textcolor{stringliteral}{"{}7"{}},\ \textcolor{stringliteral}{"{}8"{}},\ \textcolor{stringliteral}{"{}9"{}},\ \textcolor{stringliteral}{"{}10"{}},\ \textcolor{stringliteral}{"{}11"{}},\ \textcolor{stringliteral}{"{}12"{}},}
\DoxyCodeLine{02796\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}13"{}},\ \textcolor{stringliteral}{"{}14"{}},\ \textcolor{stringliteral}{"{}15"{}},\ \textcolor{stringliteral}{"{}16"{}},\ \textcolor{stringliteral}{"{}17"{}},\ \textcolor{stringliteral}{"{}18"{}},\ \textcolor{stringliteral}{"{}19"{}},\ \textcolor{stringliteral}{"{}20"{}},\ \textcolor{stringliteral}{"{}21"{}},\ \textcolor{stringliteral}{"{}22"{}},}
\DoxyCodeLine{02797\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}23"{}},\ \textcolor{stringliteral}{"{}24"{}},\ \textcolor{stringliteral}{"{}25"{}},\ \textcolor{stringliteral}{"{}26"{}},\ \textcolor{stringliteral}{"{}27"{}},\ \textcolor{stringliteral}{"{}28"{}},\ \textcolor{stringliteral}{"{}29"{}},\ \textcolor{stringliteral}{"{}30"{}},\ \textcolor{stringliteral}{"{}31"{}},\ \textcolor{stringliteral}{"{}32"{}},}
\DoxyCodeLine{02798\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}33"{}},\ \textcolor{stringliteral}{"{}34"{}},\ \textcolor{stringliteral}{"{}35"{}},\ \textcolor{stringliteral}{"{}36"{}},\ \textcolor{stringliteral}{"{}37"{}},\ \textcolor{stringliteral}{"{}38"{}},\ \textcolor{stringliteral}{"{}39"{}},\ \textcolor{stringliteral}{"{}40"{}},\ \textcolor{stringliteral}{"{}41"{}},\ \textcolor{stringliteral}{"{}42"{}},}
\DoxyCodeLine{02799\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}43"{}},\ \textcolor{stringliteral}{"{}44"{}},\ \textcolor{stringliteral}{"{}45"{}},\ \textcolor{stringliteral}{"{}46"{}},\ \textcolor{stringliteral}{"{}47"{}},\ \textcolor{stringliteral}{"{}48"{}},\ \textcolor{stringliteral}{"{}49"{}},\ \textcolor{stringliteral}{"{}50"{}}));}
\DoxyCodeLine{02800\ \}}
\DoxyCodeLine{02801\ }
\DoxyCodeLine{02802\ TEST(ConditionalTest,\ MatchesFirstIfCondition)\ \{}
\DoxyCodeLine{02803\ \ \ Matcher<std::string>\ eq\_red\ =\ Eq(\textcolor{stringliteral}{"{}red"{}});}
\DoxyCodeLine{02804\ \ \ Matcher<std::string>\ ne\_red\ =\ Ne(\textcolor{stringliteral}{"{}red"{}});}
\DoxyCodeLine{02805\ \ \ Matcher<std::string>\ m\ =\ Conditional(\textcolor{keyword}{true},\ eq\_red,\ ne\_red);}
\DoxyCodeLine{02806\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{stringliteral}{"{}red"{}}));}
\DoxyCodeLine{02807\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{stringliteral}{"{}green"{}}));}
\DoxyCodeLine{02808\ }
\DoxyCodeLine{02809\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{02810\ \ \ StringMatchResultListener\ expected;}
\DoxyCodeLine{02811\ \ \ EXPECT\_FALSE(m.MatchAndExplain(\textcolor{stringliteral}{"{}green"{}},\ \&listener));}
\DoxyCodeLine{02812\ \ \ EXPECT\_FALSE(eq\_red.MatchAndExplain(\textcolor{stringliteral}{"{}green"{}},\ \&expected));}
\DoxyCodeLine{02813\ \ \ EXPECT\_THAT(listener.str(),\ Eq(expected.str()));}
\DoxyCodeLine{02814\ \}}
\DoxyCodeLine{02815\ }
\DoxyCodeLine{02816\ TEST(ConditionalTest,\ MatchesSecondIfCondition)\ \{}
\DoxyCodeLine{02817\ \ \ Matcher<std::string>\ eq\_red\ =\ Eq(\textcolor{stringliteral}{"{}red"{}});}
\DoxyCodeLine{02818\ \ \ Matcher<std::string>\ ne\_red\ =\ Ne(\textcolor{stringliteral}{"{}red"{}});}
\DoxyCodeLine{02819\ \ \ Matcher<std::string>\ m\ =\ Conditional(\textcolor{keyword}{false},\ eq\_red,\ ne\_red);}
\DoxyCodeLine{02820\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{stringliteral}{"{}red"{}}));}
\DoxyCodeLine{02821\ \ \ EXPECT\_TRUE(m.Matches(\textcolor{stringliteral}{"{}green"{}}));}
\DoxyCodeLine{02822\ }
\DoxyCodeLine{02823\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{02824\ \ \ StringMatchResultListener\ expected;}
\DoxyCodeLine{02825\ \ \ EXPECT\_FALSE(m.MatchAndExplain(\textcolor{stringliteral}{"{}red"{}},\ \&listener));}
\DoxyCodeLine{02826\ \ \ EXPECT\_FALSE(ne\_red.MatchAndExplain(\textcolor{stringliteral}{"{}red"{}},\ \&expected));}
\DoxyCodeLine{02827\ \ \ EXPECT\_THAT(listener.str(),\ Eq(expected.str()));}
\DoxyCodeLine{02828\ \}}
\DoxyCodeLine{02829\ }
\DoxyCodeLine{02830\ \textcolor{comment}{//\ Tests\ the\ variadic\ version\ of\ the\ ElementsAreMatcher}}
\DoxyCodeLine{02831\ TEST(ElementsAreTest,\ HugeMatcher)\ \{}
\DoxyCodeLine{02832\ \ \ vector<int>\ test\_vector\{1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ 10,\ 11,\ 12\};}
\DoxyCodeLine{02833\ }
\DoxyCodeLine{02834\ \ \ EXPECT\_THAT(test\_vector,}
\DoxyCodeLine{02835\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(Eq(1),\ Eq(2),\ Lt(13),\ Eq(4),\ Eq(5),\ Eq(6),\ Eq(7),}
\DoxyCodeLine{02836\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Eq(8),\ Eq(9),\ Eq(10),\ Gt(1),\ Eq(12)));}
\DoxyCodeLine{02837\ \}}
\DoxyCodeLine{02838\ }
\DoxyCodeLine{02839\ \textcolor{comment}{//\ Tests\ the\ variadic\ version\ of\ the\ UnorderedElementsAreMatcher}}
\DoxyCodeLine{02840\ TEST(ElementsAreTest,\ HugeMatcherStr)\ \{}
\DoxyCodeLine{02841\ \ \ vector<std::string>\ test\_vector\{}
\DoxyCodeLine{02842\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}literal\_string"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}},\ \textcolor{stringliteral}{"{}"{}}\};}
\DoxyCodeLine{02843\ }
\DoxyCodeLine{02844\ \ \ EXPECT\_THAT(test\_vector,\ UnorderedElementsAre(\textcolor{stringliteral}{"{}literal\_string"{}},\ \_,\ \_,\ \_,\ \_,\ \_,}
\DoxyCodeLine{02845\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_,\ \_,\ \_,\ \_,\ \_,\ \_));}
\DoxyCodeLine{02846\ \}}
\DoxyCodeLine{02847\ }
\DoxyCodeLine{02848\ \textcolor{comment}{//\ Tests\ the\ variadic\ version\ of\ the\ UnorderedElementsAreMatcher}}
\DoxyCodeLine{02849\ TEST(ElementsAreTest,\ HugeMatcherUnordered)\ \{}
\DoxyCodeLine{02850\ \ \ vector<int>\ test\_vector\{2,\ 1,\ 8,\ 5,\ 4,\ 6,\ 7,\ 3,\ 9,\ 12,\ 11,\ 10\};}
\DoxyCodeLine{02851\ }
\DoxyCodeLine{02852\ \ \ EXPECT\_THAT(test\_vector,\ UnorderedElementsAre(}
\DoxyCodeLine{02853\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Eq(2),\ Eq(1),\ Gt(7),\ Eq(5),\ Eq(4),\ Eq(6),\ Eq(7),}
\DoxyCodeLine{02854\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Eq(3),\ Eq(9),\ Eq(12),\ Eq(11),\ Ne(122)));}
\DoxyCodeLine{02855\ \}}
\DoxyCodeLine{02856\ }
\DoxyCodeLine{02857\ }
\DoxyCodeLine{02858\ \textcolor{comment}{//\ Tests\ that\ AnyOf(m1,\ ...,\ mn)\ describes\ itself\ properly.}}
\DoxyCodeLine{02859\ TEST(AnyOfTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{02860\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02861\ \ \ m\ =\ AnyOf(Le(1),\ Ge(3));}
\DoxyCodeLine{02862\ }
\DoxyCodeLine{02863\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(is\ <=\ 1)\ or\ (is\ >=\ 3)"{}},}
\DoxyCodeLine{02864\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{02865\ }
\DoxyCodeLine{02866\ \ \ m\ =\ AnyOf(Lt(0),\ Eq(1),\ Eq(2));}
\DoxyCodeLine{02867\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(is\ <\ 0)\ or\ (is\ equal\ to\ 1)\ or\ (is\ equal\ to\ 2)"{}},\ Describe(m));}
\DoxyCodeLine{02868\ }
\DoxyCodeLine{02869\ \ \ m\ =\ AnyOf(Lt(0),\ Eq(1),\ Eq(2),\ Eq(3));}
\DoxyCodeLine{02870\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(is\ <\ 0)\ or\ (is\ equal\ to\ 1)\ or\ (is\ equal\ to\ 2)\ or\ (is\ equal\ to\ 3)"{}},}
\DoxyCodeLine{02871\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{02872\ }
\DoxyCodeLine{02873\ \ \ m\ =\ AnyOf(Le(0),\ Gt(10),\ 3,\ 5,\ 7);}
\DoxyCodeLine{02874\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{02875\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(is\ <=\ 0)\ or\ (is\ >\ 10)\ or\ (is\ equal\ to\ 3)\ or\ (is\ equal\ to\ 5)\ or\ (is\ "{}}}
\DoxyCodeLine{02876\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}equal\ to\ 7)"{}},}
\DoxyCodeLine{02877\ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{02878\ \}}
\DoxyCodeLine{02879\ }
\DoxyCodeLine{02880\ \textcolor{comment}{//\ Tests\ that\ AnyOf(m1,\ ...,\ mn)\ describes\ its\ negation\ properly.}}
\DoxyCodeLine{02881\ TEST(AnyOfTest,\ CanDescribeNegation)\ \{}
\DoxyCodeLine{02882\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02883\ \ \ m\ =\ AnyOf(Le(1),\ Ge(3));}
\DoxyCodeLine{02884\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(isn't\ <=\ 1)\ and\ (isn't\ >=\ 3)"{}},}
\DoxyCodeLine{02885\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{02886\ }
\DoxyCodeLine{02887\ \ \ m\ =\ AnyOf(Lt(0),\ Eq(1),\ Eq(2));}
\DoxyCodeLine{02888\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(isn't\ <\ 0)\ and\ (isn't\ equal\ to\ 1)\ and\ (isn't\ equal\ to\ 2)"{}},}
\DoxyCodeLine{02889\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{02890\ }
\DoxyCodeLine{02891\ \ \ m\ =\ AnyOf(Lt(0),\ Eq(1),\ Eq(2),\ Eq(3));}
\DoxyCodeLine{02892\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{02893\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(isn't\ <\ 0)\ and\ (isn't\ equal\ to\ 1)\ and\ (isn't\ equal\ to\ 2)\ and\ (isn't\ "{}}}
\DoxyCodeLine{02894\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}equal\ to\ 3)"{}},}
\DoxyCodeLine{02895\ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{02896\ }
\DoxyCodeLine{02897\ \ \ m\ =\ AnyOf(Le(0),\ Gt(10),\ 3,\ 5,\ 7);}
\DoxyCodeLine{02898\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{02899\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}(isn't\ <=\ 0)\ and\ (isn't\ >\ 10)\ and\ (isn't\ equal\ to\ 3)\ and\ (isn't\ equal\ "{}}}
\DoxyCodeLine{02900\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}to\ 5)\ and\ (isn't\ equal\ to\ 7)"{}},}
\DoxyCodeLine{02901\ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{02902\ \}}
\DoxyCodeLine{02903\ }
\DoxyCodeLine{02904\ \textcolor{comment}{//\ Tests\ that\ monomorphic\ matchers\ are\ safely\ cast\ by\ the\ AnyOf\ matcher.}}
\DoxyCodeLine{02905\ TEST(AnyOfTest,\ AnyOfMatcherSafelyCastsMonomorphicMatchers)\ \{}
\DoxyCodeLine{02906\ \ \ \textcolor{comment}{//\ greater\_than\_5\ and\ less\_than\_10\ are\ monomorphic\ matchers.}}
\DoxyCodeLine{02907\ \ \ Matcher<int>\ greater\_than\_5\ =\ Gt(5);}
\DoxyCodeLine{02908\ \ \ Matcher<int>\ less\_than\_10\ =\ Lt(10);}
\DoxyCodeLine{02909\ }
\DoxyCodeLine{02910\ \ \ Matcher<const\ int\&>\ m\ =\ AnyOf(greater\_than\_5,\ less\_than\_10);}
\DoxyCodeLine{02911\ \ \ Matcher<int\&>\ m2\ =\ AnyOf(greater\_than\_5,\ less\_than\_10);}
\DoxyCodeLine{02912\ \ \ Matcher<int\&>\ m3\ =\ AnyOf(greater\_than\_5,\ m2);}
\DoxyCodeLine{02913\ }
\DoxyCodeLine{02914\ \ \ \textcolor{comment}{//\ Tests\ that\ EitherOf\ works\ when\ composing\ itself.}}
\DoxyCodeLine{02915\ \ \ Matcher<const\ int\&>\ m4\ =\ AnyOf(greater\_than\_5,\ less\_than\_10,\ less\_than\_10);}
\DoxyCodeLine{02916\ \ \ Matcher<int\&>\ m5\ =\ AnyOf(greater\_than\_5,\ less\_than\_10,\ less\_than\_10);}
\DoxyCodeLine{02917\ \}}
\DoxyCodeLine{02918\ }
\DoxyCodeLine{02919\ TEST(AnyOfTest,\ ExplainsResult)\ \{}
\DoxyCodeLine{02920\ \ \ Matcher<int>\ m;}
\DoxyCodeLine{02921\ }
\DoxyCodeLine{02922\ \ \ \textcolor{comment}{//\ Failed\ match.\ \ Both\ matchers\ need\ to\ explain.\ \ The\ second}}
\DoxyCodeLine{02923\ \ \ \textcolor{comment}{//\ matcher\ doesn't\ give\ an\ explanation,\ so\ only\ the\ first\ matcher's}}
\DoxyCodeLine{02924\ \ \ \textcolor{comment}{//\ explanation\ is\ printed.}}
\DoxyCodeLine{02925\ \ \ m\ =\ AnyOf(GreaterThan(10),\ Lt(0));}
\DoxyCodeLine{02926\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 5\ less\ than\ 10"{}},\ Explain(m,\ 5));}
\DoxyCodeLine{02927\ }
\DoxyCodeLine{02928\ \ \ \textcolor{comment}{//\ Failed\ match.\ \ Both\ matchers\ need\ to\ explain.}}
\DoxyCodeLine{02929\ \ \ m\ =\ AnyOf(GreaterThan(10),\ GreaterThan(20));}
\DoxyCodeLine{02930\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 5\ less\ than\ 10,\ and\ which\ is\ 15\ less\ than\ 20"{}},}
\DoxyCodeLine{02931\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ 5));}
\DoxyCodeLine{02932\ }
\DoxyCodeLine{02933\ \ \ \textcolor{comment}{//\ Failed\ match.\ \ All\ matchers\ need\ to\ explain.\ \ The\ second}}
\DoxyCodeLine{02934\ \ \ \textcolor{comment}{//\ matcher\ doesn't\ given\ an\ explanation.}}
\DoxyCodeLine{02935\ \ \ m\ =\ AnyOf(GreaterThan(10),\ Gt(20),\ GreaterThan(30));}
\DoxyCodeLine{02936\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 5\ less\ than\ 10,\ and\ which\ is\ 25\ less\ than\ 30"{}},}
\DoxyCodeLine{02937\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ 5));}
\DoxyCodeLine{02938\ }
\DoxyCodeLine{02939\ \ \ \textcolor{comment}{//\ Failed\ match.\ \ All\ matchers\ need\ to\ explain.}}
\DoxyCodeLine{02940\ \ \ m\ =\ AnyOf(GreaterThan(10),\ GreaterThan(20),\ GreaterThan(30));}
\DoxyCodeLine{02941\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 5\ less\ than\ 10,\ and\ which\ is\ 15\ less\ than\ 20,\ "{}}}
\DoxyCodeLine{02942\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\ which\ is\ 25\ less\ than\ 30"{}},}
\DoxyCodeLine{02943\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ 5));}
\DoxyCodeLine{02944\ }
\DoxyCodeLine{02945\ \ \ \textcolor{comment}{//\ Successful\ match.\ \ The\ first\ matcher,\ which\ succeeded,\ needs\ to}}
\DoxyCodeLine{02946\ \ \ \textcolor{comment}{//\ explain.}}
\DoxyCodeLine{02947\ \ \ m\ =\ AnyOf(GreaterThan(10),\ GreaterThan(20));}
\DoxyCodeLine{02948\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 5\ more\ than\ 10"{}},\ Explain(m,\ 15));}
\DoxyCodeLine{02949\ }
\DoxyCodeLine{02950\ \ \ \textcolor{comment}{//\ Successful\ match.\ \ The\ second\ matcher,\ which\ succeeded,\ needs\ to}}
\DoxyCodeLine{02951\ \ \ \textcolor{comment}{//\ explain.\ \ Since\ it\ doesn't\ given\ an\ explanation,\ nothing\ is}}
\DoxyCodeLine{02952\ \ \ \textcolor{comment}{//\ printed.}}
\DoxyCodeLine{02953\ \ \ m\ =\ AnyOf(GreaterThan(10),\ Lt(30));}
\DoxyCodeLine{02954\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 0));}
\DoxyCodeLine{02955\ }
\DoxyCodeLine{02956\ \ \ \textcolor{comment}{//\ Successful\ match.\ \ The\ second\ matcher,\ which\ succeeded,\ needs\ to}}
\DoxyCodeLine{02957\ \ \ \textcolor{comment}{//\ explain.}}
\DoxyCodeLine{02958\ \ \ m\ =\ AnyOf(GreaterThan(30),\ GreaterThan(20));}
\DoxyCodeLine{02959\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 5\ more\ than\ 20"{}},\ Explain(m,\ 25));}
\DoxyCodeLine{02960\ \}}
\DoxyCodeLine{02961\ }
\DoxyCodeLine{02962\ \textcolor{comment}{//\ The\ following\ predicate\ function\ and\ predicate\ functor\ are\ for}}
\DoxyCodeLine{02963\ \textcolor{comment}{//\ testing\ the\ Truly(predicate)\ matcher.}}
\DoxyCodeLine{02964\ }
\DoxyCodeLine{02965\ \textcolor{comment}{//\ Returns\ non-\/zero\ if\ the\ input\ is\ positive.\ \ Note\ that\ the\ return}}
\DoxyCodeLine{02966\ \textcolor{comment}{//\ type\ of\ this\ function\ is\ not\ bool.\ \ It's\ OK\ as\ Truly()\ accepts\ any}}
\DoxyCodeLine{02967\ \textcolor{comment}{//\ unary\ function\ or\ functor\ whose\ return\ type\ can\ be\ implicitly}}
\DoxyCodeLine{02968\ \textcolor{comment}{//\ converted\ to\ bool.}}
\DoxyCodeLine{02969\ \textcolor{keywordtype}{int}\ IsPositive(\textcolor{keywordtype}{double}\ x)\ \{}
\DoxyCodeLine{02970\ \ \ \textcolor{keywordflow}{return}\ x\ >\ 0\ ?\ 1\ :\ 0;}
\DoxyCodeLine{02971\ \}}
\DoxyCodeLine{02972\ }
\DoxyCodeLine{02973\ \textcolor{comment}{//\ This\ functor\ returns\ true\ if\ the\ input\ is\ greater\ than\ the\ given}}
\DoxyCodeLine{02974\ \textcolor{comment}{//\ number.}}
\DoxyCodeLine{02975\ \textcolor{keyword}{class\ }IsGreaterThan\ \{}
\DoxyCodeLine{02976\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{02977\ \ \ \textcolor{keyword}{explicit}\ IsGreaterThan(\textcolor{keywordtype}{int}\ threshold)\ :\ threshold\_(threshold)\ \{\}}
\DoxyCodeLine{02978\ }
\DoxyCodeLine{02979\ \ \ \textcolor{keywordtype}{bool}\ operator()(\textcolor{keywordtype}{int}\ n)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ n\ >\ threshold\_;\ \}}
\DoxyCodeLine{02980\ }
\DoxyCodeLine{02981\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{02982\ \ \ \textcolor{keywordtype}{int}\ threshold\_;}
\DoxyCodeLine{02983\ \};}
\DoxyCodeLine{02984\ }
\DoxyCodeLine{02985\ \textcolor{comment}{//\ For\ testing\ Truly().}}
\DoxyCodeLine{02986\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ foo\ =\ 0;}
\DoxyCodeLine{02987\ }
\DoxyCodeLine{02988\ \textcolor{comment}{//\ This\ predicate\ returns\ true\ if\ and\ only\ if\ the\ argument\ references\ foo\ and}}
\DoxyCodeLine{02989\ \textcolor{comment}{//\ has\ a\ zero\ value.}}
\DoxyCodeLine{02990\ \textcolor{keywordtype}{bool}\ ReferencesFooAndIsZero(\textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\&\ n)\ \{}
\DoxyCodeLine{02991\ \ \ \textcolor{keywordflow}{return}\ (\&n\ ==\ \&foo)\ \&\&\ (n\ ==\ 0);}
\DoxyCodeLine{02992\ \}}
\DoxyCodeLine{02993\ }
\DoxyCodeLine{02994\ \textcolor{comment}{//\ Tests\ that\ Truly(predicate)\ matches\ what\ satisfies\ the\ given}}
\DoxyCodeLine{02995\ \textcolor{comment}{//\ predicate.}}
\DoxyCodeLine{02996\ TEST(TrulyTest,\ MatchesWhatSatisfiesThePredicate)\ \{}
\DoxyCodeLine{02997\ \ \ Matcher<double>\ m\ =\ Truly(IsPositive);}
\DoxyCodeLine{02998\ \ \ EXPECT\_TRUE(m.Matches(2.0));}
\DoxyCodeLine{02999\ \ \ EXPECT\_FALSE(m.Matches(-\/1.5));}
\DoxyCodeLine{03000\ \}}
\DoxyCodeLine{03001\ }
\DoxyCodeLine{03002\ \textcolor{comment}{//\ Tests\ that\ Truly(predicate\_functor)\ works\ too.}}
\DoxyCodeLine{03003\ TEST(TrulyTest,\ CanBeUsedWithFunctor)\ \{}
\DoxyCodeLine{03004\ \ \ Matcher<int>\ m\ =\ Truly(IsGreaterThan(5));}
\DoxyCodeLine{03005\ \ \ EXPECT\_TRUE(m.Matches(6));}
\DoxyCodeLine{03006\ \ \ EXPECT\_FALSE(m.Matches(4));}
\DoxyCodeLine{03007\ \}}
\DoxyCodeLine{03008\ }
\DoxyCodeLine{03009\ \textcolor{comment}{//\ A\ class\ that\ can\ be\ implicitly\ converted\ to\ bool.}}
\DoxyCodeLine{03010\ \textcolor{keyword}{class\ }ConvertibleToBool\ \{}
\DoxyCodeLine{03011\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03012\ \ \ \textcolor{keyword}{explicit}\ ConvertibleToBool(\textcolor{keywordtype}{int}\ number)\ :\ number\_(number)\ \{\}}
\DoxyCodeLine{03013\ \ \ \textcolor{keyword}{operator}\ bool()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ number\_\ !=\ 0;\ \}}
\DoxyCodeLine{03014\ }
\DoxyCodeLine{03015\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03016\ \ \ \textcolor{keywordtype}{int}\ number\_;}
\DoxyCodeLine{03017\ \};}
\DoxyCodeLine{03018\ }
\DoxyCodeLine{03019\ ConvertibleToBool\ IsNotZero(\textcolor{keywordtype}{int}\ number)\ \{}
\DoxyCodeLine{03020\ \ \ \textcolor{keywordflow}{return}\ ConvertibleToBool(number);}
\DoxyCodeLine{03021\ \}}
\DoxyCodeLine{03022\ }
\DoxyCodeLine{03023\ \textcolor{comment}{//\ Tests\ that\ the\ predicate\ used\ in\ Truly()\ may\ return\ a\ class\ that's}}
\DoxyCodeLine{03024\ \textcolor{comment}{//\ implicitly\ convertible\ to\ bool,\ even\ when\ the\ class\ has\ no}}
\DoxyCodeLine{03025\ \textcolor{comment}{//\ operator!().}}
\DoxyCodeLine{03026\ TEST(TrulyTest,\ PredicateCanReturnAClassConvertibleToBool)\ \{}
\DoxyCodeLine{03027\ \ \ Matcher<int>\ m\ =\ Truly(IsNotZero);}
\DoxyCodeLine{03028\ \ \ EXPECT\_TRUE(m.Matches(1));}
\DoxyCodeLine{03029\ \ \ EXPECT\_FALSE(m.Matches(0));}
\DoxyCodeLine{03030\ \}}
\DoxyCodeLine{03031\ }
\DoxyCodeLine{03032\ \textcolor{comment}{//\ Tests\ that\ Truly(predicate)\ can\ describe\ itself\ properly.}}
\DoxyCodeLine{03033\ TEST(TrulyTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{03034\ \ \ Matcher<double>\ m\ =\ Truly(IsPositive);}
\DoxyCodeLine{03035\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}satisfies\ the\ given\ predicate"{}},}
\DoxyCodeLine{03036\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{03037\ \}}
\DoxyCodeLine{03038\ }
\DoxyCodeLine{03039\ \textcolor{comment}{//\ Tests\ that\ Truly(predicate)\ works\ when\ the\ matcher\ takes\ its}}
\DoxyCodeLine{03040\ \textcolor{comment}{//\ argument\ by\ reference.}}
\DoxyCodeLine{03041\ TEST(TrulyTest,\ WorksForByRefArguments)\ \{}
\DoxyCodeLine{03042\ \ \ Matcher<const\ int\&>\ m\ =\ Truly(ReferencesFooAndIsZero);}
\DoxyCodeLine{03043\ \ \ EXPECT\_TRUE(m.Matches(foo));}
\DoxyCodeLine{03044\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{03045\ \ \ EXPECT\_FALSE(m.Matches(n));}
\DoxyCodeLine{03046\ \}}
\DoxyCodeLine{03047\ }
\DoxyCodeLine{03048\ \textcolor{comment}{//\ Tests\ that\ Truly(predicate)\ provides\ a\ helpful\ reason\ when\ it\ fails.}}
\DoxyCodeLine{03049\ TEST(TrulyTest,\ ExplainsFailures)\ \{}
\DoxyCodeLine{03050\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{03051\ \ \ EXPECT\_FALSE(ExplainMatchResult(Truly(IsPositive),\ -\/1,\ \&listener));}
\DoxyCodeLine{03052\ \ \ EXPECT\_EQ(listener.str(),\ \textcolor{stringliteral}{"{}didn't\ satisfy\ the\ given\ predicate"{}});}
\DoxyCodeLine{03053\ \}}
\DoxyCodeLine{03054\ }
\DoxyCodeLine{03055\ \textcolor{comment}{//\ Tests\ that\ Matches(m)\ is\ a\ predicate\ satisfied\ by\ whatever\ that}}
\DoxyCodeLine{03056\ \textcolor{comment}{//\ matches\ matcher\ m.}}
\DoxyCodeLine{03057\ TEST(MatchesTest,\ IsSatisfiedByWhatMatchesTheMatcher)\ \{}
\DoxyCodeLine{03058\ \ \ EXPECT\_TRUE(Matches(Ge(0))(1));}
\DoxyCodeLine{03059\ \ \ EXPECT\_FALSE(Matches(Eq(\textcolor{charliteral}{'a'}))(\textcolor{charliteral}{'b'}));}
\DoxyCodeLine{03060\ \}}
\DoxyCodeLine{03061\ }
\DoxyCodeLine{03062\ \textcolor{comment}{//\ Tests\ that\ Matches(m)\ works\ when\ the\ matcher\ takes\ its\ argument\ by}}
\DoxyCodeLine{03063\ \textcolor{comment}{//\ reference.}}
\DoxyCodeLine{03064\ TEST(MatchesTest,\ WorksOnByRefArguments)\ \{}
\DoxyCodeLine{03065\ \ \ \textcolor{keywordtype}{int}\ m\ =\ 0,\ n\ =\ 0;}
\DoxyCodeLine{03066\ \ \ EXPECT\_TRUE(Matches(AllOf(Ref(n),\ Eq(0)))(n));}
\DoxyCodeLine{03067\ \ \ EXPECT\_FALSE(Matches(Ref(m))(n));}
\DoxyCodeLine{03068\ \}}
\DoxyCodeLine{03069\ }
\DoxyCodeLine{03070\ \textcolor{comment}{//\ Tests\ that\ a\ Matcher\ on\ non-\/reference\ type\ can\ be\ used\ in}}
\DoxyCodeLine{03071\ \textcolor{comment}{//\ Matches().}}
\DoxyCodeLine{03072\ TEST(MatchesTest,\ WorksWithMatcherOnNonRefType)\ \{}
\DoxyCodeLine{03073\ \ \ Matcher<int>\ eq5\ =\ Eq(5);}
\DoxyCodeLine{03074\ \ \ EXPECT\_TRUE(Matches(eq5)(5));}
\DoxyCodeLine{03075\ \ \ EXPECT\_FALSE(Matches(eq5)(2));}
\DoxyCodeLine{03076\ \}}
\DoxyCodeLine{03077\ }
\DoxyCodeLine{03078\ \textcolor{comment}{//\ Tests\ Value(value,\ matcher).\ \ Since\ Value()\ is\ a\ simple\ wrapper\ for}}
\DoxyCodeLine{03079\ \textcolor{comment}{//\ Matches(),\ which\ has\ been\ tested\ already,\ we\ don't\ spend\ a\ lot\ of}}
\DoxyCodeLine{03080\ \textcolor{comment}{//\ effort\ on\ testing\ Value().}}
\DoxyCodeLine{03081\ TEST(ValueTest,\ WorksWithPolymorphicMatcher)\ \{}
\DoxyCodeLine{03082\ \ \ EXPECT\_TRUE(Value(\textcolor{stringliteral}{"{}hi"{}},\ StartsWith(\textcolor{stringliteral}{"{}h"{}})));}
\DoxyCodeLine{03083\ \ \ EXPECT\_FALSE(Value(5,\ Gt(10)));}
\DoxyCodeLine{03084\ \}}
\DoxyCodeLine{03085\ }
\DoxyCodeLine{03086\ TEST(ValueTest,\ WorksWithMonomorphicMatcher)\ \{}
\DoxyCodeLine{03087\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ is\_zero\ =\ Eq(0);}
\DoxyCodeLine{03088\ \ \ EXPECT\_TRUE(Value(0,\ is\_zero));}
\DoxyCodeLine{03089\ \ \ EXPECT\_FALSE(Value(\textcolor{charliteral}{'a'},\ is\_zero));}
\DoxyCodeLine{03090\ }
\DoxyCodeLine{03091\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{03092\ \ \ \textcolor{keyword}{const}\ Matcher<const\ int\&>\ ref\_n\ =\ Ref(n);}
\DoxyCodeLine{03093\ \ \ EXPECT\_TRUE(Value(n,\ ref\_n));}
\DoxyCodeLine{03094\ \ \ EXPECT\_FALSE(Value(1,\ ref\_n));}
\DoxyCodeLine{03095\ \}}
\DoxyCodeLine{03096\ }
\DoxyCodeLine{03097\ TEST(ExplainMatchResultTest,\ WorksWithPolymorphicMatcher)\ \{}
\DoxyCodeLine{03098\ \ \ StringMatchResultListener\ listener1;}
\DoxyCodeLine{03099\ \ \ EXPECT\_TRUE(ExplainMatchResult(PolymorphicIsEven(),\ 42,\ \&listener1));}
\DoxyCodeLine{03100\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}\%\ 2\ ==\ 0"{}},\ listener1.str());}
\DoxyCodeLine{03101\ }
\DoxyCodeLine{03102\ \ \ StringMatchResultListener\ listener2;}
\DoxyCodeLine{03103\ \ \ EXPECT\_FALSE(ExplainMatchResult(Ge(42),\ 1.5,\ \&listener2));}
\DoxyCodeLine{03104\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ listener2.str());}
\DoxyCodeLine{03105\ \}}
\DoxyCodeLine{03106\ }
\DoxyCodeLine{03107\ TEST(ExplainMatchResultTest,\ WorksWithMonomorphicMatcher)\ \{}
\DoxyCodeLine{03108\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ is\_even\ =\ PolymorphicIsEven();}
\DoxyCodeLine{03109\ \ \ StringMatchResultListener\ listener1;}
\DoxyCodeLine{03110\ \ \ EXPECT\_TRUE(ExplainMatchResult(is\_even,\ 42,\ \&listener1));}
\DoxyCodeLine{03111\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}\%\ 2\ ==\ 0"{}},\ listener1.str());}
\DoxyCodeLine{03112\ }
\DoxyCodeLine{03113\ \ \ \textcolor{keyword}{const}\ Matcher<const\ double\&>\ is\_zero\ =\ Eq(0);}
\DoxyCodeLine{03114\ \ \ StringMatchResultListener\ listener2;}
\DoxyCodeLine{03115\ \ \ EXPECT\_FALSE(ExplainMatchResult(is\_zero,\ 1.5,\ \&listener2));}
\DoxyCodeLine{03116\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ listener2.str());}
\DoxyCodeLine{03117\ \}}
\DoxyCodeLine{03118\ }
\DoxyCodeLine{03119\ MATCHER(ConstructNoArg,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{03120\ MATCHER\_P(Construct1Arg,\ arg1,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{03121\ MATCHER\_P2(Construct2Args,\ arg1,\ arg2,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{03122\ }
\DoxyCodeLine{03123\ TEST(MatcherConstruct,\ ExplicitVsImplicit)\ \{}
\DoxyCodeLine{03124\ \ \ \{}
\DoxyCodeLine{03125\ \ \ \ \ \textcolor{comment}{//\ No\ arg\ constructor\ can\ be\ constructed\ with\ empty\ brace.}}
\DoxyCodeLine{03126\ \ \ \ \ ConstructNoArgMatcher\ m\ =\ \{\};}
\DoxyCodeLine{03127\ \ \ \ \ (void)m;}
\DoxyCodeLine{03128\ \ \ \ \ \textcolor{comment}{//\ And\ with\ no\ args}}
\DoxyCodeLine{03129\ \ \ \ \ ConstructNoArgMatcher\ m2;}
\DoxyCodeLine{03130\ \ \ \ \ (void)m2;}
\DoxyCodeLine{03131\ \ \ \}}
\DoxyCodeLine{03132\ \ \ \{}
\DoxyCodeLine{03133\ \ \ \ \ \textcolor{comment}{//\ The\ one\ arg\ constructor\ has\ an\ explicit\ constructor.}}
\DoxyCodeLine{03134\ \ \ \ \ \textcolor{comment}{//\ This\ is\ to\ prevent\ the\ implicit\ conversion.}}
\DoxyCodeLine{03135\ \ \ \ \ \textcolor{keyword}{using\ }M\ =\ Construct1ArgMatcherP<int>;}
\DoxyCodeLine{03136\ \ \ \ \ EXPECT\_TRUE((std::is\_constructible<M,\ int>::value));}
\DoxyCodeLine{03137\ \ \ \ \ EXPECT\_FALSE((std::is\_convertible<int,\ M>::value));}
\DoxyCodeLine{03138\ \ \ \}}
\DoxyCodeLine{03139\ \ \ \{}
\DoxyCodeLine{03140\ \ \ \ \ \textcolor{comment}{//\ Multiple\ arg\ matchers\ can\ be\ constructed\ with\ an\ implicit\ construction.}}
\DoxyCodeLine{03141\ \ \ \ \ Construct2ArgsMatcherP2<int,\ double>\ m\ =\ \{1,\ 2.2\};}
\DoxyCodeLine{03142\ \ \ \ \ (void)m;}
\DoxyCodeLine{03143\ \ \ \}}
\DoxyCodeLine{03144\ \}}
\DoxyCodeLine{03145\ }
\DoxyCodeLine{03146\ MATCHER\_P(Really,\ inner\_matcher,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{03147\ \ \ \textcolor{keywordflow}{return}\ ExplainMatchResult(inner\_matcher,\ arg,\ result\_listener);}
\DoxyCodeLine{03148\ \}}
\DoxyCodeLine{03149\ }
\DoxyCodeLine{03150\ TEST(ExplainMatchResultTest,\ WorksInsideMATCHER)\ \{}
\DoxyCodeLine{03151\ \ \ EXPECT\_THAT(0,\ Really(Eq(0)));}
\DoxyCodeLine{03152\ \}}
\DoxyCodeLine{03153\ }
\DoxyCodeLine{03154\ TEST(DescribeMatcherTest,\ WorksWithValue)\ \{}
\DoxyCodeLine{03155\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ equal\ to\ 42"{}},\ DescribeMatcher<int>(42));}
\DoxyCodeLine{03156\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ equal\ to\ 42"{}},\ DescribeMatcher<int>(42,\ \textcolor{keyword}{true}));}
\DoxyCodeLine{03157\ \}}
\DoxyCodeLine{03158\ }
\DoxyCodeLine{03159\ TEST(DescribeMatcherTest,\ WorksWithMonomorphicMatcher)\ \{}
\DoxyCodeLine{03160\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ monomorphic\ =\ Le(0);}
\DoxyCodeLine{03161\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ <=\ 0"{}},\ DescribeMatcher<int>(monomorphic));}
\DoxyCodeLine{03162\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ <=\ 0"{}},\ DescribeMatcher<int>(monomorphic,\ \textcolor{keyword}{true}));}
\DoxyCodeLine{03163\ \}}
\DoxyCodeLine{03164\ }
\DoxyCodeLine{03165\ TEST(DescribeMatcherTest,\ WorksWithPolymorphicMatcher)\ \{}
\DoxyCodeLine{03166\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ even"{}},\ DescribeMatcher<int>(PolymorphicIsEven()));}
\DoxyCodeLine{03167\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ odd"{}},\ DescribeMatcher<int>(PolymorphicIsEven(),\ \textcolor{keyword}{true}));}
\DoxyCodeLine{03168\ \}}
\DoxyCodeLine{03169\ }
\DoxyCodeLine{03170\ TEST(AllArgsTest,\ WorksForTuple)\ \{}
\DoxyCodeLine{03171\ \ \ EXPECT\_THAT(std::make\_tuple(1,\ 2L),\ AllArgs(Lt()));}
\DoxyCodeLine{03172\ \ \ EXPECT\_THAT(std::make\_tuple(2L,\ 1),\ Not(AllArgs(Lt())));}
\DoxyCodeLine{03173\ \}}
\DoxyCodeLine{03174\ }
\DoxyCodeLine{03175\ TEST(AllArgsTest,\ WorksForNonTuple)\ \{}
\DoxyCodeLine{03176\ \ \ EXPECT\_THAT(42,\ AllArgs(Gt(0)));}
\DoxyCodeLine{03177\ \ \ EXPECT\_THAT(\textcolor{charliteral}{'a'},\ Not(AllArgs(Eq(\textcolor{charliteral}{'b'}))));}
\DoxyCodeLine{03178\ \}}
\DoxyCodeLine{03179\ }
\DoxyCodeLine{03180\ \textcolor{keyword}{class\ }AllArgsHelper\ \{}
\DoxyCodeLine{03181\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03182\ \ \ AllArgsHelper()\ \{\}}
\DoxyCodeLine{03183\ }
\DoxyCodeLine{03184\ \ \ MOCK\_METHOD2(Helper,\ \textcolor{keywordtype}{int}(\textcolor{keywordtype}{char}\ x,\ \textcolor{keywordtype}{int}\ y));}
\DoxyCodeLine{03185\ }
\DoxyCodeLine{03186\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03187\ \ \ GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(AllArgsHelper);}
\DoxyCodeLine{03188\ \};}
\DoxyCodeLine{03189\ }
\DoxyCodeLine{03190\ TEST(AllArgsTest,\ WorksInWithClause)\ \{}
\DoxyCodeLine{03191\ \ \ AllArgsHelper\ helper;}
\DoxyCodeLine{03192\ \ \ ON\_CALL(helper,\ Helper(\_,\ \_))}
\DoxyCodeLine{03193\ \ \ \ \ \ \ .With(AllArgs(Lt()))}
\DoxyCodeLine{03194\ \ \ \ \ \ \ .WillByDefault(Return(1));}
\DoxyCodeLine{03195\ \ \ EXPECT\_CALL(helper,\ Helper(\_,\ \_));}
\DoxyCodeLine{03196\ \ \ EXPECT\_CALL(helper,\ Helper(\_,\ \_))}
\DoxyCodeLine{03197\ \ \ \ \ \ \ .With(AllArgs(Gt()))}
\DoxyCodeLine{03198\ \ \ \ \ \ \ .WillOnce(Return(2));}
\DoxyCodeLine{03199\ }
\DoxyCodeLine{03200\ \ \ EXPECT\_EQ(1,\ helper.Helper(\textcolor{charliteral}{'\(\backslash\)1'},\ 2));}
\DoxyCodeLine{03201\ \ \ EXPECT\_EQ(2,\ helper.Helper(\textcolor{charliteral}{'a'},\ 1));}
\DoxyCodeLine{03202\ \}}
\DoxyCodeLine{03203\ }
\DoxyCodeLine{03204\ \textcolor{keyword}{class\ }OptionalMatchersHelper\ \{}
\DoxyCodeLine{03205\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03206\ \ \ OptionalMatchersHelper()\ \{\}}
\DoxyCodeLine{03207\ }
\DoxyCodeLine{03208\ \ \ MOCK\_METHOD0(NoArgs,\ \textcolor{keywordtype}{int}());}
\DoxyCodeLine{03209\ }
\DoxyCodeLine{03210\ \ \ MOCK\_METHOD1(OneArg,\ \textcolor{keywordtype}{int}(\textcolor{keywordtype}{int}\ y));}
\DoxyCodeLine{03211\ }
\DoxyCodeLine{03212\ \ \ MOCK\_METHOD2(TwoArgs,\ \textcolor{keywordtype}{int}(\textcolor{keywordtype}{char}\ x,\ \textcolor{keywordtype}{int}\ y));}
\DoxyCodeLine{03213\ }
\DoxyCodeLine{03214\ \ \ MOCK\_METHOD1(Overloaded,\ \textcolor{keywordtype}{int}(\textcolor{keywordtype}{char}\ x));}
\DoxyCodeLine{03215\ \ \ MOCK\_METHOD2(Overloaded,\ \textcolor{keywordtype}{int}(\textcolor{keywordtype}{char}\ x,\ \textcolor{keywordtype}{int}\ y));}
\DoxyCodeLine{03216\ }
\DoxyCodeLine{03217\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{03218\ \ \ GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(OptionalMatchersHelper);}
\DoxyCodeLine{03219\ \};}
\DoxyCodeLine{03220\ }
\DoxyCodeLine{03221\ TEST(AllArgsTest,\ WorksWithoutMatchers)\ \{}
\DoxyCodeLine{03222\ \ \ OptionalMatchersHelper\ helper;}
\DoxyCodeLine{03223\ }
\DoxyCodeLine{03224\ \ \ ON\_CALL(helper,\ NoArgs).WillByDefault(Return(10));}
\DoxyCodeLine{03225\ \ \ ON\_CALL(helper,\ OneArg).WillByDefault(Return(20));}
\DoxyCodeLine{03226\ \ \ ON\_CALL(helper,\ TwoArgs).WillByDefault(Return(30));}
\DoxyCodeLine{03227\ }
\DoxyCodeLine{03228\ \ \ EXPECT\_EQ(10,\ helper.NoArgs());}
\DoxyCodeLine{03229\ \ \ EXPECT\_EQ(20,\ helper.OneArg(1));}
\DoxyCodeLine{03230\ \ \ EXPECT\_EQ(30,\ helper.TwoArgs(\textcolor{charliteral}{'\(\backslash\)1'},\ 2));}
\DoxyCodeLine{03231\ }
\DoxyCodeLine{03232\ \ \ EXPECT\_CALL(helper,\ NoArgs).Times(1);}
\DoxyCodeLine{03233\ \ \ EXPECT\_CALL(helper,\ OneArg).WillOnce(Return(100));}
\DoxyCodeLine{03234\ \ \ EXPECT\_CALL(helper,\ OneArg(17)).WillOnce(Return(200));}
\DoxyCodeLine{03235\ \ \ EXPECT\_CALL(helper,\ TwoArgs).Times(0);}
\DoxyCodeLine{03236\ }
\DoxyCodeLine{03237\ \ \ EXPECT\_EQ(10,\ helper.NoArgs());}
\DoxyCodeLine{03238\ \ \ EXPECT\_EQ(100,\ helper.OneArg(1));}
\DoxyCodeLine{03239\ \ \ EXPECT\_EQ(200,\ helper.OneArg(17));}
\DoxyCodeLine{03240\ \}}
\DoxyCodeLine{03241\ }
\DoxyCodeLine{03242\ \textcolor{comment}{//\ Tests\ that\ ASSERT\_THAT()\ and\ EXPECT\_THAT()\ work\ when\ the\ value}}
\DoxyCodeLine{03243\ \textcolor{comment}{//\ matches\ the\ matcher.}}
\DoxyCodeLine{03244\ TEST(MatcherAssertionTest,\ WorksWhenMatcherIsSatisfied)\ \{}
\DoxyCodeLine{03245\ \ \ ASSERT\_THAT(5,\ Ge(2))\ <<\ \textcolor{stringliteral}{"{}This\ should\ succeed."{}};}
\DoxyCodeLine{03246\ \ \ ASSERT\_THAT(\textcolor{stringliteral}{"{}Foo"{}},\ EndsWith(\textcolor{stringliteral}{"{}oo"{}}));}
\DoxyCodeLine{03247\ \ \ EXPECT\_THAT(2,\ AllOf(Le(7),\ Ge(0)))\ <<\ \textcolor{stringliteral}{"{}This\ should\ succeed\ too."{}};}
\DoxyCodeLine{03248\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}Hello"{}},\ StartsWith(\textcolor{stringliteral}{"{}Hell"{}}));}
\DoxyCodeLine{03249\ \}}
\DoxyCodeLine{03250\ }
\DoxyCodeLine{03251\ \textcolor{comment}{//\ Tests\ that\ ASSERT\_THAT()\ and\ EXPECT\_THAT()\ work\ when\ the\ value}}
\DoxyCodeLine{03252\ \textcolor{comment}{//\ doesn't\ match\ the\ matcher.}}
\DoxyCodeLine{03253\ TEST(MatcherAssertionTest,\ WorksWhenMatcherIsNotSatisfied)\ \{}
\DoxyCodeLine{03254\ \ \ \textcolor{comment}{//\ 'n'\ must\ be\ static\ as\ it\ is\ used\ in\ an\ EXPECT\_FATAL\_FAILURE(),}}
\DoxyCodeLine{03255\ \ \ \textcolor{comment}{//\ which\ cannot\ reference\ auto\ variables.}}
\DoxyCodeLine{03256\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{short}\ n;\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{03257\ \ \ n\ =\ 5;}
\DoxyCodeLine{03258\ }
\DoxyCodeLine{03259\ \ \ EXPECT\_FATAL\_FAILURE(ASSERT\_THAT(n,\ Gt(10)),}
\DoxyCodeLine{03260\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Value\ of:\ n\(\backslash\)n"{}}}
\DoxyCodeLine{03261\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Expected:\ is\ >\ 10\(\backslash\)n"{}}}
\DoxyCodeLine{03262\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ Actual:\ 5"{}}\ +\ OfType(\textcolor{stringliteral}{"{}unsigned\ short"{}}));}
\DoxyCodeLine{03263\ \ \ n\ =\ 0;}
\DoxyCodeLine{03264\ \ \ EXPECT\_NONFATAL\_FAILURE(}
\DoxyCodeLine{03265\ \ \ \ \ \ \ EXPECT\_THAT(n,\ AllOf(Le(7),\ Ge(5))),}
\DoxyCodeLine{03266\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Value\ of:\ n\(\backslash\)n"{}}}
\DoxyCodeLine{03267\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Expected:\ (is\ <=\ 7)\ and\ (is\ >=\ 5)\(\backslash\)n"{}}}
\DoxyCodeLine{03268\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ Actual:\ 0"{}}\ +\ OfType(\textcolor{stringliteral}{"{}unsigned\ short"{}}));}
\DoxyCodeLine{03269\ \}}
\DoxyCodeLine{03270\ }
\DoxyCodeLine{03271\ \textcolor{comment}{//\ Tests\ that\ ASSERT\_THAT()\ and\ EXPECT\_THAT()\ work\ when\ the\ argument}}
\DoxyCodeLine{03272\ \textcolor{comment}{//\ has\ a\ reference\ type.}}
\DoxyCodeLine{03273\ TEST(MatcherAssertionTest,\ WorksForByRefArguments)\ \{}
\DoxyCodeLine{03274\ \ \ \textcolor{comment}{//\ We\ use\ a\ static\ variable\ here\ as\ EXPECT\_FATAL\_FAILURE()\ cannot}}
\DoxyCodeLine{03275\ \ \ \textcolor{comment}{//\ reference\ auto\ variables.}}
\DoxyCodeLine{03276\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{int}\ n;}
\DoxyCodeLine{03277\ \ \ n\ =\ 0;}
\DoxyCodeLine{03278\ \ \ EXPECT\_THAT(n,\ AllOf(Le(7),\ Ref(n)));}
\DoxyCodeLine{03279\ \ \ EXPECT\_FATAL\_FAILURE(ASSERT\_THAT(n,\ Not(Ref(n))),}
\DoxyCodeLine{03280\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Value\ of:\ n\(\backslash\)n"{}}}
\DoxyCodeLine{03281\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Expected:\ does\ not\ reference\ the\ variable\ @"{}});}
\DoxyCodeLine{03282\ \ \ \textcolor{comment}{//\ Tests\ the\ "{}Actual"{}\ part.}}
\DoxyCodeLine{03283\ \ \ EXPECT\_FATAL\_FAILURE(ASSERT\_THAT(n,\ Not(Ref(n))),}
\DoxyCodeLine{03284\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Actual:\ 0"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}})\ +\ \textcolor{stringliteral}{"{},\ which\ is\ located\ @"{}});}
\DoxyCodeLine{03285\ \}}
\DoxyCodeLine{03286\ }
\DoxyCodeLine{03287\ \textcolor{comment}{//\ Tests\ that\ ASSERT\_THAT()\ and\ EXPECT\_THAT()\ work\ when\ the\ matcher\ is}}
\DoxyCodeLine{03288\ \textcolor{comment}{//\ monomorphic.}}
\DoxyCodeLine{03289\ TEST(MatcherAssertionTest,\ WorksForMonomorphicMatcher)\ \{}
\DoxyCodeLine{03290\ \ \ Matcher<const\ char*>\ starts\_with\_he\ =\ StartsWith(\textcolor{stringliteral}{"{}he"{}});}
\DoxyCodeLine{03291\ \ \ ASSERT\_THAT(\textcolor{stringliteral}{"{}hello"{}},\ starts\_with\_he);}
\DoxyCodeLine{03292\ }
\DoxyCodeLine{03293\ \ \ Matcher<const\ std::string\&>\ ends\_with\_ok\ =\ EndsWith(\textcolor{stringliteral}{"{}ok"{}});}
\DoxyCodeLine{03294\ \ \ ASSERT\_THAT(\textcolor{stringliteral}{"{}book"{}},\ ends\_with\_ok);}
\DoxyCodeLine{03295\ \ \ \textcolor{keyword}{const}\ std::string\ bad\ =\ \textcolor{stringliteral}{"{}bad"{}};}
\DoxyCodeLine{03296\ \ \ EXPECT\_NONFATAL\_FAILURE(EXPECT\_THAT(bad,\ ends\_with\_ok),}
\DoxyCodeLine{03297\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Value\ of:\ bad\(\backslash\)n"{}}}
\DoxyCodeLine{03298\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Expected:\ ends\ with\ \(\backslash\)"{}ok\(\backslash\)"{}\(\backslash\)n"{}}}
\DoxyCodeLine{03299\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ Actual:\ \(\backslash\)"{}bad\(\backslash\)"{}"{}});}
\DoxyCodeLine{03300\ \ \ Matcher<int>\ is\_greater\_than\_5\ =\ Gt(5);}
\DoxyCodeLine{03301\ \ \ EXPECT\_NONFATAL\_FAILURE(EXPECT\_THAT(5,\ is\_greater\_than\_5),}
\DoxyCodeLine{03302\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Value\ of:\ 5\(\backslash\)n"{}}}
\DoxyCodeLine{03303\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Expected:\ is\ >\ 5\(\backslash\)n"{}}}
\DoxyCodeLine{03304\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ Actual:\ 5"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}));}
\DoxyCodeLine{03305\ \}}
\DoxyCodeLine{03306\ }
\DoxyCodeLine{03307\ \textcolor{comment}{//\ Tests\ floating-\/point\ matchers.}}
\DoxyCodeLine{03308\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ RawType>}
\DoxyCodeLine{03309\ \textcolor{keyword}{class\ }FloatingPointTest\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classtesting_1_1_test}{testing::Test}}\ \{}
\DoxyCodeLine{03310\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{03311\ \ \ \textcolor{keyword}{typedef}\ \mbox{\hyperlink{classtesting_1_1internal_1_1_floating_point}{testing::internal::FloatingPoint<RawType>}}\ Floating;}
\DoxyCodeLine{03312\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ Floating::Bits\ Bits;}
\DoxyCodeLine{03313\ }
\DoxyCodeLine{03314\ \ \ FloatingPointTest()}
\DoxyCodeLine{03315\ \ \ \ \ \ \ :\ max\_ulps\_(Floating::kMaxUlps),}
\DoxyCodeLine{03316\ \ \ \ \ \ \ \ \ zero\_bits\_(Floating(0).bits()),}
\DoxyCodeLine{03317\ \ \ \ \ \ \ \ \ one\_bits\_(Floating(1).bits()),}
\DoxyCodeLine{03318\ \ \ \ \ \ \ \ \ infinity\_bits\_(Floating(Floating::Infinity()).bits()),}
\DoxyCodeLine{03319\ \ \ \ \ \ \ \ \ close\_to\_positive\_zero\_(}
\DoxyCodeLine{03320\ \ \ \ \ \ \ \ \ \ \ \ \ Floating::ReinterpretBits(zero\_bits\_\ +\ max\_ulps\_/2)),}
\DoxyCodeLine{03321\ \ \ \ \ \ \ \ \ close\_to\_negative\_zero\_(}
\DoxyCodeLine{03322\ \ \ \ \ \ \ \ \ \ \ \ \ -\/Floating::ReinterpretBits(zero\_bits\_\ +\ max\_ulps\_\ -\/\ max\_ulps\_/2)),}
\DoxyCodeLine{03323\ \ \ \ \ \ \ \ \ further\_from\_negative\_zero\_(-\/Floating::ReinterpretBits(}
\DoxyCodeLine{03324\ \ \ \ \ \ \ \ \ \ \ \ \ zero\_bits\_\ +\ max\_ulps\_\ +\ 1\ -\/\ max\_ulps\_/2)),}
\DoxyCodeLine{03325\ \ \ \ \ \ \ \ \ close\_to\_one\_(Floating::ReinterpretBits(one\_bits\_\ +\ max\_ulps\_)),}
\DoxyCodeLine{03326\ \ \ \ \ \ \ \ \ further\_from\_one\_(Floating::ReinterpretBits(one\_bits\_\ +\ max\_ulps\_\ +\ 1)),}
\DoxyCodeLine{03327\ \ \ \ \ \ \ \ \ infinity\_(Floating::Infinity()),}
\DoxyCodeLine{03328\ \ \ \ \ \ \ \ \ close\_to\_infinity\_(}
\DoxyCodeLine{03329\ \ \ \ \ \ \ \ \ \ \ \ \ Floating::ReinterpretBits(infinity\_bits\_\ -\/\ max\_ulps\_)),}
\DoxyCodeLine{03330\ \ \ \ \ \ \ \ \ further\_from\_infinity\_(}
\DoxyCodeLine{03331\ \ \ \ \ \ \ \ \ \ \ \ \ Floating::ReinterpretBits(infinity\_bits\_\ -\/\ max\_ulps\_\ -\/\ 1)),}
\DoxyCodeLine{03332\ \ \ \ \ \ \ \ \ max\_(Floating::Max()),}
\DoxyCodeLine{03333\ \ \ \ \ \ \ \ \ nan1\_(Floating::ReinterpretBits(Floating::kExponentBitMask\ |\ 1)),}
\DoxyCodeLine{03334\ \ \ \ \ \ \ \ \ nan2\_(Floating::ReinterpretBits(Floating::kExponentBitMask\ |\ 200))\ \{}
\DoxyCodeLine{03335\ \ \ \}}
\DoxyCodeLine{03336\ }
\DoxyCodeLine{03337\ \ \ \textcolor{keywordtype}{void}\ TestSize()\ \{}
\DoxyCodeLine{03338\ \ \ \ \ EXPECT\_EQ(\textcolor{keyword}{sizeof}(RawType),\ \textcolor{keyword}{sizeof}(Bits));}
\DoxyCodeLine{03339\ \ \ \}}
\DoxyCodeLine{03340\ }
\DoxyCodeLine{03341\ \ \ \textcolor{comment}{//\ A\ battery\ of\ tests\ for\ FloatingEqMatcher::Matches.}}
\DoxyCodeLine{03342\ \ \ \textcolor{comment}{//\ matcher\_maker\ is\ a\ pointer\ to\ a\ function\ which\ creates\ a\ FloatingEqMatcher.}}
\DoxyCodeLine{03343\ \ \ \textcolor{keywordtype}{void}\ TestMatches(}
\DoxyCodeLine{03344\ \ \ \ \ \ \ testing::internal::FloatingEqMatcher<RawType>\ (*matcher\_maker)(RawType))\ \{}
\DoxyCodeLine{03345\ \ \ \ \ Matcher<RawType>\ m1\ =\ matcher\_maker(0.0);}
\DoxyCodeLine{03346\ \ \ \ \ EXPECT\_TRUE(m1.Matches(-\/0.0));}
\DoxyCodeLine{03347\ \ \ \ \ EXPECT\_TRUE(m1.Matches(close\_to\_positive\_zero\_));}
\DoxyCodeLine{03348\ \ \ \ \ EXPECT\_TRUE(m1.Matches(close\_to\_negative\_zero\_));}
\DoxyCodeLine{03349\ \ \ \ \ EXPECT\_FALSE(m1.Matches(1.0));}
\DoxyCodeLine{03350\ }
\DoxyCodeLine{03351\ \ \ \ \ Matcher<RawType>\ m2\ =\ matcher\_maker(close\_to\_positive\_zero\_);}
\DoxyCodeLine{03352\ \ \ \ \ EXPECT\_FALSE(m2.Matches(further\_from\_negative\_zero\_));}
\DoxyCodeLine{03353\ }
\DoxyCodeLine{03354\ \ \ \ \ Matcher<RawType>\ m3\ =\ matcher\_maker(1.0);}
\DoxyCodeLine{03355\ \ \ \ \ EXPECT\_TRUE(m3.Matches(close\_to\_one\_));}
\DoxyCodeLine{03356\ \ \ \ \ EXPECT\_FALSE(m3.Matches(further\_from\_one\_));}
\DoxyCodeLine{03357\ }
\DoxyCodeLine{03358\ \ \ \ \ \textcolor{comment}{//\ Test\ commutativity:\ matcher\_maker(0.0).Matches(1.0)\ was\ tested\ above.}}
\DoxyCodeLine{03359\ \ \ \ \ EXPECT\_FALSE(m3.Matches(0.0));}
\DoxyCodeLine{03360\ }
\DoxyCodeLine{03361\ \ \ \ \ Matcher<RawType>\ m4\ =\ matcher\_maker(-\/infinity\_);}
\DoxyCodeLine{03362\ \ \ \ \ EXPECT\_TRUE(m4.Matches(-\/close\_to\_infinity\_));}
\DoxyCodeLine{03363\ }
\DoxyCodeLine{03364\ \ \ \ \ Matcher<RawType>\ m5\ =\ matcher\_maker(infinity\_);}
\DoxyCodeLine{03365\ \ \ \ \ EXPECT\_TRUE(m5.Matches(close\_to\_infinity\_));}
\DoxyCodeLine{03366\ }
\DoxyCodeLine{03367\ \ \ \ \ \textcolor{comment}{//\ This\ is\ interesting\ as\ the\ representations\ of\ infinity\_\ and\ nan1\_}}
\DoxyCodeLine{03368\ \ \ \ \ \textcolor{comment}{//\ are\ only\ 1\ DLP\ apart.}}
\DoxyCodeLine{03369\ \ \ \ \ EXPECT\_FALSE(m5.Matches(nan1\_));}
\DoxyCodeLine{03370\ }
\DoxyCodeLine{03371\ \ \ \ \ \textcolor{comment}{//\ matcher\_maker\ can\ produce\ a\ Matcher<const\ RawType\&>,\ which\ is\ needed\ in}}
\DoxyCodeLine{03372\ \ \ \ \ \textcolor{comment}{//\ some\ cases.}}
\DoxyCodeLine{03373\ \ \ \ \ Matcher<const\ RawType\&>\ m6\ =\ matcher\_maker(0.0);}
\DoxyCodeLine{03374\ \ \ \ \ EXPECT\_TRUE(m6.Matches(-\/0.0));}
\DoxyCodeLine{03375\ \ \ \ \ EXPECT\_TRUE(m6.Matches(close\_to\_positive\_zero\_));}
\DoxyCodeLine{03376\ \ \ \ \ EXPECT\_FALSE(m6.Matches(1.0));}
\DoxyCodeLine{03377\ }
\DoxyCodeLine{03378\ \ \ \ \ \textcolor{comment}{//\ matcher\_maker\ can\ produce\ a\ Matcher<RawType\&>,\ which\ is\ needed\ in\ some}}
\DoxyCodeLine{03379\ \ \ \ \ \textcolor{comment}{//\ cases.}}
\DoxyCodeLine{03380\ \ \ \ \ Matcher<RawType\&>\ m7\ =\ matcher\_maker(0.0);}
\DoxyCodeLine{03381\ \ \ \ \ RawType\ x\ =\ 0.0;}
\DoxyCodeLine{03382\ \ \ \ \ EXPECT\_TRUE(m7.Matches(x));}
\DoxyCodeLine{03383\ \ \ \ \ x\ =\ 0.01f;}
\DoxyCodeLine{03384\ \ \ \ \ EXPECT\_FALSE(m7.Matches(x));}
\DoxyCodeLine{03385\ \ \ \}}
\DoxyCodeLine{03386\ }
\DoxyCodeLine{03387\ \ \ \textcolor{comment}{//\ Pre-\/calculated\ numbers\ to\ be\ used\ by\ the\ tests.}}
\DoxyCodeLine{03388\ }
\DoxyCodeLine{03389\ \ \ \textcolor{keyword}{const}\ Bits\ max\_ulps\_;}
\DoxyCodeLine{03390\ }
\DoxyCodeLine{03391\ \ \ \textcolor{keyword}{const}\ Bits\ zero\_bits\_;\ \ \textcolor{comment}{//\ The\ bits\ that\ represent\ 0.0.}}
\DoxyCodeLine{03392\ \ \ \textcolor{keyword}{const}\ Bits\ one\_bits\_;\ \ \textcolor{comment}{//\ The\ bits\ that\ represent\ 1.0.}}
\DoxyCodeLine{03393\ \ \ \textcolor{keyword}{const}\ Bits\ infinity\_bits\_;\ \ \textcolor{comment}{//\ The\ bits\ that\ represent\ +infinity.}}
\DoxyCodeLine{03394\ }
\DoxyCodeLine{03395\ \ \ \textcolor{comment}{//\ Some\ numbers\ close\ to\ 0.0.}}
\DoxyCodeLine{03396\ \ \ \textcolor{keyword}{const}\ RawType\ close\_to\_positive\_zero\_;}
\DoxyCodeLine{03397\ \ \ \textcolor{keyword}{const}\ RawType\ close\_to\_negative\_zero\_;}
\DoxyCodeLine{03398\ \ \ \textcolor{keyword}{const}\ RawType\ further\_from\_negative\_zero\_;}
\DoxyCodeLine{03399\ }
\DoxyCodeLine{03400\ \ \ \textcolor{comment}{//\ Some\ numbers\ close\ to\ 1.0.}}
\DoxyCodeLine{03401\ \ \ \textcolor{keyword}{const}\ RawType\ close\_to\_one\_;}
\DoxyCodeLine{03402\ \ \ \textcolor{keyword}{const}\ RawType\ further\_from\_one\_;}
\DoxyCodeLine{03403\ }
\DoxyCodeLine{03404\ \ \ \textcolor{comment}{//\ Some\ numbers\ close\ to\ +infinity.}}
\DoxyCodeLine{03405\ \ \ \textcolor{keyword}{const}\ RawType\ infinity\_;}
\DoxyCodeLine{03406\ \ \ \textcolor{keyword}{const}\ RawType\ close\_to\_infinity\_;}
\DoxyCodeLine{03407\ \ \ \textcolor{keyword}{const}\ RawType\ further\_from\_infinity\_;}
\DoxyCodeLine{03408\ }
\DoxyCodeLine{03409\ \ \ \textcolor{comment}{//\ Maximum\ representable\ value\ that's\ not\ infinity.}}
\DoxyCodeLine{03410\ \ \ \textcolor{keyword}{const}\ RawType\ max\_;}
\DoxyCodeLine{03411\ }
\DoxyCodeLine{03412\ \ \ \textcolor{comment}{//\ Some\ NaNs.}}
\DoxyCodeLine{03413\ \ \ \textcolor{keyword}{const}\ RawType\ nan1\_;}
\DoxyCodeLine{03414\ \ \ \textcolor{keyword}{const}\ RawType\ nan2\_;}
\DoxyCodeLine{03415\ \};}
\DoxyCodeLine{03416\ }
\DoxyCodeLine{03417\ \textcolor{comment}{//\ Tests\ floating-\/point\ matchers\ with\ fixed\ epsilons.}}
\DoxyCodeLine{03418\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ RawType>}
\DoxyCodeLine{03419\ \textcolor{keyword}{class\ }FloatingPointNearTest\ :\ \textcolor{keyword}{public}\ FloatingPointTest<RawType>\ \{}
\DoxyCodeLine{03420\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{03421\ \ \ \textcolor{keyword}{typedef}\ FloatingPointTest<RawType>\ ParentType;}
\DoxyCodeLine{03422\ }
\DoxyCodeLine{03423\ \ \ \textcolor{comment}{//\ A\ battery\ of\ tests\ for\ FloatingEqMatcher::Matches\ with\ a\ fixed\ epsilon.}}
\DoxyCodeLine{03424\ \ \ \textcolor{comment}{//\ matcher\_maker\ is\ a\ pointer\ to\ a\ function\ which\ creates\ a\ FloatingEqMatcher.}}
\DoxyCodeLine{03425\ \ \ \textcolor{keywordtype}{void}\ TestNearMatches(}
\DoxyCodeLine{03426\ \ \ \ \ \ \ testing::internal::FloatingEqMatcher<RawType>}
\DoxyCodeLine{03427\ \ \ \ \ \ \ \ \ \ \ (*matcher\_maker)(RawType,\ RawType))\ \{}
\DoxyCodeLine{03428\ \ \ \ \ Matcher<RawType>\ m1\ =\ matcher\_maker(0.0,\ 0.0);}
\DoxyCodeLine{03429\ \ \ \ \ EXPECT\_TRUE(m1.Matches(0.0));}
\DoxyCodeLine{03430\ \ \ \ \ EXPECT\_TRUE(m1.Matches(-\/0.0));}
\DoxyCodeLine{03431\ \ \ \ \ EXPECT\_FALSE(m1.Matches(ParentType::close\_to\_positive\_zero\_));}
\DoxyCodeLine{03432\ \ \ \ \ EXPECT\_FALSE(m1.Matches(ParentType::close\_to\_negative\_zero\_));}
\DoxyCodeLine{03433\ \ \ \ \ EXPECT\_FALSE(m1.Matches(1.0));}
\DoxyCodeLine{03434\ }
\DoxyCodeLine{03435\ \ \ \ \ Matcher<RawType>\ m2\ =\ matcher\_maker(0.0,\ 1.0);}
\DoxyCodeLine{03436\ \ \ \ \ EXPECT\_TRUE(m2.Matches(0.0));}
\DoxyCodeLine{03437\ \ \ \ \ EXPECT\_TRUE(m2.Matches(-\/0.0));}
\DoxyCodeLine{03438\ \ \ \ \ EXPECT\_TRUE(m2.Matches(1.0));}
\DoxyCodeLine{03439\ \ \ \ \ EXPECT\_TRUE(m2.Matches(-\/1.0));}
\DoxyCodeLine{03440\ \ \ \ \ EXPECT\_FALSE(m2.Matches(ParentType::close\_to\_one\_));}
\DoxyCodeLine{03441\ \ \ \ \ EXPECT\_FALSE(m2.Matches(-\/ParentType::close\_to\_one\_));}
\DoxyCodeLine{03442\ }
\DoxyCodeLine{03443\ \ \ \ \ \textcolor{comment}{//\ Check\ that\ inf\ matches\ inf,\ regardless\ of\ the\ of\ the\ specified\ max}}
\DoxyCodeLine{03444\ \ \ \ \ \textcolor{comment}{//\ absolute\ error.}}
\DoxyCodeLine{03445\ \ \ \ \ Matcher<RawType>\ m3\ =\ matcher\_maker(ParentType::infinity\_,\ 0.0);}
\DoxyCodeLine{03446\ \ \ \ \ EXPECT\_TRUE(m3.Matches(ParentType::infinity\_));}
\DoxyCodeLine{03447\ \ \ \ \ EXPECT\_FALSE(m3.Matches(ParentType::close\_to\_infinity\_));}
\DoxyCodeLine{03448\ \ \ \ \ EXPECT\_FALSE(m3.Matches(-\/ParentType::infinity\_));}
\DoxyCodeLine{03449\ }
\DoxyCodeLine{03450\ \ \ \ \ Matcher<RawType>\ m4\ =\ matcher\_maker(-\/ParentType::infinity\_,\ 0.0);}
\DoxyCodeLine{03451\ \ \ \ \ EXPECT\_TRUE(m4.Matches(-\/ParentType::infinity\_));}
\DoxyCodeLine{03452\ \ \ \ \ EXPECT\_FALSE(m4.Matches(-\/ParentType::close\_to\_infinity\_));}
\DoxyCodeLine{03453\ \ \ \ \ EXPECT\_FALSE(m4.Matches(ParentType::infinity\_));}
\DoxyCodeLine{03454\ }
\DoxyCodeLine{03455\ \ \ \ \ \textcolor{comment}{//\ Test\ various\ overflow\ scenarios.}}
\DoxyCodeLine{03456\ \ \ \ \ Matcher<RawType>\ m5\ =\ matcher\_maker(ParentType::max\_,\ ParentType::max\_);}
\DoxyCodeLine{03457\ \ \ \ \ EXPECT\_TRUE(m5.Matches(ParentType::max\_));}
\DoxyCodeLine{03458\ \ \ \ \ EXPECT\_FALSE(m5.Matches(-\/ParentType::max\_));}
\DoxyCodeLine{03459\ }
\DoxyCodeLine{03460\ \ \ \ \ Matcher<RawType>\ m6\ =\ matcher\_maker(-\/ParentType::max\_,\ ParentType::max\_);}
\DoxyCodeLine{03461\ \ \ \ \ EXPECT\_FALSE(m6.Matches(ParentType::max\_));}
\DoxyCodeLine{03462\ \ \ \ \ EXPECT\_TRUE(m6.Matches(-\/ParentType::max\_));}
\DoxyCodeLine{03463\ }
\DoxyCodeLine{03464\ \ \ \ \ Matcher<RawType>\ m7\ =\ matcher\_maker(ParentType::max\_,\ 0);}
\DoxyCodeLine{03465\ \ \ \ \ EXPECT\_TRUE(m7.Matches(ParentType::max\_));}
\DoxyCodeLine{03466\ \ \ \ \ EXPECT\_FALSE(m7.Matches(-\/ParentType::max\_));}
\DoxyCodeLine{03467\ }
\DoxyCodeLine{03468\ \ \ \ \ Matcher<RawType>\ m8\ =\ matcher\_maker(-\/ParentType::max\_,\ 0);}
\DoxyCodeLine{03469\ \ \ \ \ EXPECT\_FALSE(m8.Matches(ParentType::max\_));}
\DoxyCodeLine{03470\ \ \ \ \ EXPECT\_TRUE(m8.Matches(-\/ParentType::max\_));}
\DoxyCodeLine{03471\ }
\DoxyCodeLine{03472\ \ \ \ \ \textcolor{comment}{//\ The\ difference\ between\ max()\ and\ -\/max()\ normally\ overflows\ to\ infinity,}}
\DoxyCodeLine{03473\ \ \ \ \ \textcolor{comment}{//\ but\ it\ should\ still\ match\ if\ the\ max\_abs\_error\ is\ also\ infinity.}}
\DoxyCodeLine{03474\ \ \ \ \ Matcher<RawType>\ m9\ =\ matcher\_maker(}
\DoxyCodeLine{03475\ \ \ \ \ \ \ \ \ ParentType::max\_,\ ParentType::infinity\_);}
\DoxyCodeLine{03476\ \ \ \ \ EXPECT\_TRUE(m8.Matches(-\/ParentType::max\_));}
\DoxyCodeLine{03477\ }
\DoxyCodeLine{03478\ \ \ \ \ \textcolor{comment}{//\ matcher\_maker\ can\ produce\ a\ Matcher<const\ RawType\&>,\ which\ is\ needed\ in}}
\DoxyCodeLine{03479\ \ \ \ \ \textcolor{comment}{//\ some\ cases.}}
\DoxyCodeLine{03480\ \ \ \ \ Matcher<const\ RawType\&>\ m10\ =\ matcher\_maker(0.0,\ 1.0);}
\DoxyCodeLine{03481\ \ \ \ \ EXPECT\_TRUE(m10.Matches(-\/0.0));}
\DoxyCodeLine{03482\ \ \ \ \ EXPECT\_TRUE(m10.Matches(ParentType::close\_to\_positive\_zero\_));}
\DoxyCodeLine{03483\ \ \ \ \ EXPECT\_FALSE(m10.Matches(ParentType::close\_to\_one\_));}
\DoxyCodeLine{03484\ }
\DoxyCodeLine{03485\ \ \ \ \ \textcolor{comment}{//\ matcher\_maker\ can\ produce\ a\ Matcher<RawType\&>,\ which\ is\ needed\ in\ some}}
\DoxyCodeLine{03486\ \ \ \ \ \textcolor{comment}{//\ cases.}}
\DoxyCodeLine{03487\ \ \ \ \ Matcher<RawType\&>\ m11\ =\ matcher\_maker(0.0,\ 1.0);}
\DoxyCodeLine{03488\ \ \ \ \ RawType\ x\ =\ 0.0;}
\DoxyCodeLine{03489\ \ \ \ \ EXPECT\_TRUE(m11.Matches(x));}
\DoxyCodeLine{03490\ \ \ \ \ x\ =\ 1.0f;}
\DoxyCodeLine{03491\ \ \ \ \ EXPECT\_TRUE(m11.Matches(x));}
\DoxyCodeLine{03492\ \ \ \ \ x\ =\ -\/1.0f;}
\DoxyCodeLine{03493\ \ \ \ \ EXPECT\_TRUE(m11.Matches(x));}
\DoxyCodeLine{03494\ \ \ \ \ x\ =\ 1.1f;}
\DoxyCodeLine{03495\ \ \ \ \ EXPECT\_FALSE(m11.Matches(x));}
\DoxyCodeLine{03496\ \ \ \ \ x\ =\ -\/1.1f;}
\DoxyCodeLine{03497\ \ \ \ \ EXPECT\_FALSE(m11.Matches(x));}
\DoxyCodeLine{03498\ \ \ \}}
\DoxyCodeLine{03499\ \};}
\DoxyCodeLine{03500\ }
\DoxyCodeLine{03501\ \textcolor{comment}{//\ Instantiate\ FloatingPointTest\ for\ testing\ floats.}}
\DoxyCodeLine{03502\ \textcolor{keyword}{typedef}\ FloatingPointTest<float>\ FloatTest;}
\DoxyCodeLine{03503\ }
\DoxyCodeLine{03504\ TEST\_F(FloatTest,\ FloatEqApproximatelyMatchesFloats)\ \{}
\DoxyCodeLine{03505\ \ \ TestMatches(\&FloatEq);}
\DoxyCodeLine{03506\ \}}
\DoxyCodeLine{03507\ }
\DoxyCodeLine{03508\ TEST\_F(FloatTest,\ NanSensitiveFloatEqApproximatelyMatchesFloats)\ \{}
\DoxyCodeLine{03509\ \ \ TestMatches(\&NanSensitiveFloatEq);}
\DoxyCodeLine{03510\ \}}
\DoxyCodeLine{03511\ }
\DoxyCodeLine{03512\ TEST\_F(FloatTest,\ FloatEqCannotMatchNaN)\ \{}
\DoxyCodeLine{03513\ \ \ \textcolor{comment}{//\ FloatEq\ never\ matches\ NaN.}}
\DoxyCodeLine{03514\ \ \ Matcher<float>\ m\ =\ FloatEq(nan1\_);}
\DoxyCodeLine{03515\ \ \ EXPECT\_FALSE(m.Matches(nan1\_));}
\DoxyCodeLine{03516\ \ \ EXPECT\_FALSE(m.Matches(nan2\_));}
\DoxyCodeLine{03517\ \ \ EXPECT\_FALSE(m.Matches(1.0));}
\DoxyCodeLine{03518\ \}}
\DoxyCodeLine{03519\ }
\DoxyCodeLine{03520\ TEST\_F(FloatTest,\ NanSensitiveFloatEqCanMatchNaN)\ \{}
\DoxyCodeLine{03521\ \ \ \textcolor{comment}{//\ NanSensitiveFloatEq\ will\ match\ NaN.}}
\DoxyCodeLine{03522\ \ \ Matcher<float>\ m\ =\ NanSensitiveFloatEq(nan1\_);}
\DoxyCodeLine{03523\ \ \ EXPECT\_TRUE(m.Matches(nan1\_));}
\DoxyCodeLine{03524\ \ \ EXPECT\_TRUE(m.Matches(nan2\_));}
\DoxyCodeLine{03525\ \ \ EXPECT\_FALSE(m.Matches(1.0));}
\DoxyCodeLine{03526\ \}}
\DoxyCodeLine{03527\ }
\DoxyCodeLine{03528\ TEST\_F(FloatTest,\ FloatEqCanDescribeSelf)\ \{}
\DoxyCodeLine{03529\ \ \ Matcher<float>\ m1\ =\ FloatEq(2.0f);}
\DoxyCodeLine{03530\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 2"{}},\ Describe(m1));}
\DoxyCodeLine{03531\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ approximately\ 2"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{03532\ }
\DoxyCodeLine{03533\ \ \ Matcher<float>\ m2\ =\ FloatEq(0.5f);}
\DoxyCodeLine{03534\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 0.5"{}},\ Describe(m2));}
\DoxyCodeLine{03535\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ approximately\ 0.5"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{03536\ }
\DoxyCodeLine{03537\ \ \ Matcher<float>\ m3\ =\ FloatEq(nan1\_);}
\DoxyCodeLine{03538\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}never\ matches"{}},\ Describe(m3));}
\DoxyCodeLine{03539\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ anything"{}},\ DescribeNegation(m3));}
\DoxyCodeLine{03540\ \}}
\DoxyCodeLine{03541\ }
\DoxyCodeLine{03542\ TEST\_F(FloatTest,\ NanSensitiveFloatEqCanDescribeSelf)\ \{}
\DoxyCodeLine{03543\ \ \ Matcher<float>\ m1\ =\ NanSensitiveFloatEq(2.0f);}
\DoxyCodeLine{03544\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 2"{}},\ Describe(m1));}
\DoxyCodeLine{03545\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ approximately\ 2"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{03546\ }
\DoxyCodeLine{03547\ \ \ Matcher<float>\ m2\ =\ NanSensitiveFloatEq(0.5f);}
\DoxyCodeLine{03548\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 0.5"{}},\ Describe(m2));}
\DoxyCodeLine{03549\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ approximately\ 0.5"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{03550\ }
\DoxyCodeLine{03551\ \ \ Matcher<float>\ m3\ =\ NanSensitiveFloatEq(nan1\_);}
\DoxyCodeLine{03552\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ NaN"{}},\ Describe(m3));}
\DoxyCodeLine{03553\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NaN"{}},\ DescribeNegation(m3));}
\DoxyCodeLine{03554\ \}}
\DoxyCodeLine{03555\ }
\DoxyCodeLine{03556\ \textcolor{comment}{//\ Instantiate\ FloatingPointTest\ for\ testing\ floats\ with\ a\ user-\/specified}}
\DoxyCodeLine{03557\ \textcolor{comment}{//\ max\ absolute\ error.}}
\DoxyCodeLine{03558\ \textcolor{keyword}{typedef}\ FloatingPointNearTest<float>\ FloatNearTest;}
\DoxyCodeLine{03559\ }
\DoxyCodeLine{03560\ TEST\_F(FloatNearTest,\ FloatNearMatches)\ \{}
\DoxyCodeLine{03561\ \ \ TestNearMatches(\&FloatNear);}
\DoxyCodeLine{03562\ \}}
\DoxyCodeLine{03563\ }
\DoxyCodeLine{03564\ TEST\_F(FloatNearTest,\ NanSensitiveFloatNearApproximatelyMatchesFloats)\ \{}
\DoxyCodeLine{03565\ \ \ TestNearMatches(\&NanSensitiveFloatNear);}
\DoxyCodeLine{03566\ \}}
\DoxyCodeLine{03567\ }
\DoxyCodeLine{03568\ TEST\_F(FloatNearTest,\ FloatNearCanDescribeSelf)\ \{}
\DoxyCodeLine{03569\ \ \ Matcher<float>\ m1\ =\ FloatNear(2.0f,\ 0.5f);}
\DoxyCodeLine{03570\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 2\ (absolute\ error\ <=\ 0.5)"{}},\ Describe(m1));}
\DoxyCodeLine{03571\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{03572\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ approximately\ 2\ (absolute\ error\ >\ 0.5)"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{03573\ }
\DoxyCodeLine{03574\ \ \ Matcher<float>\ m2\ =\ FloatNear(0.5f,\ 0.5f);}
\DoxyCodeLine{03575\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 0.5\ (absolute\ error\ <=\ 0.5)"{}},\ Describe(m2));}
\DoxyCodeLine{03576\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{03577\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ approximately\ 0.5\ (absolute\ error\ >\ 0.5)"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{03578\ }
\DoxyCodeLine{03579\ \ \ Matcher<float>\ m3\ =\ FloatNear(nan1\_,\ 0.0);}
\DoxyCodeLine{03580\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}never\ matches"{}},\ Describe(m3));}
\DoxyCodeLine{03581\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ anything"{}},\ DescribeNegation(m3));}
\DoxyCodeLine{03582\ \}}
\DoxyCodeLine{03583\ }
\DoxyCodeLine{03584\ TEST\_F(FloatNearTest,\ NanSensitiveFloatNearCanDescribeSelf)\ \{}
\DoxyCodeLine{03585\ \ \ Matcher<float>\ m1\ =\ NanSensitiveFloatNear(2.0f,\ 0.5f);}
\DoxyCodeLine{03586\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 2\ (absolute\ error\ <=\ 0.5)"{}},\ Describe(m1));}
\DoxyCodeLine{03587\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{03588\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ approximately\ 2\ (absolute\ error\ >\ 0.5)"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{03589\ }
\DoxyCodeLine{03590\ \ \ Matcher<float>\ m2\ =\ NanSensitiveFloatNear(0.5f,\ 0.5f);}
\DoxyCodeLine{03591\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 0.5\ (absolute\ error\ <=\ 0.5)"{}},\ Describe(m2));}
\DoxyCodeLine{03592\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{03593\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ approximately\ 0.5\ (absolute\ error\ >\ 0.5)"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{03594\ }
\DoxyCodeLine{03595\ \ \ Matcher<float>\ m3\ =\ NanSensitiveFloatNear(nan1\_,\ 0.1f);}
\DoxyCodeLine{03596\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ NaN"{}},\ Describe(m3));}
\DoxyCodeLine{03597\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NaN"{}},\ DescribeNegation(m3));}
\DoxyCodeLine{03598\ \}}
\DoxyCodeLine{03599\ }
\DoxyCodeLine{03600\ TEST\_F(FloatNearTest,\ FloatNearCannotMatchNaN)\ \{}
\DoxyCodeLine{03601\ \ \ \textcolor{comment}{//\ FloatNear\ never\ matches\ NaN.}}
\DoxyCodeLine{03602\ \ \ Matcher<float>\ m\ =\ FloatNear(ParentType::nan1\_,\ 0.1f);}
\DoxyCodeLine{03603\ \ \ EXPECT\_FALSE(m.Matches(nan1\_));}
\DoxyCodeLine{03604\ \ \ EXPECT\_FALSE(m.Matches(nan2\_));}
\DoxyCodeLine{03605\ \ \ EXPECT\_FALSE(m.Matches(1.0));}
\DoxyCodeLine{03606\ \}}
\DoxyCodeLine{03607\ }
\DoxyCodeLine{03608\ TEST\_F(FloatNearTest,\ NanSensitiveFloatNearCanMatchNaN)\ \{}
\DoxyCodeLine{03609\ \ \ \textcolor{comment}{//\ NanSensitiveFloatNear\ will\ match\ NaN.}}
\DoxyCodeLine{03610\ \ \ Matcher<float>\ m\ =\ NanSensitiveFloatNear(nan1\_,\ 0.1f);}
\DoxyCodeLine{03611\ \ \ EXPECT\_TRUE(m.Matches(nan1\_));}
\DoxyCodeLine{03612\ \ \ EXPECT\_TRUE(m.Matches(nan2\_));}
\DoxyCodeLine{03613\ \ \ EXPECT\_FALSE(m.Matches(1.0));}
\DoxyCodeLine{03614\ \}}
\DoxyCodeLine{03615\ }
\DoxyCodeLine{03616\ \textcolor{comment}{//\ Instantiate\ FloatingPointTest\ for\ testing\ doubles.}}
\DoxyCodeLine{03617\ \textcolor{keyword}{typedef}\ FloatingPointTest<double>\ DoubleTest;}
\DoxyCodeLine{03618\ }
\DoxyCodeLine{03619\ TEST\_F(DoubleTest,\ DoubleEqApproximatelyMatchesDoubles)\ \{}
\DoxyCodeLine{03620\ \ \ TestMatches(\&DoubleEq);}
\DoxyCodeLine{03621\ \}}
\DoxyCodeLine{03622\ }
\DoxyCodeLine{03623\ TEST\_F(DoubleTest,\ NanSensitiveDoubleEqApproximatelyMatchesDoubles)\ \{}
\DoxyCodeLine{03624\ \ \ TestMatches(\&NanSensitiveDoubleEq);}
\DoxyCodeLine{03625\ \}}
\DoxyCodeLine{03626\ }
\DoxyCodeLine{03627\ TEST\_F(DoubleTest,\ DoubleEqCannotMatchNaN)\ \{}
\DoxyCodeLine{03628\ \ \ \textcolor{comment}{//\ DoubleEq\ never\ matches\ NaN.}}
\DoxyCodeLine{03629\ \ \ Matcher<double>\ m\ =\ DoubleEq(nan1\_);}
\DoxyCodeLine{03630\ \ \ EXPECT\_FALSE(m.Matches(nan1\_));}
\DoxyCodeLine{03631\ \ \ EXPECT\_FALSE(m.Matches(nan2\_));}
\DoxyCodeLine{03632\ \ \ EXPECT\_FALSE(m.Matches(1.0));}
\DoxyCodeLine{03633\ \}}
\DoxyCodeLine{03634\ }
\DoxyCodeLine{03635\ TEST\_F(DoubleTest,\ NanSensitiveDoubleEqCanMatchNaN)\ \{}
\DoxyCodeLine{03636\ \ \ \textcolor{comment}{//\ NanSensitiveDoubleEq\ will\ match\ NaN.}}
\DoxyCodeLine{03637\ \ \ Matcher<double>\ m\ =\ NanSensitiveDoubleEq(nan1\_);}
\DoxyCodeLine{03638\ \ \ EXPECT\_TRUE(m.Matches(nan1\_));}
\DoxyCodeLine{03639\ \ \ EXPECT\_TRUE(m.Matches(nan2\_));}
\DoxyCodeLine{03640\ \ \ EXPECT\_FALSE(m.Matches(1.0));}
\DoxyCodeLine{03641\ \}}
\DoxyCodeLine{03642\ }
\DoxyCodeLine{03643\ TEST\_F(DoubleTest,\ DoubleEqCanDescribeSelf)\ \{}
\DoxyCodeLine{03644\ \ \ Matcher<double>\ m1\ =\ DoubleEq(2.0);}
\DoxyCodeLine{03645\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 2"{}},\ Describe(m1));}
\DoxyCodeLine{03646\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ approximately\ 2"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{03647\ }
\DoxyCodeLine{03648\ \ \ Matcher<double>\ m2\ =\ DoubleEq(0.5);}
\DoxyCodeLine{03649\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 0.5"{}},\ Describe(m2));}
\DoxyCodeLine{03650\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ approximately\ 0.5"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{03651\ }
\DoxyCodeLine{03652\ \ \ Matcher<double>\ m3\ =\ DoubleEq(nan1\_);}
\DoxyCodeLine{03653\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}never\ matches"{}},\ Describe(m3));}
\DoxyCodeLine{03654\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ anything"{}},\ DescribeNegation(m3));}
\DoxyCodeLine{03655\ \}}
\DoxyCodeLine{03656\ }
\DoxyCodeLine{03657\ TEST\_F(DoubleTest,\ NanSensitiveDoubleEqCanDescribeSelf)\ \{}
\DoxyCodeLine{03658\ \ \ Matcher<double>\ m1\ =\ NanSensitiveDoubleEq(2.0);}
\DoxyCodeLine{03659\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 2"{}},\ Describe(m1));}
\DoxyCodeLine{03660\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ approximately\ 2"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{03661\ }
\DoxyCodeLine{03662\ \ \ Matcher<double>\ m2\ =\ NanSensitiveDoubleEq(0.5);}
\DoxyCodeLine{03663\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 0.5"{}},\ Describe(m2));}
\DoxyCodeLine{03664\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ approximately\ 0.5"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{03665\ }
\DoxyCodeLine{03666\ \ \ Matcher<double>\ m3\ =\ NanSensitiveDoubleEq(nan1\_);}
\DoxyCodeLine{03667\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ NaN"{}},\ Describe(m3));}
\DoxyCodeLine{03668\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NaN"{}},\ DescribeNegation(m3));}
\DoxyCodeLine{03669\ \}}
\DoxyCodeLine{03670\ }
\DoxyCodeLine{03671\ \textcolor{comment}{//\ Instantiate\ FloatingPointTest\ for\ testing\ floats\ with\ a\ user-\/specified}}
\DoxyCodeLine{03672\ \textcolor{comment}{//\ max\ absolute\ error.}}
\DoxyCodeLine{03673\ \textcolor{keyword}{typedef}\ FloatingPointNearTest<double>\ DoubleNearTest;}
\DoxyCodeLine{03674\ }
\DoxyCodeLine{03675\ TEST\_F(DoubleNearTest,\ DoubleNearMatches)\ \{}
\DoxyCodeLine{03676\ \ \ TestNearMatches(\&DoubleNear);}
\DoxyCodeLine{03677\ \}}
\DoxyCodeLine{03678\ }
\DoxyCodeLine{03679\ TEST\_F(DoubleNearTest,\ NanSensitiveDoubleNearApproximatelyMatchesDoubles)\ \{}
\DoxyCodeLine{03680\ \ \ TestNearMatches(\&NanSensitiveDoubleNear);}
\DoxyCodeLine{03681\ \}}
\DoxyCodeLine{03682\ }
\DoxyCodeLine{03683\ TEST\_F(DoubleNearTest,\ DoubleNearCanDescribeSelf)\ \{}
\DoxyCodeLine{03684\ \ \ Matcher<double>\ m1\ =\ DoubleNear(2.0,\ 0.5);}
\DoxyCodeLine{03685\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 2\ (absolute\ error\ <=\ 0.5)"{}},\ Describe(m1));}
\DoxyCodeLine{03686\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{03687\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ approximately\ 2\ (absolute\ error\ >\ 0.5)"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{03688\ }
\DoxyCodeLine{03689\ \ \ Matcher<double>\ m2\ =\ DoubleNear(0.5,\ 0.5);}
\DoxyCodeLine{03690\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 0.5\ (absolute\ error\ <=\ 0.5)"{}},\ Describe(m2));}
\DoxyCodeLine{03691\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{03692\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ approximately\ 0.5\ (absolute\ error\ >\ 0.5)"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{03693\ }
\DoxyCodeLine{03694\ \ \ Matcher<double>\ m3\ =\ DoubleNear(nan1\_,\ 0.0);}
\DoxyCodeLine{03695\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}never\ matches"{}},\ Describe(m3));}
\DoxyCodeLine{03696\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ anything"{}},\ DescribeNegation(m3));}
\DoxyCodeLine{03697\ \}}
\DoxyCodeLine{03698\ }
\DoxyCodeLine{03699\ TEST\_F(DoubleNearTest,\ ExplainsResultWhenMatchFails)\ \{}
\DoxyCodeLine{03700\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(DoubleNear(2.0,\ 0.1),\ 2.05));}
\DoxyCodeLine{03701\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 0.2\ from\ 2"{}},\ Explain(DoubleNear(2.0,\ 0.1),\ 2.2));}
\DoxyCodeLine{03702\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ -\/0.3\ from\ 2"{}},\ Explain(DoubleNear(2.0,\ 0.1),\ 1.7));}
\DoxyCodeLine{03703\ }
\DoxyCodeLine{03704\ \ \ \textcolor{keyword}{const}\ std::string\ explanation\ =}
\DoxyCodeLine{03705\ \ \ \ \ \ \ Explain(DoubleNear(2.1,\ 1e-\/10),\ 2.1\ +\ 1.2e-\/10);}
\DoxyCodeLine{03706\ \ \ \textcolor{comment}{//\ Different\ C++\ implementations\ may\ print\ floating-\/point\ numbers}}
\DoxyCodeLine{03707\ \ \ \textcolor{comment}{//\ slightly\ differently.}}
\DoxyCodeLine{03708\ \ \ EXPECT\_TRUE(explanation\ ==\ \textcolor{stringliteral}{"{}which\ is\ 1.2e-\/10\ from\ 2.1"{}}\ ||\ \ \textcolor{comment}{//\ GCC}}
\DoxyCodeLine{03709\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ explanation\ ==\ \textcolor{stringliteral}{"{}which\ is\ 1.2e-\/010\ from\ 2.1"{}})\ \ \ \textcolor{comment}{//\ MSVC}}
\DoxyCodeLine{03710\ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ where\ explanation\ is\ \(\backslash\)"{}"{}}\ <<\ explanation\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)"{}."{}};}
\DoxyCodeLine{03711\ \}}
\DoxyCodeLine{03712\ }
\DoxyCodeLine{03713\ TEST\_F(DoubleNearTest,\ NanSensitiveDoubleNearCanDescribeSelf)\ \{}
\DoxyCodeLine{03714\ \ \ Matcher<double>\ m1\ =\ NanSensitiveDoubleNear(2.0,\ 0.5);}
\DoxyCodeLine{03715\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 2\ (absolute\ error\ <=\ 0.5)"{}},\ Describe(m1));}
\DoxyCodeLine{03716\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{03717\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ approximately\ 2\ (absolute\ error\ >\ 0.5)"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{03718\ }
\DoxyCodeLine{03719\ \ \ Matcher<double>\ m2\ =\ NanSensitiveDoubleNear(0.5,\ 0.5);}
\DoxyCodeLine{03720\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ approximately\ 0.5\ (absolute\ error\ <=\ 0.5)"{}},\ Describe(m2));}
\DoxyCodeLine{03721\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{03722\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ approximately\ 0.5\ (absolute\ error\ >\ 0.5)"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{03723\ }
\DoxyCodeLine{03724\ \ \ Matcher<double>\ m3\ =\ NanSensitiveDoubleNear(nan1\_,\ 0.1);}
\DoxyCodeLine{03725\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ NaN"{}},\ Describe(m3));}
\DoxyCodeLine{03726\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ NaN"{}},\ DescribeNegation(m3));}
\DoxyCodeLine{03727\ \}}
\DoxyCodeLine{03728\ }
\DoxyCodeLine{03729\ TEST\_F(DoubleNearTest,\ DoubleNearCannotMatchNaN)\ \{}
\DoxyCodeLine{03730\ \ \ \textcolor{comment}{//\ DoubleNear\ never\ matches\ NaN.}}
\DoxyCodeLine{03731\ \ \ Matcher<double>\ m\ =\ DoubleNear(ParentType::nan1\_,\ 0.1);}
\DoxyCodeLine{03732\ \ \ EXPECT\_FALSE(m.Matches(nan1\_));}
\DoxyCodeLine{03733\ \ \ EXPECT\_FALSE(m.Matches(nan2\_));}
\DoxyCodeLine{03734\ \ \ EXPECT\_FALSE(m.Matches(1.0));}
\DoxyCodeLine{03735\ \}}
\DoxyCodeLine{03736\ }
\DoxyCodeLine{03737\ TEST\_F(DoubleNearTest,\ NanSensitiveDoubleNearCanMatchNaN)\ \{}
\DoxyCodeLine{03738\ \ \ \textcolor{comment}{//\ NanSensitiveDoubleNear\ will\ match\ NaN.}}
\DoxyCodeLine{03739\ \ \ Matcher<double>\ m\ =\ NanSensitiveDoubleNear(nan1\_,\ 0.1);}
\DoxyCodeLine{03740\ \ \ EXPECT\_TRUE(m.Matches(nan1\_));}
\DoxyCodeLine{03741\ \ \ EXPECT\_TRUE(m.Matches(nan2\_));}
\DoxyCodeLine{03742\ \ \ EXPECT\_FALSE(m.Matches(1.0));}
\DoxyCodeLine{03743\ \}}
\DoxyCodeLine{03744\ }
\DoxyCodeLine{03745\ TEST(PointeeTest,\ RawPointer)\ \{}
\DoxyCodeLine{03746\ \ \ \textcolor{keyword}{const}\ Matcher<int*>\ m\ =\ Pointee(Ge(0));}
\DoxyCodeLine{03747\ }
\DoxyCodeLine{03748\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 1;}
\DoxyCodeLine{03749\ \ \ EXPECT\_TRUE(m.Matches(\&n));}
\DoxyCodeLine{03750\ \ \ n\ =\ -\/1;}
\DoxyCodeLine{03751\ \ \ EXPECT\_FALSE(m.Matches(\&n));}
\DoxyCodeLine{03752\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{03753\ \}}
\DoxyCodeLine{03754\ }
\DoxyCodeLine{03755\ TEST(PointeeTest,\ RawPointerToConst)\ \{}
\DoxyCodeLine{03756\ \ \ \textcolor{keyword}{const}\ Matcher<const\ double*>\ m\ =\ Pointee(Ge(0));}
\DoxyCodeLine{03757\ }
\DoxyCodeLine{03758\ \ \ \textcolor{keywordtype}{double}\ x\ =\ 1;}
\DoxyCodeLine{03759\ \ \ EXPECT\_TRUE(m.Matches(\&x));}
\DoxyCodeLine{03760\ \ \ x\ =\ -\/1;}
\DoxyCodeLine{03761\ \ \ EXPECT\_FALSE(m.Matches(\&x));}
\DoxyCodeLine{03762\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{03763\ \}}
\DoxyCodeLine{03764\ }
\DoxyCodeLine{03765\ TEST(PointeeTest,\ ReferenceToConstRawPointer)\ \{}
\DoxyCodeLine{03766\ \ \ \textcolor{keyword}{const}\ Matcher<int*\ const\ \&>\ m\ =\ Pointee(Ge(0));}
\DoxyCodeLine{03767\ }
\DoxyCodeLine{03768\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 1;}
\DoxyCodeLine{03769\ \ \ EXPECT\_TRUE(m.Matches(\&n));}
\DoxyCodeLine{03770\ \ \ n\ =\ -\/1;}
\DoxyCodeLine{03771\ \ \ EXPECT\_FALSE(m.Matches(\&n));}
\DoxyCodeLine{03772\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{03773\ \}}
\DoxyCodeLine{03774\ }
\DoxyCodeLine{03775\ TEST(PointeeTest,\ ReferenceToNonConstRawPointer)\ \{}
\DoxyCodeLine{03776\ \ \ \textcolor{keyword}{const}\ Matcher<double*\ \&>\ m\ =\ Pointee(Ge(0));}
\DoxyCodeLine{03777\ }
\DoxyCodeLine{03778\ \ \ \textcolor{keywordtype}{double}\ x\ =\ 1.0;}
\DoxyCodeLine{03779\ \ \ \textcolor{keywordtype}{double}*\ p\ =\ \&x;}
\DoxyCodeLine{03780\ \ \ EXPECT\_TRUE(m.Matches(p));}
\DoxyCodeLine{03781\ \ \ x\ =\ -\/1;}
\DoxyCodeLine{03782\ \ \ EXPECT\_FALSE(m.Matches(p));}
\DoxyCodeLine{03783\ \ \ p\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03784\ \ \ EXPECT\_FALSE(m.Matches(p));}
\DoxyCodeLine{03785\ \}}
\DoxyCodeLine{03786\ }
\DoxyCodeLine{03787\ TEST(PointeeTest,\ SmartPointer)\ \{}
\DoxyCodeLine{03788\ \ \ \textcolor{keyword}{const}\ Matcher<std::unique\_ptr<int>>\ m\ =\ Pointee(Ge(0));}
\DoxyCodeLine{03789\ }
\DoxyCodeLine{03790\ \ \ std::unique\_ptr<int>\ n(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(1));}
\DoxyCodeLine{03791\ \ \ EXPECT\_TRUE(m.Matches(n));}
\DoxyCodeLine{03792\ \}}
\DoxyCodeLine{03793\ }
\DoxyCodeLine{03794\ TEST(PointeeTest,\ SmartPointerToConst)\ \{}
\DoxyCodeLine{03795\ \ \ \textcolor{keyword}{const}\ Matcher<std::unique\_ptr<const\ int>>\ m\ =\ Pointee(Ge(0));}
\DoxyCodeLine{03796\ }
\DoxyCodeLine{03797\ \ \ \textcolor{comment}{//\ There's\ no\ implicit\ conversion\ from\ unique\_ptr<int>\ to\ const}}
\DoxyCodeLine{03798\ \ \ \textcolor{comment}{//\ unique\_ptr<const\ int>,\ so\ we\ must\ pass\ a\ unique\_ptr<const\ int>\ into\ the}}
\DoxyCodeLine{03799\ \ \ \textcolor{comment}{//\ matcher.}}
\DoxyCodeLine{03800\ \ \ std::unique\_ptr<const\ int>\ n(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(1));}
\DoxyCodeLine{03801\ \ \ EXPECT\_TRUE(m.Matches(n));}
\DoxyCodeLine{03802\ \}}
\DoxyCodeLine{03803\ }
\DoxyCodeLine{03804\ TEST(PointerTest,\ RawPointer)\ \{}
\DoxyCodeLine{03805\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 1;}
\DoxyCodeLine{03806\ \ \ \textcolor{keyword}{const}\ Matcher<int*>\ m\ =\ Pointer(Eq(\&n));}
\DoxyCodeLine{03807\ }
\DoxyCodeLine{03808\ \ \ EXPECT\_TRUE(m.Matches(\&n));}
\DoxyCodeLine{03809\ }
\DoxyCodeLine{03810\ \ \ \textcolor{keywordtype}{int}*\ p\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03811\ \ \ EXPECT\_FALSE(m.Matches(p));}
\DoxyCodeLine{03812\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{03813\ \}}
\DoxyCodeLine{03814\ }
\DoxyCodeLine{03815\ TEST(PointerTest,\ RawPointerToConst)\ \{}
\DoxyCodeLine{03816\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 1;}
\DoxyCodeLine{03817\ \ \ \textcolor{keyword}{const}\ Matcher<const\ int*>\ m\ =\ Pointer(Eq(\&n));}
\DoxyCodeLine{03818\ }
\DoxyCodeLine{03819\ \ \ EXPECT\_TRUE(m.Matches(\&n));}
\DoxyCodeLine{03820\ }
\DoxyCodeLine{03821\ \ \ \textcolor{keywordtype}{int}*\ p\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03822\ \ \ EXPECT\_FALSE(m.Matches(p));}
\DoxyCodeLine{03823\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{03824\ \}}
\DoxyCodeLine{03825\ }
\DoxyCodeLine{03826\ TEST(PointerTest,\ SmartPointer)\ \{}
\DoxyCodeLine{03827\ \ \ std::unique\_ptr<int>\ n(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(10));}
\DoxyCodeLine{03828\ \ \ \textcolor{keywordtype}{int}*\ raw\_n\ =\ n.get();}
\DoxyCodeLine{03829\ \ \ \textcolor{keyword}{const}\ Matcher<std::unique\_ptr<int>>\ m\ =\ Pointer(Eq(raw\_n));}
\DoxyCodeLine{03830\ }
\DoxyCodeLine{03831\ \ \ EXPECT\_TRUE(m.Matches(n));}
\DoxyCodeLine{03832\ \}}
\DoxyCodeLine{03833\ }
\DoxyCodeLine{03834\ TEST(PointerTest,\ SmartPointerToConst)\ \{}
\DoxyCodeLine{03835\ \ \ std::unique\_ptr<const\ int>\ n(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(10));}
\DoxyCodeLine{03836\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ raw\_n\ =\ n.get();}
\DoxyCodeLine{03837\ \ \ \textcolor{keyword}{const}\ Matcher<std::unique\_ptr<const\ int>>\ m\ =\ Pointer(Eq(raw\_n));}
\DoxyCodeLine{03838\ }
\DoxyCodeLine{03839\ \ \ \textcolor{comment}{//\ There's\ no\ implicit\ conversion\ from\ unique\_ptr<int>\ to\ const}}
\DoxyCodeLine{03840\ \ \ \textcolor{comment}{//\ unique\_ptr<const\ int>,\ so\ we\ must\ pass\ a\ unique\_ptr<const\ int>\ into\ the}}
\DoxyCodeLine{03841\ \ \ \textcolor{comment}{//\ matcher.}}
\DoxyCodeLine{03842\ \ \ std::unique\_ptr<const\ int>\ p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(10));}
\DoxyCodeLine{03843\ \ \ EXPECT\_FALSE(m.Matches(p));}
\DoxyCodeLine{03844\ \}}
\DoxyCodeLine{03845\ }
\DoxyCodeLine{03846\ TEST(AddressTest,\ NonConst)\ \{}
\DoxyCodeLine{03847\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 1;}
\DoxyCodeLine{03848\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ Address(Eq(\&n));}
\DoxyCodeLine{03849\ }
\DoxyCodeLine{03850\ \ \ EXPECT\_TRUE(m.Matches(n));}
\DoxyCodeLine{03851\ }
\DoxyCodeLine{03852\ \ \ \textcolor{keywordtype}{int}\ other\ =\ 5;}
\DoxyCodeLine{03853\ }
\DoxyCodeLine{03854\ \ \ EXPECT\_FALSE(m.Matches(other));}
\DoxyCodeLine{03855\ }
\DoxyCodeLine{03856\ \ \ \textcolor{keywordtype}{int}\&\ n\_ref\ =\ n;}
\DoxyCodeLine{03857\ }
\DoxyCodeLine{03858\ \ \ EXPECT\_TRUE(m.Matches(n\_ref));}
\DoxyCodeLine{03859\ \}}
\DoxyCodeLine{03860\ }
\DoxyCodeLine{03861\ TEST(AddressTest,\ Const)\ \{}
\DoxyCodeLine{03862\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ n\ =\ 1;}
\DoxyCodeLine{03863\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ Address(Eq(\&n));}
\DoxyCodeLine{03864\ }
\DoxyCodeLine{03865\ \ \ EXPECT\_TRUE(m.Matches(n));}
\DoxyCodeLine{03866\ }
\DoxyCodeLine{03867\ \ \ \textcolor{keywordtype}{int}\ other\ =\ 5;}
\DoxyCodeLine{03868\ }
\DoxyCodeLine{03869\ \ \ EXPECT\_FALSE(m.Matches(other));}
\DoxyCodeLine{03870\ \}}
\DoxyCodeLine{03871\ }
\DoxyCodeLine{03872\ TEST(AddressTest,\ MatcherDoesntCopy)\ \{}
\DoxyCodeLine{03873\ \ \ std::unique\_ptr<int>\ n(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(1));}
\DoxyCodeLine{03874\ \ \ \textcolor{keyword}{const}\ Matcher<std::unique\_ptr<int>>\ m\ =\ Address(Eq(\&n));}
\DoxyCodeLine{03875\ }
\DoxyCodeLine{03876\ \ \ EXPECT\_TRUE(m.Matches(n));}
\DoxyCodeLine{03877\ \}}
\DoxyCodeLine{03878\ }
\DoxyCodeLine{03879\ TEST(AddressTest,\ Describe)\ \{}
\DoxyCodeLine{03880\ \ \ Matcher<int>\ matcher\ =\ Address(\_);}
\DoxyCodeLine{03881\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ address\ that\ is\ anything"{}},\ Describe(matcher));}
\DoxyCodeLine{03882\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}does\ not\ have\ address\ that\ is\ anything"{}},}
\DoxyCodeLine{03883\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(matcher));}
\DoxyCodeLine{03884\ \}}
\DoxyCodeLine{03885\ }
\DoxyCodeLine{03886\ MATCHER\_P(FieldIIs,\ inner\_matcher,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{03887\ \ \ \textcolor{keywordflow}{return}\ ExplainMatchResult(inner\_matcher,\ arg.i,\ result\_listener);}
\DoxyCodeLine{03888\ \}}
\DoxyCodeLine{03889\ }
\DoxyCodeLine{03890\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{03891\ TEST(WhenDynamicCastToTest,\ SameType)\ \{}
\DoxyCodeLine{03892\ \ \ Derived\ derived;}
\DoxyCodeLine{03893\ \ \ derived.i\ =\ 4;}
\DoxyCodeLine{03894\ }
\DoxyCodeLine{03895\ \ \ \textcolor{comment}{//\ Right\ type.\ A\ pointer\ is\ passed\ down.}}
\DoxyCodeLine{03896\ \ \ Base*\ as\_base\_ptr\ =\ \&derived;}
\DoxyCodeLine{03897\ \ \ EXPECT\_THAT(as\_base\_ptr,\ WhenDynamicCastTo<Derived*>(Not(IsNull())));}
\DoxyCodeLine{03898\ \ \ EXPECT\_THAT(as\_base\_ptr,\ WhenDynamicCastTo<Derived*>(Pointee(FieldIIs(4))));}
\DoxyCodeLine{03899\ \ \ EXPECT\_THAT(as\_base\_ptr,}
\DoxyCodeLine{03900\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Not(WhenDynamicCastTo<Derived*>(Pointee(FieldIIs(5)))));}
\DoxyCodeLine{03901\ \}}
\DoxyCodeLine{03902\ }
\DoxyCodeLine{03903\ TEST(WhenDynamicCastToTest,\ WrongTypes)\ \{}
\DoxyCodeLine{03904\ \ \ Base\ base;}
\DoxyCodeLine{03905\ \ \ Derived\ derived;}
\DoxyCodeLine{03906\ \ \ OtherDerived\ other\_derived;}
\DoxyCodeLine{03907\ }
\DoxyCodeLine{03908\ \ \ \textcolor{comment}{//\ Wrong\ types.\ NULL\ is\ passed.}}
\DoxyCodeLine{03909\ \ \ EXPECT\_THAT(\&base,\ Not(WhenDynamicCastTo<Derived*>(Pointee(\_))));}
\DoxyCodeLine{03910\ \ \ EXPECT\_THAT(\&base,\ WhenDynamicCastTo<Derived*>(IsNull()));}
\DoxyCodeLine{03911\ \ \ Base*\ as\_base\_ptr\ =\ \&derived;}
\DoxyCodeLine{03912\ \ \ EXPECT\_THAT(as\_base\_ptr,\ Not(WhenDynamicCastTo<OtherDerived*>(Pointee(\_))));}
\DoxyCodeLine{03913\ \ \ EXPECT\_THAT(as\_base\_ptr,\ WhenDynamicCastTo<OtherDerived*>(IsNull()));}
\DoxyCodeLine{03914\ \ \ as\_base\_ptr\ =\ \&other\_derived;}
\DoxyCodeLine{03915\ \ \ EXPECT\_THAT(as\_base\_ptr,\ Not(WhenDynamicCastTo<Derived*>(Pointee(\_))));}
\DoxyCodeLine{03916\ \ \ EXPECT\_THAT(as\_base\_ptr,\ WhenDynamicCastTo<Derived*>(IsNull()));}
\DoxyCodeLine{03917\ \}}
\DoxyCodeLine{03918\ }
\DoxyCodeLine{03919\ TEST(WhenDynamicCastToTest,\ AlreadyNull)\ \{}
\DoxyCodeLine{03920\ \ \ \textcolor{comment}{//\ Already\ NULL.}}
\DoxyCodeLine{03921\ \ \ Base*\ as\_base\_ptr\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03922\ \ \ EXPECT\_THAT(as\_base\_ptr,\ WhenDynamicCastTo<Derived*>(IsNull()));}
\DoxyCodeLine{03923\ \}}
\DoxyCodeLine{03924\ }
\DoxyCodeLine{03925\ \textcolor{keyword}{struct\ }AmbiguousCastTypes\ \{}
\DoxyCodeLine{03926\ \ \ \textcolor{keyword}{class\ }VirtualDerived\ :\ \textcolor{keyword}{public}\ \textcolor{keyword}{virtual}\ Base\ \{\};}
\DoxyCodeLine{03927\ \ \ \textcolor{keyword}{class\ }DerivedSub1\ :\ \textcolor{keyword}{public}\ VirtualDerived\ \{\};}
\DoxyCodeLine{03928\ \ \ \textcolor{keyword}{class\ }DerivedSub2\ :\ \textcolor{keyword}{public}\ VirtualDerived\ \{\};}
\DoxyCodeLine{03929\ \ \ \textcolor{keyword}{class\ }ManyDerivedInHierarchy\ :\ \textcolor{keyword}{public}\ DerivedSub1,\ \textcolor{keyword}{public}\ DerivedSub2\ \{\};}
\DoxyCodeLine{03930\ \};}
\DoxyCodeLine{03931\ }
\DoxyCodeLine{03932\ TEST(WhenDynamicCastToTest,\ AmbiguousCast)\ \{}
\DoxyCodeLine{03933\ \ \ AmbiguousCastTypes::DerivedSub1\ sub1;}
\DoxyCodeLine{03934\ \ \ AmbiguousCastTypes::ManyDerivedInHierarchy\ many\_derived;}
\DoxyCodeLine{03935\ \ \ \textcolor{comment}{//\ Multiply\ derived\ from\ Base.\ dynamic\_cast<>\ returns\ NULL.}}
\DoxyCodeLine{03936\ \ \ Base*\ as\_base\_ptr\ =}
\DoxyCodeLine{03937\ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}AmbiguousCastTypes::DerivedSub1*\textcolor{keyword}{>}(\&many\_derived);}
\DoxyCodeLine{03938\ \ \ EXPECT\_THAT(as\_base\_ptr,}
\DoxyCodeLine{03939\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ WhenDynamicCastTo<AmbiguousCastTypes::VirtualDerived*>(IsNull()));}
\DoxyCodeLine{03940\ \ \ as\_base\_ptr\ =\ \&sub1;}
\DoxyCodeLine{03941\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{03942\ \ \ \ \ \ \ as\_base\_ptr,}
\DoxyCodeLine{03943\ \ \ \ \ \ \ WhenDynamicCastTo<AmbiguousCastTypes::VirtualDerived*>(Not(IsNull())));}
\DoxyCodeLine{03944\ \}}
\DoxyCodeLine{03945\ }
\DoxyCodeLine{03946\ TEST(WhenDynamicCastToTest,\ Describe)\ \{}
\DoxyCodeLine{03947\ \ \ Matcher<Base*>\ matcher\ =\ WhenDynamicCastTo<Derived*>(Pointee(\_));}
\DoxyCodeLine{03948\ \ \ \textcolor{keyword}{const}\ std::string\ prefix\ =}
\DoxyCodeLine{03949\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}when\ dynamic\_cast\ to\ "{}}\ +\ internal::GetTypeName<Derived*>()\ +\ \textcolor{stringliteral}{"{},\ "{}};}
\DoxyCodeLine{03950\ \ \ EXPECT\_EQ(prefix\ +\ \textcolor{stringliteral}{"{}points\ to\ a\ value\ that\ is\ anything"{}},\ Describe(matcher));}
\DoxyCodeLine{03951\ \ \ EXPECT\_EQ(prefix\ +\ \textcolor{stringliteral}{"{}does\ not\ point\ to\ a\ value\ that\ is\ anything"{}},}
\DoxyCodeLine{03952\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(matcher));}
\DoxyCodeLine{03953\ \}}
\DoxyCodeLine{03954\ }
\DoxyCodeLine{03955\ TEST(WhenDynamicCastToTest,\ Explain)\ \{}
\DoxyCodeLine{03956\ \ \ Matcher<Base*>\ matcher\ =\ WhenDynamicCastTo<Derived*>(Pointee(\_));}
\DoxyCodeLine{03957\ \ \ Base*\ null\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03958\ \ \ EXPECT\_THAT(Explain(matcher,\ null),\ HasSubstr(\textcolor{stringliteral}{"{}NULL"{}}));}
\DoxyCodeLine{03959\ \ \ Derived\ derived;}
\DoxyCodeLine{03960\ \ \ EXPECT\_TRUE(matcher.Matches(\&derived));}
\DoxyCodeLine{03961\ \ \ EXPECT\_THAT(Explain(matcher,\ \&derived),\ HasSubstr(\textcolor{stringliteral}{"{}which\ points\ to\ "{}}));}
\DoxyCodeLine{03962\ }
\DoxyCodeLine{03963\ \ \ \textcolor{comment}{//\ With\ references,\ the\ matcher\ itself\ can\ fail.\ Test\ for\ that\ one.}}
\DoxyCodeLine{03964\ \ \ Matcher<const\ Base\&>\ ref\_matcher\ =\ WhenDynamicCastTo<const\ OtherDerived\&>(\_);}
\DoxyCodeLine{03965\ \ \ EXPECT\_THAT(Explain(ref\_matcher,\ derived),}
\DoxyCodeLine{03966\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ HasSubstr(\textcolor{stringliteral}{"{}which\ cannot\ be\ dynamic\_cast"{}}));}
\DoxyCodeLine{03967\ \}}
\DoxyCodeLine{03968\ }
\DoxyCodeLine{03969\ TEST(WhenDynamicCastToTest,\ GoodReference)\ \{}
\DoxyCodeLine{03970\ \ \ Derived\ derived;}
\DoxyCodeLine{03971\ \ \ derived.i\ =\ 4;}
\DoxyCodeLine{03972\ \ \ Base\&\ as\_base\_ref\ =\ derived;}
\DoxyCodeLine{03973\ \ \ EXPECT\_THAT(as\_base\_ref,\ WhenDynamicCastTo<const\ Derived\&>(FieldIIs(4)));}
\DoxyCodeLine{03974\ \ \ EXPECT\_THAT(as\_base\_ref,\ WhenDynamicCastTo<const\ Derived\&>(Not(FieldIIs(5))));}
\DoxyCodeLine{03975\ \}}
\DoxyCodeLine{03976\ }
\DoxyCodeLine{03977\ TEST(WhenDynamicCastToTest,\ BadReference)\ \{}
\DoxyCodeLine{03978\ \ \ Derived\ derived;}
\DoxyCodeLine{03979\ \ \ Base\&\ as\_base\_ref\ =\ derived;}
\DoxyCodeLine{03980\ \ \ EXPECT\_THAT(as\_base\_ref,\ Not(WhenDynamicCastTo<const\ OtherDerived\&>(\_)));}
\DoxyCodeLine{03981\ \}}
\DoxyCodeLine{03982\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_RTTI}}
\DoxyCodeLine{03983\ }
\DoxyCodeLine{03984\ \textcolor{comment}{//\ Minimal\ const-\/propagating\ pointer.}}
\DoxyCodeLine{03985\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{03986\ \textcolor{keyword}{class\ }ConstPropagatingPtr\ \{}
\DoxyCodeLine{03987\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{03988\ \ \ \textcolor{keyword}{typedef}\ T\ element\_type;}
\DoxyCodeLine{03989\ }
\DoxyCodeLine{03990\ \ \ ConstPropagatingPtr()\ :\ val\_()\ \{\}}
\DoxyCodeLine{03991\ \ \ \textcolor{keyword}{explicit}\ ConstPropagatingPtr(T*\ t)\ :\ val\_(t)\ \{\}}
\DoxyCodeLine{03992\ \ \ ConstPropagatingPtr(\textcolor{keyword}{const}\ ConstPropagatingPtr\&\ other)\ :\ val\_(other.val\_)\ \{\}}
\DoxyCodeLine{03993\ }
\DoxyCodeLine{03994\ \ \ T*\ get()\ \{\ \textcolor{keywordflow}{return}\ val\_;\ \}}
\DoxyCodeLine{03995\ \ \ T\&\ operator*()\ \{\ \textcolor{keywordflow}{return}\ *val\_;\ \}}
\DoxyCodeLine{03996\ \ \ \textcolor{comment}{//\ Most\ smart\ pointers\ return\ non-\/const\ T*\ and\ T\&\ from\ the\ next\ methods.}}
\DoxyCodeLine{03997\ \ \ \textcolor{keyword}{const}\ T*\ get()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ val\_;\ \}}
\DoxyCodeLine{03998\ \ \ \textcolor{keyword}{const}\ T\&\ operator*()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ *val\_;\ \}}
\DoxyCodeLine{03999\ }
\DoxyCodeLine{04000\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04001\ \ \ T*\ val\_;}
\DoxyCodeLine{04002\ \};}
\DoxyCodeLine{04003\ }
\DoxyCodeLine{04004\ TEST(PointeeTest,\ WorksWithConstPropagatingPointers)\ \{}
\DoxyCodeLine{04005\ \ \ \textcolor{keyword}{const}\ Matcher<\ ConstPropagatingPtr<int>\ >\ m\ =\ Pointee(Lt(5));}
\DoxyCodeLine{04006\ \ \ \textcolor{keywordtype}{int}\ three\ =\ 3;}
\DoxyCodeLine{04007\ \ \ \textcolor{keyword}{const}\ ConstPropagatingPtr<int>\ co(\&three);}
\DoxyCodeLine{04008\ \ \ ConstPropagatingPtr<int>\ o(\&three);}
\DoxyCodeLine{04009\ \ \ EXPECT\_TRUE(m.Matches(o));}
\DoxyCodeLine{04010\ \ \ EXPECT\_TRUE(m.Matches(co));}
\DoxyCodeLine{04011\ \ \ *o\ =\ 6;}
\DoxyCodeLine{04012\ \ \ EXPECT\_FALSE(m.Matches(o));}
\DoxyCodeLine{04013\ \ \ EXPECT\_FALSE(m.Matches(ConstPropagatingPtr<int>()));}
\DoxyCodeLine{04014\ \}}
\DoxyCodeLine{04015\ }
\DoxyCodeLine{04016\ TEST(PointeeTest,\ NeverMatchesNull)\ \{}
\DoxyCodeLine{04017\ \ \ \textcolor{keyword}{const}\ Matcher<const\ char*>\ m\ =\ Pointee(\_);}
\DoxyCodeLine{04018\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{04019\ \}}
\DoxyCodeLine{04020\ }
\DoxyCodeLine{04021\ \textcolor{comment}{//\ Tests\ that\ we\ can\ write\ Pointee(value)\ instead\ of\ Pointee(Eq(value)).}}
\DoxyCodeLine{04022\ TEST(PointeeTest,\ MatchesAgainstAValue)\ \{}
\DoxyCodeLine{04023\ \ \ \textcolor{keyword}{const}\ Matcher<int*>\ m\ =\ Pointee(5);}
\DoxyCodeLine{04024\ }
\DoxyCodeLine{04025\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 5;}
\DoxyCodeLine{04026\ \ \ EXPECT\_TRUE(m.Matches(\&n));}
\DoxyCodeLine{04027\ \ \ n\ =\ -\/1;}
\DoxyCodeLine{04028\ \ \ EXPECT\_FALSE(m.Matches(\&n));}
\DoxyCodeLine{04029\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{04030\ \}}
\DoxyCodeLine{04031\ }
\DoxyCodeLine{04032\ TEST(PointeeTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{04033\ \ \ \textcolor{keyword}{const}\ Matcher<int*>\ m\ =\ Pointee(Gt(3));}
\DoxyCodeLine{04034\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}points\ to\ a\ value\ that\ is\ >\ 3"{}},\ Describe(m));}
\DoxyCodeLine{04035\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}does\ not\ point\ to\ a\ value\ that\ is\ >\ 3"{}},}
\DoxyCodeLine{04036\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{04037\ \}}
\DoxyCodeLine{04038\ }
\DoxyCodeLine{04039\ TEST(PointeeTest,\ CanExplainMatchResult)\ \{}
\DoxyCodeLine{04040\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::string*>\ m\ =\ Pointee(StartsWith(\textcolor{stringliteral}{"{}Hi"{}}));}
\DoxyCodeLine{04041\ }
\DoxyCodeLine{04042\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const\ }std::string*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{04043\ }
\DoxyCodeLine{04044\ \ \ \textcolor{keyword}{const}\ Matcher<long*>\ m2\ =\ Pointee(GreaterThan(1));\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{04045\ \ \ \textcolor{keywordtype}{long}\ n\ =\ 3;\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{04046\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ points\ to\ 3"{}}\ +\ OfType(\textcolor{stringliteral}{"{}long"{}})\ +\ \textcolor{stringliteral}{"{},\ which\ is\ 2\ more\ than\ 1"{}},}
\DoxyCodeLine{04047\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m2,\ \&n));}
\DoxyCodeLine{04048\ \}}
\DoxyCodeLine{04049\ }
\DoxyCodeLine{04050\ TEST(PointeeTest,\ AlwaysExplainsPointee)\ \{}
\DoxyCodeLine{04051\ \ \ \textcolor{keyword}{const}\ Matcher<int*>\ m\ =\ Pointee(0);}
\DoxyCodeLine{04052\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 42;}
\DoxyCodeLine{04053\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ points\ to\ 42"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),\ Explain(m,\ \&n));}
\DoxyCodeLine{04054\ \}}
\DoxyCodeLine{04055\ }
\DoxyCodeLine{04056\ \textcolor{comment}{//\ An\ uncopyable\ class.}}
\DoxyCodeLine{04057\ \textcolor{keyword}{class\ }Uncopyable\ \{}
\DoxyCodeLine{04058\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04059\ \ \ Uncopyable()\ :\ value\_(-\/1)\ \{\}}
\DoxyCodeLine{04060\ \ \ \textcolor{keyword}{explicit}\ Uncopyable(\textcolor{keywordtype}{int}\ a\_value)\ :\ value\_(a\_value)\ \{\}}
\DoxyCodeLine{04061\ }
\DoxyCodeLine{04062\ \ \ \textcolor{keywordtype}{int}\ value()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ value\_;\ \}}
\DoxyCodeLine{04063\ \ \ \textcolor{keywordtype}{void}\ set\_value(\textcolor{keywordtype}{int}\ i)\ \{\ value\_\ =\ i;\ \}}
\DoxyCodeLine{04064\ }
\DoxyCodeLine{04065\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04066\ \ \ \textcolor{keywordtype}{int}\ value\_;}
\DoxyCodeLine{04067\ \ \ GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(Uncopyable);}
\DoxyCodeLine{04068\ \};}
\DoxyCodeLine{04069\ }
\DoxyCodeLine{04070\ \textcolor{comment}{//\ Returns\ true\ if\ and\ only\ if\ x.value()\ is\ positive.}}
\DoxyCodeLine{04071\ \textcolor{keywordtype}{bool}\ ValueIsPositive(\textcolor{keyword}{const}\ Uncopyable\&\ x)\ \{\ \textcolor{keywordflow}{return}\ x.value()\ >\ 0;\ \}}
\DoxyCodeLine{04072\ }
\DoxyCodeLine{04073\ MATCHER\_P(UncopyableIs,\ inner\_matcher,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{04074\ \ \ \textcolor{keywordflow}{return}\ ExplainMatchResult(inner\_matcher,\ arg.value(),\ result\_listener);}
\DoxyCodeLine{04075\ \}}
\DoxyCodeLine{04076\ }
\DoxyCodeLine{04077\ \textcolor{comment}{//\ A\ user-\/defined\ struct\ for\ testing\ Field().}}
\DoxyCodeLine{04078\ \textcolor{keyword}{struct\ }AStruct\ \{}
\DoxyCodeLine{04079\ \ \ AStruct()\ :\ x(0),\ y(1.0),\ z(5),\ p(nullptr)\ \{\}}
\DoxyCodeLine{04080\ \ \ AStruct(\textcolor{keyword}{const}\ AStruct\&\ rhs)}
\DoxyCodeLine{04081\ \ \ \ \ \ \ :\ x(rhs.x),\ y(rhs.y),\ z(rhs.z.value()),\ p(rhs.p)\ \{\}}
\DoxyCodeLine{04082\ }
\DoxyCodeLine{04083\ \ \ \textcolor{keywordtype}{int}\ x;\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ A\ non-\/const\ field.}}
\DoxyCodeLine{04084\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ y;\ \ \textcolor{comment}{//\ A\ const\ field.}}
\DoxyCodeLine{04085\ \ \ Uncopyable\ z;\ \ \ \ \textcolor{comment}{//\ An\ uncopyable\ field.}}
\DoxyCodeLine{04086\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ p;\ \ \ \textcolor{comment}{//\ A\ pointer\ field.}}
\DoxyCodeLine{04087\ \};}
\DoxyCodeLine{04088\ }
\DoxyCodeLine{04089\ \textcolor{comment}{//\ A\ derived\ struct\ for\ testing\ Field().}}
\DoxyCodeLine{04090\ \textcolor{keyword}{struct\ }DerivedStruct\ :\ \textcolor{keyword}{public}\ AStruct\ \{}
\DoxyCodeLine{04091\ \ \ \textcolor{keywordtype}{char}\ ch;}
\DoxyCodeLine{04092\ \};}
\DoxyCodeLine{04093\ }
\DoxyCodeLine{04094\ \textcolor{comment}{//\ Tests\ that\ Field(\&Foo::field,\ ...)\ works\ when\ field\ is\ non-\/const.}}
\DoxyCodeLine{04095\ TEST(FieldTest,\ WorksForNonConstField)\ \{}
\DoxyCodeLine{04096\ \ \ Matcher<AStruct>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04097\ \ \ Matcher<AStruct>\ m\_with\_name\ =\ Field(\textcolor{stringliteral}{"{}x"{}},\ \&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04098\ }
\DoxyCodeLine{04099\ \ \ AStruct\ a;}
\DoxyCodeLine{04100\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04101\ \ \ EXPECT\_TRUE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04102\ \ \ a.x\ =\ -\/1;}
\DoxyCodeLine{04103\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04104\ \ \ EXPECT\_FALSE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04105\ \}}
\DoxyCodeLine{04106\ }
\DoxyCodeLine{04107\ \textcolor{comment}{//\ Tests\ that\ Field(\&Foo::field,\ ...)\ works\ when\ field\ is\ const.}}
\DoxyCodeLine{04108\ TEST(FieldTest,\ WorksForConstField)\ \{}
\DoxyCodeLine{04109\ \ \ AStruct\ a;}
\DoxyCodeLine{04110\ }
\DoxyCodeLine{04111\ \ \ Matcher<AStruct>\ m\ =\ Field(\&AStruct::y,\ Ge(0.0));}
\DoxyCodeLine{04112\ \ \ Matcher<AStruct>\ m\_with\_name\ =\ Field(\textcolor{stringliteral}{"{}y"{}},\ \&AStruct::y,\ Ge(0.0));}
\DoxyCodeLine{04113\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04114\ \ \ EXPECT\_TRUE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04115\ \ \ m\ =\ Field(\&AStruct::y,\ Le(0.0));}
\DoxyCodeLine{04116\ \ \ m\_with\_name\ =\ Field(\textcolor{stringliteral}{"{}y"{}},\ \&AStruct::y,\ Le(0.0));}
\DoxyCodeLine{04117\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04118\ \ \ EXPECT\_FALSE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04119\ \}}
\DoxyCodeLine{04120\ }
\DoxyCodeLine{04121\ \textcolor{comment}{//\ Tests\ that\ Field(\&Foo::field,\ ...)\ works\ when\ field\ is\ not\ copyable.}}
\DoxyCodeLine{04122\ TEST(FieldTest,\ WorksForUncopyableField)\ \{}
\DoxyCodeLine{04123\ \ \ AStruct\ a;}
\DoxyCodeLine{04124\ }
\DoxyCodeLine{04125\ \ \ Matcher<AStruct>\ m\ =\ Field(\&AStruct::z,\ Truly(ValueIsPositive));}
\DoxyCodeLine{04126\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04127\ \ \ m\ =\ Field(\&AStruct::z,\ Not(Truly(ValueIsPositive)));}
\DoxyCodeLine{04128\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04129\ \}}
\DoxyCodeLine{04130\ }
\DoxyCodeLine{04131\ \textcolor{comment}{//\ Tests\ that\ Field(\&Foo::field,\ ...)\ works\ when\ field\ is\ a\ pointer.}}
\DoxyCodeLine{04132\ TEST(FieldTest,\ WorksForPointerField)\ \{}
\DoxyCodeLine{04133\ \ \ \textcolor{comment}{//\ Matching\ against\ NULL.}}
\DoxyCodeLine{04134\ \ \ Matcher<AStruct>\ m\ =\ Field(\&AStruct::p,\ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const\ }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{04135\ \ \ AStruct\ a;}
\DoxyCodeLine{04136\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04137\ \ \ a.p\ =\ \textcolor{stringliteral}{"{}hi"{}};}
\DoxyCodeLine{04138\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04139\ }
\DoxyCodeLine{04140\ \ \ \textcolor{comment}{//\ Matching\ a\ pointer\ that\ is\ not\ NULL.}}
\DoxyCodeLine{04141\ \ \ m\ =\ Field(\&AStruct::p,\ StartsWith(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{04142\ \ \ a.p\ =\ \textcolor{stringliteral}{"{}hill"{}};}
\DoxyCodeLine{04143\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04144\ \ \ a.p\ =\ \textcolor{stringliteral}{"{}hole"{}};}
\DoxyCodeLine{04145\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04146\ \}}
\DoxyCodeLine{04147\ }
\DoxyCodeLine{04148\ \textcolor{comment}{//\ Tests\ that\ Field()\ works\ when\ the\ object\ is\ passed\ by\ reference.}}
\DoxyCodeLine{04149\ TEST(FieldTest,\ WorksForByRefArgument)\ \{}
\DoxyCodeLine{04150\ \ \ Matcher<const\ AStruct\&>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04151\ }
\DoxyCodeLine{04152\ \ \ AStruct\ a;}
\DoxyCodeLine{04153\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04154\ \ \ a.x\ =\ -\/1;}
\DoxyCodeLine{04155\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04156\ \}}
\DoxyCodeLine{04157\ }
\DoxyCodeLine{04158\ \textcolor{comment}{//\ Tests\ that\ Field(\&Foo::field,\ ...)\ works\ when\ the\ argument's\ type}}
\DoxyCodeLine{04159\ \textcolor{comment}{//\ is\ a\ sub-\/type\ of\ Foo.}}
\DoxyCodeLine{04160\ TEST(FieldTest,\ WorksForArgumentOfSubType)\ \{}
\DoxyCodeLine{04161\ \ \ \textcolor{comment}{//\ Note\ that\ the\ matcher\ expects\ DerivedStruct\ but\ we\ say\ AStruct}}
\DoxyCodeLine{04162\ \ \ \textcolor{comment}{//\ inside\ Field().}}
\DoxyCodeLine{04163\ \ \ Matcher<const\ DerivedStruct\&>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04164\ }
\DoxyCodeLine{04165\ \ \ DerivedStruct\ d;}
\DoxyCodeLine{04166\ \ \ EXPECT\_TRUE(m.Matches(d));}
\DoxyCodeLine{04167\ \ \ d.x\ =\ -\/1;}
\DoxyCodeLine{04168\ \ \ EXPECT\_FALSE(m.Matches(d));}
\DoxyCodeLine{04169\ \}}
\DoxyCodeLine{04170\ }
\DoxyCodeLine{04171\ \textcolor{comment}{//\ Tests\ that\ Field(\&Foo::field,\ m)\ works\ when\ field's\ type\ and\ m's}}
\DoxyCodeLine{04172\ \textcolor{comment}{//\ argument\ type\ are\ compatible\ but\ not\ the\ same.}}
\DoxyCodeLine{04173\ TEST(FieldTest,\ WorksForCompatibleMatcherType)\ \{}
\DoxyCodeLine{04174\ \ \ \textcolor{comment}{//\ The\ field\ is\ an\ int,\ but\ the\ inner\ matcher\ expects\ a\ signed\ char.}}
\DoxyCodeLine{04175\ \ \ Matcher<const\ AStruct\&>\ m\ =\ Field(\&AStruct::x,}
\DoxyCodeLine{04176\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Matcher<signed\ char>(Ge(0)));}
\DoxyCodeLine{04177\ }
\DoxyCodeLine{04178\ \ \ AStruct\ a;}
\DoxyCodeLine{04179\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04180\ \ \ a.x\ =\ -\/1;}
\DoxyCodeLine{04181\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04182\ \}}
\DoxyCodeLine{04183\ }
\DoxyCodeLine{04184\ \textcolor{comment}{//\ Tests\ that\ Field()\ can\ describe\ itself.}}
\DoxyCodeLine{04185\ TEST(FieldTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{04186\ \ \ Matcher<const\ AStruct\&>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04187\ }
\DoxyCodeLine{04188\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ given\ field\ is\ >=\ 0"{}},\ Describe(m));}
\DoxyCodeLine{04189\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ given\ field\ isn't\ >=\ 0"{}},\ DescribeNegation(m));}
\DoxyCodeLine{04190\ \}}
\DoxyCodeLine{04191\ }
\DoxyCodeLine{04192\ TEST(FieldTest,\ CanDescribeSelfWithFieldName)\ \{}
\DoxyCodeLine{04193\ \ \ Matcher<const\ AStruct\&>\ m\ =\ Field(\textcolor{stringliteral}{"{}field\_name"{}},\ \&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04194\ }
\DoxyCodeLine{04195\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ field\ \`{}field\_name`\ is\ >=\ 0"{}},\ Describe(m));}
\DoxyCodeLine{04196\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ field\ \`{}field\_name`\ isn't\ >=\ 0"{}},}
\DoxyCodeLine{04197\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{04198\ \}}
\DoxyCodeLine{04199\ }
\DoxyCodeLine{04200\ \textcolor{comment}{//\ Tests\ that\ Field()\ can\ explain\ the\ match\ result.}}
\DoxyCodeLine{04201\ TEST(FieldTest,\ CanExplainMatchResult)\ \{}
\DoxyCodeLine{04202\ \ \ Matcher<const\ AStruct\&>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04203\ }
\DoxyCodeLine{04204\ \ \ AStruct\ a;}
\DoxyCodeLine{04205\ \ \ a.x\ =\ 1;}
\DoxyCodeLine{04206\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ given\ field\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),\ Explain(m,\ a));}
\DoxyCodeLine{04207\ }
\DoxyCodeLine{04208\ \ \ m\ =\ Field(\&AStruct::x,\ GreaterThan(0));}
\DoxyCodeLine{04209\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{04210\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ given\ field\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}})\ +\ \textcolor{stringliteral}{"{},\ which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{04211\ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{04212\ \}}
\DoxyCodeLine{04213\ }
\DoxyCodeLine{04214\ TEST(FieldTest,\ CanExplainMatchResultWithFieldName)\ \{}
\DoxyCodeLine{04215\ \ \ Matcher<const\ AStruct\&>\ m\ =\ Field(\textcolor{stringliteral}{"{}field\_name"{}},\ \&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04216\ }
\DoxyCodeLine{04217\ \ \ AStruct\ a;}
\DoxyCodeLine{04218\ \ \ a.x\ =\ 1;}
\DoxyCodeLine{04219\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ field\ \`{}field\_name`\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),\ Explain(m,\ a));}
\DoxyCodeLine{04220\ }
\DoxyCodeLine{04221\ \ \ m\ =\ Field(\textcolor{stringliteral}{"{}field\_name"{}},\ \&AStruct::x,\ GreaterThan(0));}
\DoxyCodeLine{04222\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ field\ \`{}field\_name`\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}})\ +}
\DoxyCodeLine{04223\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{04224\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{04225\ \}}
\DoxyCodeLine{04226\ }
\DoxyCodeLine{04227\ \textcolor{comment}{//\ Tests\ that\ Field()\ works\ when\ the\ argument\ is\ a\ pointer\ to\ const.}}
\DoxyCodeLine{04228\ TEST(FieldForPointerTest,\ WorksForPointerToConst)\ \{}
\DoxyCodeLine{04229\ \ \ Matcher<const\ AStruct*>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04230\ }
\DoxyCodeLine{04231\ \ \ AStruct\ a;}
\DoxyCodeLine{04232\ \ \ EXPECT\_TRUE(m.Matches(\&a));}
\DoxyCodeLine{04233\ \ \ a.x\ =\ -\/1;}
\DoxyCodeLine{04234\ \ \ EXPECT\_FALSE(m.Matches(\&a));}
\DoxyCodeLine{04235\ \}}
\DoxyCodeLine{04236\ }
\DoxyCodeLine{04237\ \textcolor{comment}{//\ Tests\ that\ Field()\ works\ when\ the\ argument\ is\ a\ pointer\ to\ non-\/const.}}
\DoxyCodeLine{04238\ TEST(FieldForPointerTest,\ WorksForPointerToNonConst)\ \{}
\DoxyCodeLine{04239\ \ \ Matcher<AStruct*>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04240\ }
\DoxyCodeLine{04241\ \ \ AStruct\ a;}
\DoxyCodeLine{04242\ \ \ EXPECT\_TRUE(m.Matches(\&a));}
\DoxyCodeLine{04243\ \ \ a.x\ =\ -\/1;}
\DoxyCodeLine{04244\ \ \ EXPECT\_FALSE(m.Matches(\&a));}
\DoxyCodeLine{04245\ \}}
\DoxyCodeLine{04246\ }
\DoxyCodeLine{04247\ \textcolor{comment}{//\ Tests\ that\ Field()\ works\ when\ the\ argument\ is\ a\ reference\ to\ a\ const\ pointer.}}
\DoxyCodeLine{04248\ TEST(FieldForPointerTest,\ WorksForReferenceToConstPointer)\ \{}
\DoxyCodeLine{04249\ \ \ Matcher<AStruct*\ const\&>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04250\ }
\DoxyCodeLine{04251\ \ \ AStruct\ a;}
\DoxyCodeLine{04252\ \ \ EXPECT\_TRUE(m.Matches(\&a));}
\DoxyCodeLine{04253\ \ \ a.x\ =\ -\/1;}
\DoxyCodeLine{04254\ \ \ EXPECT\_FALSE(m.Matches(\&a));}
\DoxyCodeLine{04255\ \}}
\DoxyCodeLine{04256\ }
\DoxyCodeLine{04257\ \textcolor{comment}{//\ Tests\ that\ Field()\ does\ not\ match\ the\ NULL\ pointer.}}
\DoxyCodeLine{04258\ TEST(FieldForPointerTest,\ DoesNotMatchNull)\ \{}
\DoxyCodeLine{04259\ \ \ Matcher<const\ AStruct*>\ m\ =\ Field(\&AStruct::x,\ \_);}
\DoxyCodeLine{04260\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{04261\ \}}
\DoxyCodeLine{04262\ }
\DoxyCodeLine{04263\ \textcolor{comment}{//\ Tests\ that\ Field(\&Foo::field,\ ...)\ works\ when\ the\ argument's\ type}}
\DoxyCodeLine{04264\ \textcolor{comment}{//\ is\ a\ sub-\/type\ of\ const\ Foo*.}}
\DoxyCodeLine{04265\ TEST(FieldForPointerTest,\ WorksForArgumentOfSubType)\ \{}
\DoxyCodeLine{04266\ \ \ \textcolor{comment}{//\ Note\ that\ the\ matcher\ expects\ DerivedStruct\ but\ we\ say\ AStruct}}
\DoxyCodeLine{04267\ \ \ \textcolor{comment}{//\ inside\ Field().}}
\DoxyCodeLine{04268\ \ \ Matcher<DerivedStruct*>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04269\ }
\DoxyCodeLine{04270\ \ \ DerivedStruct\ d;}
\DoxyCodeLine{04271\ \ \ EXPECT\_TRUE(m.Matches(\&d));}
\DoxyCodeLine{04272\ \ \ d.x\ =\ -\/1;}
\DoxyCodeLine{04273\ \ \ EXPECT\_FALSE(m.Matches(\&d));}
\DoxyCodeLine{04274\ \}}
\DoxyCodeLine{04275\ }
\DoxyCodeLine{04276\ \textcolor{comment}{//\ Tests\ that\ Field()\ can\ describe\ itself\ when\ used\ to\ match\ a\ pointer.}}
\DoxyCodeLine{04277\ TEST(FieldForPointerTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{04278\ \ \ Matcher<const\ AStruct*>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04279\ }
\DoxyCodeLine{04280\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ given\ field\ is\ >=\ 0"{}},\ Describe(m));}
\DoxyCodeLine{04281\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ given\ field\ isn't\ >=\ 0"{}},\ DescribeNegation(m));}
\DoxyCodeLine{04282\ \}}
\DoxyCodeLine{04283\ }
\DoxyCodeLine{04284\ TEST(FieldForPointerTest,\ CanDescribeSelfWithFieldName)\ \{}
\DoxyCodeLine{04285\ \ \ Matcher<const\ AStruct*>\ m\ =\ Field(\textcolor{stringliteral}{"{}field\_name"{}},\ \&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04286\ }
\DoxyCodeLine{04287\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ field\ \`{}field\_name`\ is\ >=\ 0"{}},\ Describe(m));}
\DoxyCodeLine{04288\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ field\ \`{}field\_name`\ isn't\ >=\ 0"{}},}
\DoxyCodeLine{04289\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{04290\ \}}
\DoxyCodeLine{04291\ }
\DoxyCodeLine{04292\ \textcolor{comment}{//\ Tests\ that\ Field()\ can\ explain\ the\ result\ of\ matching\ a\ pointer.}}
\DoxyCodeLine{04293\ TEST(FieldForPointerTest,\ CanExplainMatchResult)\ \{}
\DoxyCodeLine{04294\ \ \ Matcher<const\ AStruct*>\ m\ =\ Field(\&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04295\ }
\DoxyCodeLine{04296\ \ \ AStruct\ a;}
\DoxyCodeLine{04297\ \ \ a.x\ =\ 1;}
\DoxyCodeLine{04298\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const\ }AStruct*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{04299\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ whose\ given\ field\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),}
\DoxyCodeLine{04300\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ \&a));}
\DoxyCodeLine{04301\ }
\DoxyCodeLine{04302\ \ \ m\ =\ Field(\&AStruct::x,\ GreaterThan(0));}
\DoxyCodeLine{04303\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ whose\ given\ field\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}})\ +}
\DoxyCodeLine{04304\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ which\ is\ 1\ more\ than\ 0"{}},\ Explain(m,\ \&a));}
\DoxyCodeLine{04305\ \}}
\DoxyCodeLine{04306\ }
\DoxyCodeLine{04307\ TEST(FieldForPointerTest,\ CanExplainMatchResultWithFieldName)\ \{}
\DoxyCodeLine{04308\ \ \ Matcher<const\ AStruct*>\ m\ =\ Field(\textcolor{stringliteral}{"{}field\_name"{}},\ \&AStruct::x,\ Ge(0));}
\DoxyCodeLine{04309\ }
\DoxyCodeLine{04310\ \ \ AStruct\ a;}
\DoxyCodeLine{04311\ \ \ a.x\ =\ 1;}
\DoxyCodeLine{04312\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const\ }AStruct*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{04313\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{04314\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ whose\ field\ \`{}field\_name`\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),}
\DoxyCodeLine{04315\ \ \ \ \ \ \ Explain(m,\ \&a));}
\DoxyCodeLine{04316\ }
\DoxyCodeLine{04317\ \ \ m\ =\ Field(\textcolor{stringliteral}{"{}field\_name"{}},\ \&AStruct::x,\ GreaterThan(0));}
\DoxyCodeLine{04318\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ whose\ field\ \`{}field\_name`\ is\ 1"{}}\ +}
\DoxyCodeLine{04319\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OfType(\textcolor{stringliteral}{"{}int"{}})\ +\ \textcolor{stringliteral}{"{},\ which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{04320\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ \&a));}
\DoxyCodeLine{04321\ \}}
\DoxyCodeLine{04322\ }
\DoxyCodeLine{04323\ \textcolor{comment}{//\ A\ user-\/defined\ class\ for\ testing\ Property().}}
\DoxyCodeLine{04324\ \textcolor{keyword}{class\ }AClass\ \{}
\DoxyCodeLine{04325\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04326\ \ \ AClass()\ :\ n\_(0)\ \{\}}
\DoxyCodeLine{04327\ }
\DoxyCodeLine{04328\ \ \ \textcolor{comment}{//\ A\ getter\ that\ returns\ a\ non-\/reference.}}
\DoxyCodeLine{04329\ \ \ \textcolor{keywordtype}{int}\ n()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ n\_;\ \}}
\DoxyCodeLine{04330\ }
\DoxyCodeLine{04331\ \ \ \textcolor{keywordtype}{void}\ set\_n(\textcolor{keywordtype}{int}\ new\_n)\ \{\ n\_\ =\ new\_n;\ \}}
\DoxyCodeLine{04332\ }
\DoxyCodeLine{04333\ \ \ \textcolor{comment}{//\ A\ getter\ that\ returns\ a\ reference\ to\ const.}}
\DoxyCodeLine{04334\ \ \ \textcolor{keyword}{const}\ std::string\&\ s()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ s\_;\ \}}
\DoxyCodeLine{04335\ }
\DoxyCodeLine{04336\ \ \ \textcolor{keyword}{const}\ std::string\&\ s\_ref()\ const\ \&\ \{\ \textcolor{keywordflow}{return}\ s\_;\ \}}
\DoxyCodeLine{04337\ }
\DoxyCodeLine{04338\ \ \ \textcolor{keywordtype}{void}\ set\_s(\textcolor{keyword}{const}\ std::string\&\ new\_s)\ \{\ s\_\ =\ new\_s;\ \}}
\DoxyCodeLine{04339\ }
\DoxyCodeLine{04340\ \ \ \textcolor{comment}{//\ A\ getter\ that\ returns\ a\ reference\ to\ non-\/const.}}
\DoxyCodeLine{04341\ \ \ \textcolor{keywordtype}{double}\&\ x()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ x\_;\ \}}
\DoxyCodeLine{04342\ }
\DoxyCodeLine{04343\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04344\ \ \ \textcolor{keywordtype}{int}\ n\_;}
\DoxyCodeLine{04345\ \ \ std::string\ s\_;}
\DoxyCodeLine{04346\ }
\DoxyCodeLine{04347\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{double}\ x\_;}
\DoxyCodeLine{04348\ \};}
\DoxyCodeLine{04349\ }
\DoxyCodeLine{04350\ \textcolor{keywordtype}{double}\ AClass::x\_\ =\ 0.0;}
\DoxyCodeLine{04351\ }
\DoxyCodeLine{04352\ \textcolor{comment}{//\ A\ derived\ class\ for\ testing\ Property().}}
\DoxyCodeLine{04353\ \textcolor{keyword}{class\ }DerivedClass\ :\ \textcolor{keyword}{public}\ AClass\ \{}
\DoxyCodeLine{04354\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04355\ \ \ \textcolor{keywordtype}{int}\ k()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ k\_;\ \}}
\DoxyCodeLine{04356\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04357\ \ \ \textcolor{keywordtype}{int}\ k\_;}
\DoxyCodeLine{04358\ \};}
\DoxyCodeLine{04359\ }
\DoxyCodeLine{04360\ \textcolor{comment}{//\ Tests\ that\ Property(\&Foo::property,\ ...)\ works\ when\ property()}}
\DoxyCodeLine{04361\ \textcolor{comment}{//\ returns\ a\ non-\/reference.}}
\DoxyCodeLine{04362\ TEST(PropertyTest,\ WorksForNonReferenceProperty)\ \{}
\DoxyCodeLine{04363\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\&AClass::n,\ Ge(0));}
\DoxyCodeLine{04364\ \ \ Matcher<const\ AClass\&>\ m\_with\_name\ =\ Property(\textcolor{stringliteral}{"{}n"{}},\ \&AClass::n,\ Ge(0));}
\DoxyCodeLine{04365\ }
\DoxyCodeLine{04366\ \ \ AClass\ a;}
\DoxyCodeLine{04367\ \ \ a.set\_n(1);}
\DoxyCodeLine{04368\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04369\ \ \ EXPECT\_TRUE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04370\ }
\DoxyCodeLine{04371\ \ \ a.set\_n(-\/1);}
\DoxyCodeLine{04372\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04373\ \ \ EXPECT\_FALSE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04374\ \}}
\DoxyCodeLine{04375\ }
\DoxyCodeLine{04376\ \textcolor{comment}{//\ Tests\ that\ Property(\&Foo::property,\ ...)\ works\ when\ property()}}
\DoxyCodeLine{04377\ \textcolor{comment}{//\ returns\ a\ reference\ to\ const.}}
\DoxyCodeLine{04378\ TEST(PropertyTest,\ WorksForReferenceToConstProperty)\ \{}
\DoxyCodeLine{04379\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\&AClass::s,\ StartsWith(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{04380\ \ \ Matcher<const\ AClass\&>\ m\_with\_name\ =}
\DoxyCodeLine{04381\ \ \ \ \ \ \ Property(\textcolor{stringliteral}{"{}s"{}},\ \&AClass::s,\ StartsWith(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{04382\ }
\DoxyCodeLine{04383\ \ \ AClass\ a;}
\DoxyCodeLine{04384\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hill"{}});}
\DoxyCodeLine{04385\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04386\ \ \ EXPECT\_TRUE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04387\ }
\DoxyCodeLine{04388\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hole"{}});}
\DoxyCodeLine{04389\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04390\ \ \ EXPECT\_FALSE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04391\ \}}
\DoxyCodeLine{04392\ }
\DoxyCodeLine{04393\ \textcolor{comment}{//\ Tests\ that\ Property(\&Foo::property,\ ...)\ works\ when\ property()\ is}}
\DoxyCodeLine{04394\ \textcolor{comment}{//\ ref-\/qualified.}}
\DoxyCodeLine{04395\ TEST(PropertyTest,\ WorksForRefQualifiedProperty)\ \{}
\DoxyCodeLine{04396\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\&AClass::s\_ref,\ StartsWith(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{04397\ \ \ Matcher<const\ AClass\&>\ m\_with\_name\ =}
\DoxyCodeLine{04398\ \ \ \ \ \ \ Property(\textcolor{stringliteral}{"{}s"{}},\ \&AClass::s\_ref,\ StartsWith(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{04399\ }
\DoxyCodeLine{04400\ \ \ AClass\ a;}
\DoxyCodeLine{04401\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hill"{}});}
\DoxyCodeLine{04402\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04403\ \ \ EXPECT\_TRUE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04404\ }
\DoxyCodeLine{04405\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hole"{}});}
\DoxyCodeLine{04406\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04407\ \ \ EXPECT\_FALSE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04408\ \}}
\DoxyCodeLine{04409\ }
\DoxyCodeLine{04410\ \textcolor{comment}{//\ Tests\ that\ Property(\&Foo::property,\ ...)\ works\ when\ property()}}
\DoxyCodeLine{04411\ \textcolor{comment}{//\ returns\ a\ reference\ to\ non-\/const.}}
\DoxyCodeLine{04412\ TEST(PropertyTest,\ WorksForReferenceToNonConstProperty)\ \{}
\DoxyCodeLine{04413\ \ \ \textcolor{keywordtype}{double}\ x\ =\ 0.0;}
\DoxyCodeLine{04414\ \ \ AClass\ a;}
\DoxyCodeLine{04415\ }
\DoxyCodeLine{04416\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\&AClass::x,\ Ref(x));}
\DoxyCodeLine{04417\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04418\ }
\DoxyCodeLine{04419\ \ \ m\ =\ Property(\&AClass::x,\ Not(Ref(x)));}
\DoxyCodeLine{04420\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04421\ \}}
\DoxyCodeLine{04422\ }
\DoxyCodeLine{04423\ \textcolor{comment}{//\ Tests\ that\ Property(\&Foo::property,\ ...)\ works\ when\ the\ argument\ is}}
\DoxyCodeLine{04424\ \textcolor{comment}{//\ passed\ by\ value.}}
\DoxyCodeLine{04425\ TEST(PropertyTest,\ WorksForByValueArgument)\ \{}
\DoxyCodeLine{04426\ \ \ Matcher<AClass>\ m\ =\ Property(\&AClass::s,\ StartsWith(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{04427\ }
\DoxyCodeLine{04428\ \ \ AClass\ a;}
\DoxyCodeLine{04429\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hill"{}});}
\DoxyCodeLine{04430\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04431\ }
\DoxyCodeLine{04432\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hole"{}});}
\DoxyCodeLine{04433\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04434\ \}}
\DoxyCodeLine{04435\ }
\DoxyCodeLine{04436\ \textcolor{comment}{//\ Tests\ that\ Property(\&Foo::property,\ ...)\ works\ when\ the\ argument's}}
\DoxyCodeLine{04437\ \textcolor{comment}{//\ type\ is\ a\ sub-\/type\ of\ Foo.}}
\DoxyCodeLine{04438\ TEST(PropertyTest,\ WorksForArgumentOfSubType)\ \{}
\DoxyCodeLine{04439\ \ \ \textcolor{comment}{//\ The\ matcher\ expects\ a\ DerivedClass,\ but\ inside\ the\ Property()\ we}}
\DoxyCodeLine{04440\ \ \ \textcolor{comment}{//\ say\ AClass.}}
\DoxyCodeLine{04441\ \ \ Matcher<const\ DerivedClass\&>\ m\ =\ Property(\&AClass::n,\ Ge(0));}
\DoxyCodeLine{04442\ }
\DoxyCodeLine{04443\ \ \ DerivedClass\ d;}
\DoxyCodeLine{04444\ \ \ d.set\_n(1);}
\DoxyCodeLine{04445\ \ \ EXPECT\_TRUE(m.Matches(d));}
\DoxyCodeLine{04446\ }
\DoxyCodeLine{04447\ \ \ d.set\_n(-\/1);}
\DoxyCodeLine{04448\ \ \ EXPECT\_FALSE(m.Matches(d));}
\DoxyCodeLine{04449\ \}}
\DoxyCodeLine{04450\ }
\DoxyCodeLine{04451\ \textcolor{comment}{//\ Tests\ that\ Property(\&Foo::property,\ m)\ works\ when\ property()'s\ type}}
\DoxyCodeLine{04452\ \textcolor{comment}{//\ and\ m's\ argument\ type\ are\ compatible\ but\ different.}}
\DoxyCodeLine{04453\ TEST(PropertyTest,\ WorksForCompatibleMatcherType)\ \{}
\DoxyCodeLine{04454\ \ \ \textcolor{comment}{//\ n()\ returns\ an\ int\ but\ the\ inner\ matcher\ expects\ a\ signed\ char.}}
\DoxyCodeLine{04455\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\&AClass::n,}
\DoxyCodeLine{04456\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Matcher<signed\ char>(Ge(0)));}
\DoxyCodeLine{04457\ }
\DoxyCodeLine{04458\ \ \ Matcher<const\ AClass\&>\ m\_with\_name\ =}
\DoxyCodeLine{04459\ \ \ \ \ \ \ Property(\textcolor{stringliteral}{"{}n"{}},\ \&AClass::n,\ Matcher<signed\ char>(Ge(0)));}
\DoxyCodeLine{04460\ }
\DoxyCodeLine{04461\ \ \ AClass\ a;}
\DoxyCodeLine{04462\ \ \ EXPECT\_TRUE(m.Matches(a));}
\DoxyCodeLine{04463\ \ \ EXPECT\_TRUE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04464\ \ \ a.set\_n(-\/1);}
\DoxyCodeLine{04465\ \ \ EXPECT\_FALSE(m.Matches(a));}
\DoxyCodeLine{04466\ \ \ EXPECT\_FALSE(m\_with\_name.Matches(a));}
\DoxyCodeLine{04467\ \}}
\DoxyCodeLine{04468\ }
\DoxyCodeLine{04469\ \textcolor{comment}{//\ Tests\ that\ Property()\ can\ describe\ itself.}}
\DoxyCodeLine{04470\ TEST(PropertyTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{04471\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\&AClass::n,\ Ge(0));}
\DoxyCodeLine{04472\ }
\DoxyCodeLine{04473\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ given\ property\ is\ >=\ 0"{}},\ Describe(m));}
\DoxyCodeLine{04474\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ given\ property\ isn't\ >=\ 0"{}},}
\DoxyCodeLine{04475\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{04476\ \}}
\DoxyCodeLine{04477\ }
\DoxyCodeLine{04478\ TEST(PropertyTest,\ CanDescribeSelfWithPropertyName)\ \{}
\DoxyCodeLine{04479\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\textcolor{stringliteral}{"{}fancy\_name"{}},\ \&AClass::n,\ Ge(0));}
\DoxyCodeLine{04480\ }
\DoxyCodeLine{04481\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ property\ \`{}fancy\_name`\ is\ >=\ 0"{}},\ Describe(m));}
\DoxyCodeLine{04482\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ property\ \`{}fancy\_name`\ isn't\ >=\ 0"{}},}
\DoxyCodeLine{04483\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{04484\ \}}
\DoxyCodeLine{04485\ }
\DoxyCodeLine{04486\ \textcolor{comment}{//\ Tests\ that\ Property()\ can\ explain\ the\ match\ result.}}
\DoxyCodeLine{04487\ TEST(PropertyTest,\ CanExplainMatchResult)\ \{}
\DoxyCodeLine{04488\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\&AClass::n,\ Ge(0));}
\DoxyCodeLine{04489\ }
\DoxyCodeLine{04490\ \ \ AClass\ a;}
\DoxyCodeLine{04491\ \ \ a.set\_n(1);}
\DoxyCodeLine{04492\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ given\ property\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),\ Explain(m,\ a));}
\DoxyCodeLine{04493\ }
\DoxyCodeLine{04494\ \ \ m\ =\ Property(\&AClass::n,\ GreaterThan(0));}
\DoxyCodeLine{04495\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{04496\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ given\ property\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}})\ +\ \textcolor{stringliteral}{"{},\ which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{04497\ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{04498\ \}}
\DoxyCodeLine{04499\ }
\DoxyCodeLine{04500\ TEST(PropertyTest,\ CanExplainMatchResultWithPropertyName)\ \{}
\DoxyCodeLine{04501\ \ \ Matcher<const\ AClass\&>\ m\ =\ Property(\textcolor{stringliteral}{"{}fancy\_name"{}},\ \&AClass::n,\ Ge(0));}
\DoxyCodeLine{04502\ }
\DoxyCodeLine{04503\ \ \ AClass\ a;}
\DoxyCodeLine{04504\ \ \ a.set\_n(1);}
\DoxyCodeLine{04505\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ property\ \`{}fancy\_name`\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),\ Explain(m,\ a));}
\DoxyCodeLine{04506\ }
\DoxyCodeLine{04507\ \ \ m\ =\ Property(\textcolor{stringliteral}{"{}fancy\_name"{}},\ \&AClass::n,\ GreaterThan(0));}
\DoxyCodeLine{04508\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ property\ \`{}fancy\_name`\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}})\ +}
\DoxyCodeLine{04509\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{04510\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{04511\ \}}
\DoxyCodeLine{04512\ }
\DoxyCodeLine{04513\ \textcolor{comment}{//\ Tests\ that\ Property()\ works\ when\ the\ argument\ is\ a\ pointer\ to\ const.}}
\DoxyCodeLine{04514\ TEST(PropertyForPointerTest,\ WorksForPointerToConst)\ \{}
\DoxyCodeLine{04515\ \ \ Matcher<const\ AClass*>\ m\ =\ Property(\&AClass::n,\ Ge(0));}
\DoxyCodeLine{04516\ }
\DoxyCodeLine{04517\ \ \ AClass\ a;}
\DoxyCodeLine{04518\ \ \ a.set\_n(1);}
\DoxyCodeLine{04519\ \ \ EXPECT\_TRUE(m.Matches(\&a));}
\DoxyCodeLine{04520\ }
\DoxyCodeLine{04521\ \ \ a.set\_n(-\/1);}
\DoxyCodeLine{04522\ \ \ EXPECT\_FALSE(m.Matches(\&a));}
\DoxyCodeLine{04523\ \}}
\DoxyCodeLine{04524\ }
\DoxyCodeLine{04525\ \textcolor{comment}{//\ Tests\ that\ Property()\ works\ when\ the\ argument\ is\ a\ pointer\ to\ non-\/const.}}
\DoxyCodeLine{04526\ TEST(PropertyForPointerTest,\ WorksForPointerToNonConst)\ \{}
\DoxyCodeLine{04527\ \ \ Matcher<AClass*>\ m\ =\ Property(\&AClass::s,\ StartsWith(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{04528\ }
\DoxyCodeLine{04529\ \ \ AClass\ a;}
\DoxyCodeLine{04530\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hill"{}});}
\DoxyCodeLine{04531\ \ \ EXPECT\_TRUE(m.Matches(\&a));}
\DoxyCodeLine{04532\ }
\DoxyCodeLine{04533\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hole"{}});}
\DoxyCodeLine{04534\ \ \ EXPECT\_FALSE(m.Matches(\&a));}
\DoxyCodeLine{04535\ \}}
\DoxyCodeLine{04536\ }
\DoxyCodeLine{04537\ \textcolor{comment}{//\ Tests\ that\ Property()\ works\ when\ the\ argument\ is\ a\ reference\ to\ a}}
\DoxyCodeLine{04538\ \textcolor{comment}{//\ const\ pointer.}}
\DoxyCodeLine{04539\ TEST(PropertyForPointerTest,\ WorksForReferenceToConstPointer)\ \{}
\DoxyCodeLine{04540\ \ \ Matcher<AClass*\ const\&>\ m\ =\ Property(\&AClass::s,\ StartsWith(\textcolor{stringliteral}{"{}hi"{}}));}
\DoxyCodeLine{04541\ }
\DoxyCodeLine{04542\ \ \ AClass\ a;}
\DoxyCodeLine{04543\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hill"{}});}
\DoxyCodeLine{04544\ \ \ EXPECT\_TRUE(m.Matches(\&a));}
\DoxyCodeLine{04545\ }
\DoxyCodeLine{04546\ \ \ a.set\_s(\textcolor{stringliteral}{"{}hole"{}});}
\DoxyCodeLine{04547\ \ \ EXPECT\_FALSE(m.Matches(\&a));}
\DoxyCodeLine{04548\ \}}
\DoxyCodeLine{04549\ }
\DoxyCodeLine{04550\ \textcolor{comment}{//\ Tests\ that\ Property()\ does\ not\ match\ the\ NULL\ pointer.}}
\DoxyCodeLine{04551\ TEST(PropertyForPointerTest,\ WorksForReferenceToNonConstProperty)\ \{}
\DoxyCodeLine{04552\ \ \ Matcher<const\ AClass*>\ m\ =\ Property(\&AClass::x,\ \_);}
\DoxyCodeLine{04553\ \ \ EXPECT\_FALSE(m.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{04554\ \}}
\DoxyCodeLine{04555\ }
\DoxyCodeLine{04556\ \textcolor{comment}{//\ Tests\ that\ Property(\&Foo::property,\ ...)\ works\ when\ the\ argument's}}
\DoxyCodeLine{04557\ \textcolor{comment}{//\ type\ is\ a\ sub-\/type\ of\ const\ Foo*.}}
\DoxyCodeLine{04558\ TEST(PropertyForPointerTest,\ WorksForArgumentOfSubType)\ \{}
\DoxyCodeLine{04559\ \ \ \textcolor{comment}{//\ The\ matcher\ expects\ a\ DerivedClass,\ but\ inside\ the\ Property()\ we}}
\DoxyCodeLine{04560\ \ \ \textcolor{comment}{//\ say\ AClass.}}
\DoxyCodeLine{04561\ \ \ Matcher<const\ DerivedClass*>\ m\ =\ Property(\&AClass::n,\ Ge(0));}
\DoxyCodeLine{04562\ }
\DoxyCodeLine{04563\ \ \ DerivedClass\ d;}
\DoxyCodeLine{04564\ \ \ d.set\_n(1);}
\DoxyCodeLine{04565\ \ \ EXPECT\_TRUE(m.Matches(\&d));}
\DoxyCodeLine{04566\ }
\DoxyCodeLine{04567\ \ \ d.set\_n(-\/1);}
\DoxyCodeLine{04568\ \ \ EXPECT\_FALSE(m.Matches(\&d));}
\DoxyCodeLine{04569\ \}}
\DoxyCodeLine{04570\ }
\DoxyCodeLine{04571\ \textcolor{comment}{//\ Tests\ that\ Property()\ can\ describe\ itself\ when\ used\ to\ match\ a\ pointer.}}
\DoxyCodeLine{04572\ TEST(PropertyForPointerTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{04573\ \ \ Matcher<const\ AClass*>\ m\ =\ Property(\&AClass::n,\ Ge(0));}
\DoxyCodeLine{04574\ }
\DoxyCodeLine{04575\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ given\ property\ is\ >=\ 0"{}},\ Describe(m));}
\DoxyCodeLine{04576\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ given\ property\ isn't\ >=\ 0"{}},}
\DoxyCodeLine{04577\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{04578\ \}}
\DoxyCodeLine{04579\ }
\DoxyCodeLine{04580\ TEST(PropertyForPointerTest,\ CanDescribeSelfWithPropertyDescription)\ \{}
\DoxyCodeLine{04581\ \ \ Matcher<const\ AClass*>\ m\ =\ Property(\textcolor{stringliteral}{"{}fancy\_name"{}},\ \&AClass::n,\ Ge(0));}
\DoxyCodeLine{04582\ }
\DoxyCodeLine{04583\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ property\ \`{}fancy\_name`\ is\ >=\ 0"{}},\ Describe(m));}
\DoxyCodeLine{04584\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ an\ object\ whose\ property\ \`{}fancy\_name`\ isn't\ >=\ 0"{}},}
\DoxyCodeLine{04585\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{04586\ \}}
\DoxyCodeLine{04587\ }
\DoxyCodeLine{04588\ \textcolor{comment}{//\ Tests\ that\ Property()\ can\ explain\ the\ result\ of\ matching\ a\ pointer.}}
\DoxyCodeLine{04589\ TEST(PropertyForPointerTest,\ CanExplainMatchResult)\ \{}
\DoxyCodeLine{04590\ \ \ Matcher<const\ AClass*>\ m\ =\ Property(\&AClass::n,\ Ge(0));}
\DoxyCodeLine{04591\ }
\DoxyCodeLine{04592\ \ \ AClass\ a;}
\DoxyCodeLine{04593\ \ \ a.set\_n(1);}
\DoxyCodeLine{04594\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const\ }AClass*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{04595\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{04596\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ whose\ given\ property\ is\ 1"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),}
\DoxyCodeLine{04597\ \ \ \ \ \ \ Explain(m,\ \&a));}
\DoxyCodeLine{04598\ }
\DoxyCodeLine{04599\ \ \ m\ =\ Property(\&AClass::n,\ GreaterThan(0));}
\DoxyCodeLine{04600\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ whose\ given\ property\ is\ 1"{}}\ +}
\DoxyCodeLine{04601\ \ \ \ \ \ \ \ \ \ \ \ \ OfType(\textcolor{stringliteral}{"{}int"{}})\ +\ \textcolor{stringliteral}{"{},\ which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{04602\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ \&a));}
\DoxyCodeLine{04603\ \}}
\DoxyCodeLine{04604\ }
\DoxyCodeLine{04605\ TEST(PropertyForPointerTest,\ CanExplainMatchResultWithPropertyName)\ \{}
\DoxyCodeLine{04606\ \ \ Matcher<const\ AClass*>\ m\ =\ Property(\textcolor{stringliteral}{"{}fancy\_name"{}},\ \&AClass::n,\ Ge(0));}
\DoxyCodeLine{04607\ }
\DoxyCodeLine{04608\ \ \ AClass\ a;}
\DoxyCodeLine{04609\ \ \ a.set\_n(1);}
\DoxyCodeLine{04610\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const\ }AClass*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{04611\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ whose\ property\ \`{}fancy\_name`\ is\ 1"{}}\ +}
\DoxyCodeLine{04612\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OfType(\textcolor{stringliteral}{"{}int"{}}),}
\DoxyCodeLine{04613\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ \&a));}
\DoxyCodeLine{04614\ }
\DoxyCodeLine{04615\ \ \ m\ =\ Property(\textcolor{stringliteral}{"{}fancy\_name"{}},\ \&AClass::n,\ GreaterThan(0));}
\DoxyCodeLine{04616\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ points\ to\ an\ object\ whose\ property\ \`{}fancy\_name`\ is\ 1"{}}\ +}
\DoxyCodeLine{04617\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ OfType(\textcolor{stringliteral}{"{}int"{}})\ +\ \textcolor{stringliteral}{"{},\ which\ is\ 1\ more\ than\ 0"{}},}
\DoxyCodeLine{04618\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ \&a));}
\DoxyCodeLine{04619\ \}}
\DoxyCodeLine{04620\ }
\DoxyCodeLine{04621\ \textcolor{comment}{//\ Tests\ ResultOf.}}
\DoxyCodeLine{04622\ }
\DoxyCodeLine{04623\ \textcolor{comment}{//\ Tests\ that\ ResultOf(f,\ ...)\ compiles\ and\ works\ as\ expected\ when\ f\ is\ a}}
\DoxyCodeLine{04624\ \textcolor{comment}{//\ function\ pointer.}}
\DoxyCodeLine{04625\ std::string\ IntToStringFunction(\textcolor{keywordtype}{int}\ input)\ \{}
\DoxyCodeLine{04626\ \ \ \textcolor{keywordflow}{return}\ input\ ==\ 1\ ?\ \textcolor{stringliteral}{"{}foo"{}}\ :\ \textcolor{stringliteral}{"{}bar"{}};}
\DoxyCodeLine{04627\ \}}
\DoxyCodeLine{04628\ }
\DoxyCodeLine{04629\ TEST(ResultOfTest,\ WorksForFunctionPointers)\ \{}
\DoxyCodeLine{04630\ \ \ Matcher<int>\ matcher\ =\ ResultOf(\&IntToStringFunction,\ Eq(std::string(\textcolor{stringliteral}{"{}foo"{}})));}
\DoxyCodeLine{04631\ }
\DoxyCodeLine{04632\ \ \ EXPECT\_TRUE(matcher.Matches(1));}
\DoxyCodeLine{04633\ \ \ EXPECT\_FALSE(matcher.Matches(2));}
\DoxyCodeLine{04634\ \}}
\DoxyCodeLine{04635\ }
\DoxyCodeLine{04636\ \textcolor{comment}{//\ Tests\ that\ ResultOf()\ can\ describe\ itself.}}
\DoxyCodeLine{04637\ TEST(ResultOfTest,\ CanDescribeItself)\ \{}
\DoxyCodeLine{04638\ \ \ Matcher<int>\ matcher\ =\ ResultOf(\&IntToStringFunction,\ StrEq(\textcolor{stringliteral}{"{}foo"{}}));}
\DoxyCodeLine{04639\ }
\DoxyCodeLine{04640\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ mapped\ by\ the\ given\ callable\ to\ a\ value\ that\ "{}}}
\DoxyCodeLine{04641\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}is\ equal\ to\ \(\backslash\)"{}foo\(\backslash\)"{}"{}},\ Describe(matcher));}
\DoxyCodeLine{04642\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ mapped\ by\ the\ given\ callable\ to\ a\ value\ that\ "{}}}
\DoxyCodeLine{04643\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}isn't\ equal\ to\ \(\backslash\)"{}foo\(\backslash\)"{}"{}},\ DescribeNegation(matcher));}
\DoxyCodeLine{04644\ \}}
\DoxyCodeLine{04645\ }
\DoxyCodeLine{04646\ \textcolor{comment}{//\ Tests\ that\ ResultOf()\ can\ explain\ the\ match\ result.}}
\DoxyCodeLine{04647\ \textcolor{keywordtype}{int}\ IntFunction(\textcolor{keywordtype}{int}\ input)\ \{\ \textcolor{keywordflow}{return}\ input\ ==\ 42\ ?\ 80\ :\ 90;\ \}}
\DoxyCodeLine{04648\ }
\DoxyCodeLine{04649\ TEST(ResultOfTest,\ CanExplainMatchResult)\ \{}
\DoxyCodeLine{04650\ \ \ Matcher<int>\ matcher\ =\ ResultOf(\&IntFunction,\ Ge(85));}
\DoxyCodeLine{04651\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ mapped\ by\ the\ given\ callable\ to\ 90"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}}),}
\DoxyCodeLine{04652\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(matcher,\ 36));}
\DoxyCodeLine{04653\ }
\DoxyCodeLine{04654\ \ \ matcher\ =\ ResultOf(\&IntFunction,\ GreaterThan(85));}
\DoxyCodeLine{04655\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ mapped\ by\ the\ given\ callable\ to\ 90"{}}\ +\ OfType(\textcolor{stringliteral}{"{}int"{}})\ +}
\DoxyCodeLine{04656\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\ which\ is\ 5\ more\ than\ 85"{}},\ Explain(matcher,\ 36));}
\DoxyCodeLine{04657\ \}}
\DoxyCodeLine{04658\ }
\DoxyCodeLine{04659\ \textcolor{comment}{//\ Tests\ that\ ResultOf(f,\ ...)\ compiles\ and\ works\ as\ expected\ when\ f(x)}}
\DoxyCodeLine{04660\ \textcolor{comment}{//\ returns\ a\ non-\/reference.}}
\DoxyCodeLine{04661\ TEST(ResultOfTest,\ WorksForNonReferenceResults)\ \{}
\DoxyCodeLine{04662\ \ \ Matcher<int>\ matcher\ =\ ResultOf(\&IntFunction,\ Eq(80));}
\DoxyCodeLine{04663\ }
\DoxyCodeLine{04664\ \ \ EXPECT\_TRUE(matcher.Matches(42));}
\DoxyCodeLine{04665\ \ \ EXPECT\_FALSE(matcher.Matches(36));}
\DoxyCodeLine{04666\ \}}
\DoxyCodeLine{04667\ }
\DoxyCodeLine{04668\ \textcolor{comment}{//\ Tests\ that\ ResultOf(f,\ ...)\ compiles\ and\ works\ as\ expected\ when\ f(x)}}
\DoxyCodeLine{04669\ \textcolor{comment}{//\ returns\ a\ reference\ to\ non-\/const.}}
\DoxyCodeLine{04670\ \textcolor{keywordtype}{double}\&\ DoubleFunction(\textcolor{keywordtype}{double}\&\ input)\ \{\ \textcolor{keywordflow}{return}\ input;\ \}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{04671\ }
\DoxyCodeLine{04672\ Uncopyable\&\ RefUncopyableFunction(Uncopyable\&\ obj)\ \{\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{04673\ \ \ \textcolor{keywordflow}{return}\ obj;}
\DoxyCodeLine{04674\ \}}
\DoxyCodeLine{04675\ }
\DoxyCodeLine{04676\ TEST(ResultOfTest,\ WorksForReferenceToNonConstResults)\ \{}
\DoxyCodeLine{04677\ \ \ \textcolor{keywordtype}{double}\ x\ =\ 3.14;}
\DoxyCodeLine{04678\ \ \ \textcolor{keywordtype}{double}\ x2\ =\ x;}
\DoxyCodeLine{04679\ \ \ Matcher<double\&>\ matcher\ =\ ResultOf(\&DoubleFunction,\ Ref(x));}
\DoxyCodeLine{04680\ }
\DoxyCodeLine{04681\ \ \ EXPECT\_TRUE(matcher.Matches(x));}
\DoxyCodeLine{04682\ \ \ EXPECT\_FALSE(matcher.Matches(x2));}
\DoxyCodeLine{04683\ }
\DoxyCodeLine{04684\ \ \ \textcolor{comment}{//\ Test\ that\ ResultOf\ works\ with\ uncopyable\ objects}}
\DoxyCodeLine{04685\ \ \ Uncopyable\ obj(0);}
\DoxyCodeLine{04686\ \ \ Uncopyable\ obj2(0);}
\DoxyCodeLine{04687\ \ \ Matcher<Uncopyable\&>\ matcher2\ =}
\DoxyCodeLine{04688\ \ \ \ \ \ \ ResultOf(\&RefUncopyableFunction,\ Ref(obj));}
\DoxyCodeLine{04689\ }
\DoxyCodeLine{04690\ \ \ EXPECT\_TRUE(matcher2.Matches(obj));}
\DoxyCodeLine{04691\ \ \ EXPECT\_FALSE(matcher2.Matches(obj2));}
\DoxyCodeLine{04692\ \}}
\DoxyCodeLine{04693\ }
\DoxyCodeLine{04694\ \textcolor{comment}{//\ Tests\ that\ ResultOf(f,\ ...)\ compiles\ and\ works\ as\ expected\ when\ f(x)}}
\DoxyCodeLine{04695\ \textcolor{comment}{//\ returns\ a\ reference\ to\ const.}}
\DoxyCodeLine{04696\ \textcolor{keyword}{const}\ std::string\&\ StringFunction(\textcolor{keyword}{const}\ std::string\&\ input)\ \{\ \textcolor{keywordflow}{return}\ input;\ \}}
\DoxyCodeLine{04697\ }
\DoxyCodeLine{04698\ TEST(ResultOfTest,\ WorksForReferenceToConstResults)\ \{}
\DoxyCodeLine{04699\ \ \ std::string\ s\ =\ \textcolor{stringliteral}{"{}foo"{}};}
\DoxyCodeLine{04700\ \ \ std::string\ s2\ =\ s;}
\DoxyCodeLine{04701\ \ \ Matcher<const\ std::string\&>\ matcher\ =\ ResultOf(\&StringFunction,\ Ref(s));}
\DoxyCodeLine{04702\ }
\DoxyCodeLine{04703\ \ \ EXPECT\_TRUE(matcher.Matches(s));}
\DoxyCodeLine{04704\ \ \ EXPECT\_FALSE(matcher.Matches(s2));}
\DoxyCodeLine{04705\ \}}
\DoxyCodeLine{04706\ }
\DoxyCodeLine{04707\ \textcolor{comment}{//\ Tests\ that\ ResultOf(f,\ m)\ works\ when\ f(x)\ and\ m's}}
\DoxyCodeLine{04708\ \textcolor{comment}{//\ argument\ types\ are\ compatible\ but\ different.}}
\DoxyCodeLine{04709\ TEST(ResultOfTest,\ WorksForCompatibleMatcherTypes)\ \{}
\DoxyCodeLine{04710\ \ \ \textcolor{comment}{//\ IntFunction()\ returns\ int\ but\ the\ inner\ matcher\ expects\ a\ signed\ char.}}
\DoxyCodeLine{04711\ \ \ Matcher<int>\ matcher\ =\ ResultOf(IntFunction,\ Matcher<signed\ char>(Ge(85)));}
\DoxyCodeLine{04712\ }
\DoxyCodeLine{04713\ \ \ EXPECT\_TRUE(matcher.Matches(36));}
\DoxyCodeLine{04714\ \ \ EXPECT\_FALSE(matcher.Matches(42));}
\DoxyCodeLine{04715\ \}}
\DoxyCodeLine{04716\ }
\DoxyCodeLine{04717\ \textcolor{comment}{//\ Tests\ that\ the\ program\ aborts\ when\ ResultOf\ is\ passed}}
\DoxyCodeLine{04718\ \textcolor{comment}{//\ a\ NULL\ function\ pointer.}}
\DoxyCodeLine{04719\ TEST(ResultOfDeathTest,\ DiesOnNullFunctionPointers)\ \{}
\DoxyCodeLine{04720\ \ \ EXPECT\_DEATH\_IF\_SUPPORTED(}
\DoxyCodeLine{04721\ \ \ \ \ \ \ ResultOf(\textcolor{keyword}{static\_cast<}std::string\ (*)(\textcolor{keywordtype}{int}\ dummy)\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}),}
\DoxyCodeLine{04722\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Eq(std::string(\textcolor{stringliteral}{"{}foo"{}}))),}
\DoxyCodeLine{04723\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}NULL\ function\ pointer\ is\ passed\ into\ ResultOf\(\backslash\)\(\backslash\)(\(\backslash\)\(\backslash\))\(\backslash\)\(\backslash\)."{}});}
\DoxyCodeLine{04724\ \}}
\DoxyCodeLine{04725\ }
\DoxyCodeLine{04726\ \textcolor{comment}{//\ Tests\ that\ ResultOf(f,\ ...)\ compiles\ and\ works\ as\ expected\ when\ f\ is\ a}}
\DoxyCodeLine{04727\ \textcolor{comment}{//\ function\ reference.}}
\DoxyCodeLine{04728\ TEST(ResultOfTest,\ WorksForFunctionReferences)\ \{}
\DoxyCodeLine{04729\ \ \ Matcher<int>\ matcher\ =\ ResultOf(IntToStringFunction,\ StrEq(\textcolor{stringliteral}{"{}foo"{}}));}
\DoxyCodeLine{04730\ \ \ EXPECT\_TRUE(matcher.Matches(1));}
\DoxyCodeLine{04731\ \ \ EXPECT\_FALSE(matcher.Matches(2));}
\DoxyCodeLine{04732\ \}}
\DoxyCodeLine{04733\ }
\DoxyCodeLine{04734\ \textcolor{comment}{//\ Tests\ that\ ResultOf(f,\ ...)\ compiles\ and\ works\ as\ expected\ when\ f\ is\ a}}
\DoxyCodeLine{04735\ \textcolor{comment}{//\ function\ object.}}
\DoxyCodeLine{04736\ \textcolor{keyword}{struct\ }Functor\ \{}
\DoxyCodeLine{04737\ \ \ std::string\ operator()(\textcolor{keywordtype}{int}\ input)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04738\ \ \ \ \ \textcolor{keywordflow}{return}\ IntToStringFunction(input);}
\DoxyCodeLine{04739\ \ \ \}}
\DoxyCodeLine{04740\ \};}
\DoxyCodeLine{04741\ }
\DoxyCodeLine{04742\ TEST(ResultOfTest,\ WorksForFunctors)\ \{}
\DoxyCodeLine{04743\ \ \ Matcher<int>\ matcher\ =\ ResultOf(Functor(),\ Eq(std::string(\textcolor{stringliteral}{"{}foo"{}})));}
\DoxyCodeLine{04744\ }
\DoxyCodeLine{04745\ \ \ EXPECT\_TRUE(matcher.Matches(1));}
\DoxyCodeLine{04746\ \ \ EXPECT\_FALSE(matcher.Matches(2));}
\DoxyCodeLine{04747\ \}}
\DoxyCodeLine{04748\ }
\DoxyCodeLine{04749\ \textcolor{comment}{//\ Tests\ that\ ResultOf(f,\ ...)\ compiles\ and\ works\ as\ expected\ when\ f\ is\ a}}
\DoxyCodeLine{04750\ \textcolor{comment}{//\ functor\ with\ more\ than\ one\ operator()\ defined.\ ResultOf()\ must\ work}}
\DoxyCodeLine{04751\ \textcolor{comment}{//\ for\ each\ defined\ operator().}}
\DoxyCodeLine{04752\ \textcolor{keyword}{struct\ }PolymorphicFunctor\ \{}
\DoxyCodeLine{04753\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keywordtype}{int}\ result\_type;}
\DoxyCodeLine{04754\ \ \ \textcolor{keywordtype}{int}\ operator()(\textcolor{keywordtype}{int}\ n)\ \{\ \textcolor{keywordflow}{return}\ n;\ \}}
\DoxyCodeLine{04755\ \ \ \textcolor{keywordtype}{int}\ operator()(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ s)\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(strlen(s));\ \}}
\DoxyCodeLine{04756\ \ \ std::string\ operator()(\textcolor{keywordtype}{int}\ *p)\ \{\ \textcolor{keywordflow}{return}\ p\ ?\ \textcolor{stringliteral}{"{}good\ ptr"{}}\ :\ \textcolor{stringliteral}{"{}null"{}};\ \}}
\DoxyCodeLine{04757\ \};}
\DoxyCodeLine{04758\ }
\DoxyCodeLine{04759\ TEST(ResultOfTest,\ WorksForPolymorphicFunctors)\ \{}
\DoxyCodeLine{04760\ \ \ Matcher<int>\ matcher\_int\ =\ ResultOf(PolymorphicFunctor(),\ Ge(5));}
\DoxyCodeLine{04761\ }
\DoxyCodeLine{04762\ \ \ EXPECT\_TRUE(matcher\_int.Matches(10));}
\DoxyCodeLine{04763\ \ \ EXPECT\_FALSE(matcher\_int.Matches(2));}
\DoxyCodeLine{04764\ }
\DoxyCodeLine{04765\ \ \ Matcher<const\ char*>\ matcher\_string\ =\ ResultOf(PolymorphicFunctor(),\ Ge(5));}
\DoxyCodeLine{04766\ }
\DoxyCodeLine{04767\ \ \ EXPECT\_TRUE(matcher\_string.Matches(\textcolor{stringliteral}{"{}long\ string"{}}));}
\DoxyCodeLine{04768\ \ \ EXPECT\_FALSE(matcher\_string.Matches(\textcolor{stringliteral}{"{}shrt"{}}));}
\DoxyCodeLine{04769\ \}}
\DoxyCodeLine{04770\ }
\DoxyCodeLine{04771\ TEST(ResultOfTest,\ WorksForPolymorphicFunctorsIgnoringResultType)\ \{}
\DoxyCodeLine{04772\ \ \ Matcher<int*>\ matcher\ =\ ResultOf(PolymorphicFunctor(),\ \textcolor{stringliteral}{"{}good\ ptr"{}});}
\DoxyCodeLine{04773\ }
\DoxyCodeLine{04774\ \ \ \textcolor{keywordtype}{int}\ n\ =\ 0;}
\DoxyCodeLine{04775\ \ \ EXPECT\_TRUE(matcher.Matches(\&n));}
\DoxyCodeLine{04776\ \ \ EXPECT\_FALSE(matcher.Matches(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{04777\ \}}
\DoxyCodeLine{04778\ }
\DoxyCodeLine{04779\ TEST(ResultOfTest,\ WorksForLambdas)\ \{}
\DoxyCodeLine{04780\ \ \ Matcher<int>\ matcher\ =\ ResultOf(}
\DoxyCodeLine{04781\ \ \ \ \ \ \ [](\textcolor{keywordtype}{int}\ str\_len)\ \{}
\DoxyCodeLine{04782\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::string(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(str\_len),\ \textcolor{charliteral}{'x'});}
\DoxyCodeLine{04783\ \ \ \ \ \ \ \},}
\DoxyCodeLine{04784\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}xxx"{}});}
\DoxyCodeLine{04785\ \ \ EXPECT\_TRUE(matcher.Matches(3));}
\DoxyCodeLine{04786\ \ \ EXPECT\_FALSE(matcher.Matches(1));}
\DoxyCodeLine{04787\ \}}
\DoxyCodeLine{04788\ }
\DoxyCodeLine{04789\ TEST(ResultOfTest,\ WorksForNonCopyableArguments)\ \{}
\DoxyCodeLine{04790\ \ \ Matcher<std::unique\_ptr<int>>\ matcher\ =\ ResultOf(}
\DoxyCodeLine{04791\ \ \ \ \ \ \ [](\textcolor{keyword}{const}\ std::unique\_ptr<int>\&\ str\_len)\ \{}
\DoxyCodeLine{04792\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::string(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(*str\_len),\ \textcolor{charliteral}{'x'});}
\DoxyCodeLine{04793\ \ \ \ \ \ \ \},}
\DoxyCodeLine{04794\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}xxx"{}});}
\DoxyCodeLine{04795\ \ \ EXPECT\_TRUE(matcher.Matches(std::unique\_ptr<int>(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(3))));}
\DoxyCodeLine{04796\ \ \ EXPECT\_FALSE(matcher.Matches(std::unique\_ptr<int>(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(1))));}
\DoxyCodeLine{04797\ \}}
\DoxyCodeLine{04798\ }
\DoxyCodeLine{04799\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ ReferencingFunction(\textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\&\ n)\ \{\ \textcolor{keywordflow}{return}\ \&n;\ \}}
\DoxyCodeLine{04800\ }
\DoxyCodeLine{04801\ \textcolor{keyword}{struct\ }ReferencingFunctor\ \{}
\DoxyCodeLine{04802\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ result\_type;}
\DoxyCodeLine{04803\ \ \ result\_type\ operator()(\textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\&\ n)\ \{\ \textcolor{keywordflow}{return}\ \&n;\ \}}
\DoxyCodeLine{04804\ \};}
\DoxyCodeLine{04805\ }
\DoxyCodeLine{04806\ TEST(ResultOfTest,\ WorksForReferencingCallables)\ \{}
\DoxyCodeLine{04807\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ n\ =\ 1;}
\DoxyCodeLine{04808\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ n2\ =\ 1;}
\DoxyCodeLine{04809\ \ \ Matcher<const\ int\&>\ matcher2\ =\ ResultOf(ReferencingFunction,\ Eq(\&n));}
\DoxyCodeLine{04810\ \ \ EXPECT\_TRUE(matcher2.Matches(n));}
\DoxyCodeLine{04811\ \ \ EXPECT\_FALSE(matcher2.Matches(n2));}
\DoxyCodeLine{04812\ }
\DoxyCodeLine{04813\ \ \ Matcher<const\ int\&>\ matcher3\ =\ ResultOf(ReferencingFunctor(),\ Eq(\&n));}
\DoxyCodeLine{04814\ \ \ EXPECT\_TRUE(matcher3.Matches(n));}
\DoxyCodeLine{04815\ \ \ EXPECT\_FALSE(matcher3.Matches(n2));}
\DoxyCodeLine{04816\ \}}
\DoxyCodeLine{04817\ }
\DoxyCodeLine{04818\ \textcolor{keyword}{class\ }DivisibleByImpl\ \{}
\DoxyCodeLine{04819\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04820\ \ \ \textcolor{keyword}{explicit}\ DivisibleByImpl(\textcolor{keywordtype}{int}\ a\_divider)\ :\ divider\_(a\_divider)\ \{\}}
\DoxyCodeLine{04821\ }
\DoxyCodeLine{04822\ \ \ \textcolor{comment}{//\ For\ testing\ using\ ExplainMatchResultTo()\ with\ polymorphic\ matchers.}}
\DoxyCodeLine{04823\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{04824\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ T\&\ n,\ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04825\ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}which\ is\ "{}}\ <<\ (n\ \%\ divider\_)\ <<\ \textcolor{stringliteral}{"{}\ modulo\ "{}}}
\DoxyCodeLine{04826\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ divider\_;}
\DoxyCodeLine{04827\ \ \ \ \ \textcolor{keywordflow}{return}\ (n\ \%\ divider\_)\ ==\ 0;}
\DoxyCodeLine{04828\ \ \ \}}
\DoxyCodeLine{04829\ }
\DoxyCodeLine{04830\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04831\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ divisible\ by\ "{}}\ <<\ divider\_;}
\DoxyCodeLine{04832\ \ \ \}}
\DoxyCodeLine{04833\ }
\DoxyCodeLine{04834\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04835\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}is\ not\ divisible\ by\ "{}}\ <<\ divider\_;}
\DoxyCodeLine{04836\ \ \ \}}
\DoxyCodeLine{04837\ }
\DoxyCodeLine{04838\ \ \ \textcolor{keywordtype}{void}\ set\_divider(\textcolor{keywordtype}{int}\ a\_divider)\ \{\ divider\_\ =\ a\_divider;\ \}}
\DoxyCodeLine{04839\ \ \ \textcolor{keywordtype}{int}\ divider()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ divider\_;\ \}}
\DoxyCodeLine{04840\ }
\DoxyCodeLine{04841\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04842\ \ \ \textcolor{keywordtype}{int}\ divider\_;}
\DoxyCodeLine{04843\ \};}
\DoxyCodeLine{04844\ }
\DoxyCodeLine{04845\ PolymorphicMatcher<DivisibleByImpl>\ DivisibleBy(\textcolor{keywordtype}{int}\ n)\ \{}
\DoxyCodeLine{04846\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(DivisibleByImpl(n));}
\DoxyCodeLine{04847\ \}}
\DoxyCodeLine{04848\ }
\DoxyCodeLine{04849\ \textcolor{comment}{//\ Tests\ that\ when\ AllOf()\ fails,\ only\ the\ first\ failing\ matcher\ is}}
\DoxyCodeLine{04850\ \textcolor{comment}{//\ asked\ to\ explain\ why.}}
\DoxyCodeLine{04851\ TEST(ExplainMatchResultTest,\ AllOf\_False\_False)\ \{}
\DoxyCodeLine{04852\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ AllOf(DivisibleBy(4),\ DivisibleBy(3));}
\DoxyCodeLine{04853\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 1\ modulo\ 4"{}},\ Explain(m,\ 5));}
\DoxyCodeLine{04854\ \}}
\DoxyCodeLine{04855\ }
\DoxyCodeLine{04856\ \textcolor{comment}{//\ Tests\ that\ when\ AllOf()\ fails,\ only\ the\ first\ failing\ matcher\ is}}
\DoxyCodeLine{04857\ \textcolor{comment}{//\ asked\ to\ explain\ why.}}
\DoxyCodeLine{04858\ TEST(ExplainMatchResultTest,\ AllOf\_False\_True)\ \{}
\DoxyCodeLine{04859\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ AllOf(DivisibleBy(4),\ DivisibleBy(3));}
\DoxyCodeLine{04860\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 2\ modulo\ 4"{}},\ Explain(m,\ 6));}
\DoxyCodeLine{04861\ \}}
\DoxyCodeLine{04862\ }
\DoxyCodeLine{04863\ \textcolor{comment}{//\ Tests\ that\ when\ AllOf()\ fails,\ only\ the\ first\ failing\ matcher\ is}}
\DoxyCodeLine{04864\ \textcolor{comment}{//\ asked\ to\ explain\ why.}}
\DoxyCodeLine{04865\ TEST(ExplainMatchResultTest,\ AllOf\_True\_False)\ \{}
\DoxyCodeLine{04866\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ AllOf(Ge(1),\ DivisibleBy(3));}
\DoxyCodeLine{04867\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 2\ modulo\ 3"{}},\ Explain(m,\ 5));}
\DoxyCodeLine{04868\ \}}
\DoxyCodeLine{04869\ }
\DoxyCodeLine{04870\ \textcolor{comment}{//\ Tests\ that\ when\ AllOf()\ succeeds,\ all\ matchers\ are\ asked\ to\ explain}}
\DoxyCodeLine{04871\ \textcolor{comment}{//\ why.}}
\DoxyCodeLine{04872\ TEST(ExplainMatchResultTest,\ AllOf\_True\_True)\ \{}
\DoxyCodeLine{04873\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ AllOf(DivisibleBy(2),\ DivisibleBy(3));}
\DoxyCodeLine{04874\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 0\ modulo\ 2,\ and\ which\ is\ 0\ modulo\ 3"{}},\ Explain(m,\ 6));}
\DoxyCodeLine{04875\ \}}
\DoxyCodeLine{04876\ }
\DoxyCodeLine{04877\ TEST(ExplainMatchResultTest,\ AllOf\_True\_True\_2)\ \{}
\DoxyCodeLine{04878\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ AllOf(Ge(2),\ Le(3));}
\DoxyCodeLine{04879\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 2));}
\DoxyCodeLine{04880\ \}}
\DoxyCodeLine{04881\ }
\DoxyCodeLine{04882\ TEST(ExplainmatcherResultTest,\ MonomorphicMatcher)\ \{}
\DoxyCodeLine{04883\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ GreaterThan(5);}
\DoxyCodeLine{04884\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 1\ more\ than\ 5"{}},\ Explain(m,\ 6));}
\DoxyCodeLine{04885\ \}}
\DoxyCodeLine{04886\ }
\DoxyCodeLine{04887\ \textcolor{comment}{//\ The\ following\ two\ tests\ verify\ that\ values\ without\ a\ public\ copy}}
\DoxyCodeLine{04888\ \textcolor{comment}{//\ ctor\ can\ be\ used\ as\ arguments\ to\ matchers\ like\ Eq(),\ Ge(),\ and\ etc}}
\DoxyCodeLine{04889\ \textcolor{comment}{//\ with\ the\ help\ of\ ByRef().}}
\DoxyCodeLine{04890\ }
\DoxyCodeLine{04891\ \textcolor{keyword}{class\ }NotCopyable\ \{}
\DoxyCodeLine{04892\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{04893\ \ \ \textcolor{keyword}{explicit}\ NotCopyable(\textcolor{keywordtype}{int}\ a\_value)\ :\ value\_(a\_value)\ \{\}}
\DoxyCodeLine{04894\ }
\DoxyCodeLine{04895\ \ \ \textcolor{keywordtype}{int}\ value()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ value\_;\ \}}
\DoxyCodeLine{04896\ }
\DoxyCodeLine{04897\ \ \ \textcolor{keywordtype}{bool}\ operator==(\textcolor{keyword}{const}\ NotCopyable\&\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04898\ \ \ \ \ \textcolor{keywordflow}{return}\ value()\ ==\ rhs.value();}
\DoxyCodeLine{04899\ \ \ \}}
\DoxyCodeLine{04900\ }
\DoxyCodeLine{04901\ \ \ \textcolor{keywordtype}{bool}\ operator>=(\textcolor{keyword}{const}\ NotCopyable\&\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{04902\ \ \ \ \ \textcolor{keywordflow}{return}\ value()\ >=\ rhs.value();}
\DoxyCodeLine{04903\ \ \ \}}
\DoxyCodeLine{04904\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{04905\ \ \ \textcolor{keywordtype}{int}\ value\_;}
\DoxyCodeLine{04906\ }
\DoxyCodeLine{04907\ \ \ GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(NotCopyable);}
\DoxyCodeLine{04908\ \};}
\DoxyCodeLine{04909\ }
\DoxyCodeLine{04910\ TEST(ByRefTest,\ AllowsNotCopyableConstValueInMatchers)\ \{}
\DoxyCodeLine{04911\ \ \ \textcolor{keyword}{const}\ NotCopyable\ const\_value1(1);}
\DoxyCodeLine{04912\ \ \ \textcolor{keyword}{const}\ Matcher<const\ NotCopyable\&>\ m\ =\ Eq(ByRef(const\_value1));}
\DoxyCodeLine{04913\ }
\DoxyCodeLine{04914\ \ \ \textcolor{keyword}{const}\ NotCopyable\ n1(1),\ n2(2);}
\DoxyCodeLine{04915\ \ \ EXPECT\_TRUE(m.Matches(n1));}
\DoxyCodeLine{04916\ \ \ EXPECT\_FALSE(m.Matches(n2));}
\DoxyCodeLine{04917\ \}}
\DoxyCodeLine{04918\ }
\DoxyCodeLine{04919\ TEST(ByRefTest,\ AllowsNotCopyableValueInMatchers)\ \{}
\DoxyCodeLine{04920\ \ \ NotCopyable\ value2(2);}
\DoxyCodeLine{04921\ \ \ \textcolor{keyword}{const}\ Matcher<NotCopyable\&>\ m\ =\ Ge(ByRef(value2));}
\DoxyCodeLine{04922\ }
\DoxyCodeLine{04923\ \ \ NotCopyable\ n1(1),\ n2(2);}
\DoxyCodeLine{04924\ \ \ EXPECT\_FALSE(m.Matches(n1));}
\DoxyCodeLine{04925\ \ \ EXPECT\_TRUE(m.Matches(n2));}
\DoxyCodeLine{04926\ \}}
\DoxyCodeLine{04927\ }
\DoxyCodeLine{04928\ TEST(IsEmptyTest,\ ImplementsIsEmpty)\ \{}
\DoxyCodeLine{04929\ \ \ vector<int>\ container;}
\DoxyCodeLine{04930\ \ \ EXPECT\_THAT(container,\ IsEmpty());}
\DoxyCodeLine{04931\ \ \ container.push\_back(0);}
\DoxyCodeLine{04932\ \ \ EXPECT\_THAT(container,\ Not(IsEmpty()));}
\DoxyCodeLine{04933\ \ \ container.push\_back(1);}
\DoxyCodeLine{04934\ \ \ EXPECT\_THAT(container,\ Not(IsEmpty()));}
\DoxyCodeLine{04935\ \}}
\DoxyCodeLine{04936\ }
\DoxyCodeLine{04937\ TEST(IsEmptyTest,\ WorksWithString)\ \{}
\DoxyCodeLine{04938\ \ \ std::string\ text;}
\DoxyCodeLine{04939\ \ \ EXPECT\_THAT(text,\ IsEmpty());}
\DoxyCodeLine{04940\ \ \ text\ =\ \textcolor{stringliteral}{"{}foo"{}};}
\DoxyCodeLine{04941\ \ \ EXPECT\_THAT(text,\ Not(IsEmpty()));}
\DoxyCodeLine{04942\ \ \ text\ =\ std::string(\textcolor{stringliteral}{"{}\(\backslash\)0"{}},\ 1);}
\DoxyCodeLine{04943\ \ \ EXPECT\_THAT(text,\ Not(IsEmpty()));}
\DoxyCodeLine{04944\ \}}
\DoxyCodeLine{04945\ }
\DoxyCodeLine{04946\ TEST(IsEmptyTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{04947\ \ \ Matcher<vector<int>\ >\ m\ =\ IsEmpty();}
\DoxyCodeLine{04948\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ empty"{}},\ Describe(m));}
\DoxyCodeLine{04949\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ empty"{}},\ DescribeNegation(m));}
\DoxyCodeLine{04950\ \}}
\DoxyCodeLine{04951\ }
\DoxyCodeLine{04952\ TEST(IsEmptyTest,\ ExplainsResult)\ \{}
\DoxyCodeLine{04953\ \ \ Matcher<vector<int>\ >\ m\ =\ IsEmpty();}
\DoxyCodeLine{04954\ \ \ vector<int>\ container;}
\DoxyCodeLine{04955\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ container));}
\DoxyCodeLine{04956\ \ \ container.push\_back(0);}
\DoxyCodeLine{04957\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ is\ 1"{}},\ Explain(m,\ container));}
\DoxyCodeLine{04958\ \}}
\DoxyCodeLine{04959\ }
\DoxyCodeLine{04960\ TEST(IsEmptyTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{04961\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{04962\ \ \ EXPECT\_CALL(helper,\ Call(IsEmpty()));}
\DoxyCodeLine{04963\ \ \ helper.Call(\{\});}
\DoxyCodeLine{04964\ \}}
\DoxyCodeLine{04965\ }
\DoxyCodeLine{04966\ TEST(IsTrueTest,\ IsTrueIsFalse)\ \{}
\DoxyCodeLine{04967\ \ \ EXPECT\_THAT(\textcolor{keyword}{true},\ IsTrue());}
\DoxyCodeLine{04968\ \ \ EXPECT\_THAT(\textcolor{keyword}{false},\ IsFalse());}
\DoxyCodeLine{04969\ \ \ EXPECT\_THAT(\textcolor{keyword}{true},\ Not(IsFalse()));}
\DoxyCodeLine{04970\ \ \ EXPECT\_THAT(\textcolor{keyword}{false},\ Not(IsTrue()));}
\DoxyCodeLine{04971\ \ \ EXPECT\_THAT(0,\ Not(IsTrue()));}
\DoxyCodeLine{04972\ \ \ EXPECT\_THAT(0,\ IsFalse());}
\DoxyCodeLine{04973\ \ \ EXPECT\_THAT(\textcolor{keyword}{nullptr},\ Not(IsTrue()));}
\DoxyCodeLine{04974\ \ \ EXPECT\_THAT(\textcolor{keyword}{nullptr},\ IsFalse());}
\DoxyCodeLine{04975\ \ \ EXPECT\_THAT(-\/1,\ IsTrue());}
\DoxyCodeLine{04976\ \ \ EXPECT\_THAT(-\/1,\ Not(IsFalse()));}
\DoxyCodeLine{04977\ \ \ EXPECT\_THAT(1,\ IsTrue());}
\DoxyCodeLine{04978\ \ \ EXPECT\_THAT(1,\ Not(IsFalse()));}
\DoxyCodeLine{04979\ \ \ EXPECT\_THAT(2,\ IsTrue());}
\DoxyCodeLine{04980\ \ \ EXPECT\_THAT(2,\ Not(IsFalse()));}
\DoxyCodeLine{04981\ \ \ \textcolor{keywordtype}{int}\ a\ =\ 42;}
\DoxyCodeLine{04982\ \ \ EXPECT\_THAT(a,\ IsTrue());}
\DoxyCodeLine{04983\ \ \ EXPECT\_THAT(a,\ Not(IsFalse()));}
\DoxyCodeLine{04984\ \ \ EXPECT\_THAT(\&a,\ IsTrue());}
\DoxyCodeLine{04985\ \ \ EXPECT\_THAT(\&a,\ Not(IsFalse()));}
\DoxyCodeLine{04986\ \ \ EXPECT\_THAT(\textcolor{keyword}{false},\ Not(IsTrue()));}
\DoxyCodeLine{04987\ \ \ EXPECT\_THAT(\textcolor{keyword}{true},\ Not(IsFalse()));}
\DoxyCodeLine{04988\ \ \ EXPECT\_THAT(std::true\_type(),\ IsTrue());}
\DoxyCodeLine{04989\ \ \ EXPECT\_THAT(std::true\_type(),\ Not(IsFalse()));}
\DoxyCodeLine{04990\ \ \ EXPECT\_THAT(std::false\_type(),\ IsFalse());}
\DoxyCodeLine{04991\ \ \ EXPECT\_THAT(std::false\_type(),\ Not(IsTrue()));}
\DoxyCodeLine{04992\ \ \ EXPECT\_THAT(\textcolor{keyword}{nullptr},\ Not(IsTrue()));}
\DoxyCodeLine{04993\ \ \ EXPECT\_THAT(\textcolor{keyword}{nullptr},\ IsFalse());}
\DoxyCodeLine{04994\ \ \ std::unique\_ptr<int>\ null\_unique;}
\DoxyCodeLine{04995\ \ \ std::unique\_ptr<int>\ nonnull\_unique(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(0));}
\DoxyCodeLine{04996\ \ \ EXPECT\_THAT(null\_unique,\ Not(IsTrue()));}
\DoxyCodeLine{04997\ \ \ EXPECT\_THAT(null\_unique,\ IsFalse());}
\DoxyCodeLine{04998\ \ \ EXPECT\_THAT(nonnull\_unique,\ IsTrue());}
\DoxyCodeLine{04999\ \ \ EXPECT\_THAT(nonnull\_unique,\ Not(IsFalse()));}
\DoxyCodeLine{05000\ \}}
\DoxyCodeLine{05001\ }
\DoxyCodeLine{05002\ TEST(SizeIsTest,\ ImplementsSizeIs)\ \{}
\DoxyCodeLine{05003\ \ \ vector<int>\ container;}
\DoxyCodeLine{05004\ \ \ EXPECT\_THAT(container,\ SizeIs(0));}
\DoxyCodeLine{05005\ \ \ EXPECT\_THAT(container,\ Not(SizeIs(1)));}
\DoxyCodeLine{05006\ \ \ container.push\_back(0);}
\DoxyCodeLine{05007\ \ \ EXPECT\_THAT(container,\ Not(SizeIs(0)));}
\DoxyCodeLine{05008\ \ \ EXPECT\_THAT(container,\ SizeIs(1));}
\DoxyCodeLine{05009\ \ \ container.push\_back(0);}
\DoxyCodeLine{05010\ \ \ EXPECT\_THAT(container,\ Not(SizeIs(0)));}
\DoxyCodeLine{05011\ \ \ EXPECT\_THAT(container,\ SizeIs(2));}
\DoxyCodeLine{05012\ \}}
\DoxyCodeLine{05013\ }
\DoxyCodeLine{05014\ TEST(SizeIsTest,\ WorksWithMap)\ \{}
\DoxyCodeLine{05015\ \ \ map<std::string,\ int>\ container;}
\DoxyCodeLine{05016\ \ \ EXPECT\_THAT(container,\ SizeIs(0));}
\DoxyCodeLine{05017\ \ \ EXPECT\_THAT(container,\ Not(SizeIs(1)));}
\DoxyCodeLine{05018\ \ \ container.insert(make\_pair(\textcolor{stringliteral}{"{}foo"{}},\ 1));}
\DoxyCodeLine{05019\ \ \ EXPECT\_THAT(container,\ Not(SizeIs(0)));}
\DoxyCodeLine{05020\ \ \ EXPECT\_THAT(container,\ SizeIs(1));}
\DoxyCodeLine{05021\ \ \ container.insert(make\_pair(\textcolor{stringliteral}{"{}bar"{}},\ 2));}
\DoxyCodeLine{05022\ \ \ EXPECT\_THAT(container,\ Not(SizeIs(0)));}
\DoxyCodeLine{05023\ \ \ EXPECT\_THAT(container,\ SizeIs(2));}
\DoxyCodeLine{05024\ \}}
\DoxyCodeLine{05025\ }
\DoxyCodeLine{05026\ TEST(SizeIsTest,\ WorksWithReferences)\ \{}
\DoxyCodeLine{05027\ \ \ vector<int>\ container;}
\DoxyCodeLine{05028\ \ \ Matcher<const\ vector<int>\&>\ m\ =\ SizeIs(1);}
\DoxyCodeLine{05029\ \ \ EXPECT\_THAT(container,\ Not(m));}
\DoxyCodeLine{05030\ \ \ container.push\_back(0);}
\DoxyCodeLine{05031\ \ \ EXPECT\_THAT(container,\ m);}
\DoxyCodeLine{05032\ \}}
\DoxyCodeLine{05033\ }
\DoxyCodeLine{05034\ TEST(SizeIsTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{05035\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{05036\ \ \ EXPECT\_CALL(helper,\ Call(SizeIs(3)));}
\DoxyCodeLine{05037\ \ \ helper.Call(MakeUniquePtrs(\{1,\ 2,\ 3\}));}
\DoxyCodeLine{05038\ \}}
\DoxyCodeLine{05039\ }
\DoxyCodeLine{05040\ \textcolor{comment}{//\ SizeIs\ should\ work\ for\ any\ type\ that\ provides\ a\ size()\ member\ function.}}
\DoxyCodeLine{05041\ \textcolor{comment}{//\ For\ example,\ a\ size\_type\ member\ type\ should\ not\ need\ to\ be\ provided.}}
\DoxyCodeLine{05042\ \textcolor{keyword}{struct\ }MinimalistCustomType\ \{}
\DoxyCodeLine{05043\ \ \ \textcolor{keywordtype}{int}\ size()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ 1;\ \}}
\DoxyCodeLine{05044\ \};}
\DoxyCodeLine{05045\ TEST(SizeIsTest,\ WorksWithMinimalistCustomType)\ \{}
\DoxyCodeLine{05046\ \ \ MinimalistCustomType\ container;}
\DoxyCodeLine{05047\ \ \ EXPECT\_THAT(container,\ SizeIs(1));}
\DoxyCodeLine{05048\ \ \ EXPECT\_THAT(container,\ Not(SizeIs(0)));}
\DoxyCodeLine{05049\ \}}
\DoxyCodeLine{05050\ }
\DoxyCodeLine{05051\ TEST(SizeIsTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{05052\ \ \ Matcher<vector<int>\ >\ m\ =\ SizeIs(2);}
\DoxyCodeLine{05053\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}size\ is\ equal\ to\ 2"{}},\ Describe(m));}
\DoxyCodeLine{05054\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}size\ isn't\ equal\ to\ 2"{}},\ DescribeNegation(m));}
\DoxyCodeLine{05055\ \}}
\DoxyCodeLine{05056\ }
\DoxyCodeLine{05057\ TEST(SizeIsTest,\ ExplainsResult)\ \{}
\DoxyCodeLine{05058\ \ \ Matcher<vector<int>\ >\ m1\ =\ SizeIs(2);}
\DoxyCodeLine{05059\ \ \ Matcher<vector<int>\ >\ m2\ =\ SizeIs(Lt(2u));}
\DoxyCodeLine{05060\ \ \ Matcher<vector<int>\ >\ m3\ =\ SizeIs(AnyOf(0,\ 3));}
\DoxyCodeLine{05061\ \ \ Matcher<vector<int>\ >\ m4\ =\ SizeIs(Gt(1u));}
\DoxyCodeLine{05062\ \ \ vector<int>\ container;}
\DoxyCodeLine{05063\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ 0\ doesn't\ match"{}},\ Explain(m1,\ container));}
\DoxyCodeLine{05064\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ 0\ matches"{}},\ Explain(m2,\ container));}
\DoxyCodeLine{05065\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ 0\ matches"{}},\ Explain(m3,\ container));}
\DoxyCodeLine{05066\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ 0\ doesn't\ match"{}},\ Explain(m4,\ container));}
\DoxyCodeLine{05067\ \ \ container.push\_back(0);}
\DoxyCodeLine{05068\ \ \ container.push\_back(0);}
\DoxyCodeLine{05069\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ 2\ matches"{}},\ Explain(m1,\ container));}
\DoxyCodeLine{05070\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ 2\ doesn't\ match"{}},\ Explain(m2,\ container));}
\DoxyCodeLine{05071\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ 2\ doesn't\ match"{}},\ Explain(m3,\ container));}
\DoxyCodeLine{05072\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ size\ 2\ matches"{}},\ Explain(m4,\ container));}
\DoxyCodeLine{05073\ \}}
\DoxyCodeLine{05074\ }
\DoxyCodeLine{05075\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_TYPED\_TEST}}
\DoxyCodeLine{05076\ \textcolor{comment}{//\ Tests\ ContainerEq\ with\ different\ container\ types,\ and}}
\DoxyCodeLine{05077\ \textcolor{comment}{//\ different\ element\ types.}}
\DoxyCodeLine{05078\ }
\DoxyCodeLine{05079\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05080\ \textcolor{keyword}{class\ }ContainerEqTest\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classtesting_1_1_test}{testing::Test}}\ \{\};}
\DoxyCodeLine{05081\ }
\DoxyCodeLine{05082\ \textcolor{keyword}{typedef}\ \mbox{\hyperlink{structtesting_1_1internal_1_1_proxy_type_list}{testing::Types}}<}
\DoxyCodeLine{05083\ \ \ \ \ set<int>,}
\DoxyCodeLine{05084\ \ \ \ \ vector<size\_t>,}
\DoxyCodeLine{05085\ \ \ \ \ multiset<size\_t>,}
\DoxyCodeLine{05086\ \ \ \ \ list<int>\ >}
\DoxyCodeLine{05087\ \ \ \ \ ContainerEqTestTypes;}
\DoxyCodeLine{05088\ }
\DoxyCodeLine{05089\ TYPED\_TEST\_SUITE(ContainerEqTest,\ ContainerEqTestTypes);}
\DoxyCodeLine{05090\ }
\DoxyCodeLine{05091\ \textcolor{comment}{//\ Tests\ that\ the\ filled\ container\ is\ equal\ to\ itself.}}
\DoxyCodeLine{05092\ TYPED\_TEST(ContainerEqTest,\ EqualsSelf)\ \{}
\DoxyCodeLine{05093\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05094\ \ \ TypeParam\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05095\ \ \ \textcolor{keyword}{const}\ Matcher<TypeParam>\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05096\ \ \ EXPECT\_TRUE(m.Matches(my\_set));}
\DoxyCodeLine{05097\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ my\_set));}
\DoxyCodeLine{05098\ \}}
\DoxyCodeLine{05099\ }
\DoxyCodeLine{05100\ \textcolor{comment}{//\ Tests\ that\ missing\ values\ are\ reported.}}
\DoxyCodeLine{05101\ TYPED\_TEST(ContainerEqTest,\ ValueMissing)\ \{}
\DoxyCodeLine{05102\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05103\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ test\_vals[]\ =\ \{2,\ 1,\ 8,\ 5\};}
\DoxyCodeLine{05104\ \ \ TypeParam\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05105\ \ \ TypeParam\ test\_set(test\_vals,\ test\_vals\ +\ 4);}
\DoxyCodeLine{05106\ \ \ \textcolor{keyword}{const}\ Matcher<TypeParam>\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05107\ \ \ EXPECT\_FALSE(m.Matches(test\_set));}
\DoxyCodeLine{05108\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ doesn't\ have\ these\ expected\ elements:\ 3"{}},}
\DoxyCodeLine{05109\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ test\_set));}
\DoxyCodeLine{05110\ \}}
\DoxyCodeLine{05111\ }
\DoxyCodeLine{05112\ \textcolor{comment}{//\ Tests\ that\ added\ values\ are\ reported.}}
\DoxyCodeLine{05113\ TYPED\_TEST(ContainerEqTest,\ ValueAdded)\ \{}
\DoxyCodeLine{05114\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05115\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ test\_vals[]\ =\ \{1,\ 2,\ 3,\ 5,\ 8,\ 46\};}
\DoxyCodeLine{05116\ \ \ TypeParam\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05117\ \ \ TypeParam\ test\_set(test\_vals,\ test\_vals\ +\ 6);}
\DoxyCodeLine{05118\ \ \ \textcolor{keyword}{const}\ Matcher<const\ TypeParam\&>\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05119\ \ \ EXPECT\_FALSE(m.Matches(test\_set));}
\DoxyCodeLine{05120\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ has\ these\ unexpected\ elements:\ 46"{}},\ Explain(m,\ test\_set));}
\DoxyCodeLine{05121\ \}}
\DoxyCodeLine{05122\ }
\DoxyCodeLine{05123\ \textcolor{comment}{//\ Tests\ that\ added\ and\ missing\ values\ are\ reported\ together.}}
\DoxyCodeLine{05124\ TYPED\_TEST(ContainerEqTest,\ ValueAddedAndRemoved)\ \{}
\DoxyCodeLine{05125\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05126\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ test\_vals[]\ =\ \{1,\ 2,\ 3,\ 8,\ 46\};}
\DoxyCodeLine{05127\ \ \ TypeParam\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05128\ \ \ TypeParam\ test\_set(test\_vals,\ test\_vals\ +\ 5);}
\DoxyCodeLine{05129\ \ \ \textcolor{keyword}{const}\ Matcher<TypeParam>\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05130\ \ \ EXPECT\_FALSE(m.Matches(test\_set));}
\DoxyCodeLine{05131\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ has\ these\ unexpected\ elements:\ 46,\(\backslash\)n"{}}}
\DoxyCodeLine{05132\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\ doesn't\ have\ these\ expected\ elements:\ 5"{}},}
\DoxyCodeLine{05133\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ test\_set));}
\DoxyCodeLine{05134\ \}}
\DoxyCodeLine{05135\ }
\DoxyCodeLine{05136\ \textcolor{comment}{//\ Tests\ duplicated\ value\ -\/-\/\ expect\ no\ explanation.}}
\DoxyCodeLine{05137\ TYPED\_TEST(ContainerEqTest,\ DuplicateDifference)\ \{}
\DoxyCodeLine{05138\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05139\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ test\_vals[]\ =\ \{1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05140\ \ \ TypeParam\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05141\ \ \ TypeParam\ test\_set(test\_vals,\ test\_vals\ +\ 5);}
\DoxyCodeLine{05142\ \ \ \textcolor{keyword}{const}\ Matcher<const\ TypeParam\&>\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05143\ \ \ \textcolor{comment}{//\ Depending\ on\ the\ container,\ match\ may\ be\ true\ or\ false}}
\DoxyCodeLine{05144\ \ \ \textcolor{comment}{//\ But\ in\ any\ case\ there\ should\ be\ no\ explanation.}}
\DoxyCodeLine{05145\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ test\_set));}
\DoxyCodeLine{05146\ \}}
\DoxyCodeLine{05147\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_TYPED\_TEST}}
\DoxyCodeLine{05148\ }
\DoxyCodeLine{05149\ \textcolor{comment}{//\ Tests\ that\ multiple\ missing\ values\ are\ reported.}}
\DoxyCodeLine{05150\ \textcolor{comment}{//\ Using\ just\ vector\ here,\ so\ order\ is\ predictable.}}
\DoxyCodeLine{05151\ TEST(ContainerEqExtraTest,\ MultipleValuesMissing)\ \{}
\DoxyCodeLine{05152\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05153\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ test\_vals[]\ =\ \{2,\ 1,\ 5\};}
\DoxyCodeLine{05154\ \ \ vector<int>\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05155\ \ \ vector<int>\ test\_set(test\_vals,\ test\_vals\ +\ 3);}
\DoxyCodeLine{05156\ \ \ \textcolor{keyword}{const}\ Matcher<vector<int>\ >\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05157\ \ \ EXPECT\_FALSE(m.Matches(test\_set));}
\DoxyCodeLine{05158\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ doesn't\ have\ these\ expected\ elements:\ 3,\ 8"{}},}
\DoxyCodeLine{05159\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ test\_set));}
\DoxyCodeLine{05160\ \}}
\DoxyCodeLine{05161\ }
\DoxyCodeLine{05162\ \textcolor{comment}{//\ Tests\ that\ added\ values\ are\ reported.}}
\DoxyCodeLine{05163\ \textcolor{comment}{//\ Using\ just\ vector\ here,\ so\ order\ is\ predictable.}}
\DoxyCodeLine{05164\ TEST(ContainerEqExtraTest,\ MultipleValuesAdded)\ \{}
\DoxyCodeLine{05165\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05166\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ test\_vals[]\ =\ \{1,\ 2,\ 92,\ 3,\ 5,\ 8,\ 46\};}
\DoxyCodeLine{05167\ \ \ list<size\_t>\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05168\ \ \ list<size\_t>\ test\_set(test\_vals,\ test\_vals\ +\ 7);}
\DoxyCodeLine{05169\ \ \ \textcolor{keyword}{const}\ Matcher<const\ list<size\_t>\&>\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05170\ \ \ EXPECT\_FALSE(m.Matches(test\_set));}
\DoxyCodeLine{05171\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ has\ these\ unexpected\ elements:\ 92,\ 46"{}},}
\DoxyCodeLine{05172\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ test\_set));}
\DoxyCodeLine{05173\ \}}
\DoxyCodeLine{05174\ }
\DoxyCodeLine{05175\ \textcolor{comment}{//\ Tests\ that\ added\ and\ missing\ values\ are\ reported\ together.}}
\DoxyCodeLine{05176\ TEST(ContainerEqExtraTest,\ MultipleValuesAddedAndRemoved)\ \{}
\DoxyCodeLine{05177\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05178\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ test\_vals[]\ =\ \{1,\ 2,\ 3,\ 92,\ 46\};}
\DoxyCodeLine{05179\ \ \ list<size\_t>\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05180\ \ \ list<size\_t>\ test\_set(test\_vals,\ test\_vals\ +\ 5);}
\DoxyCodeLine{05181\ \ \ \textcolor{keyword}{const}\ Matcher<const\ list<size\_t>\ >\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05182\ \ \ EXPECT\_FALSE(m.Matches(test\_set));}
\DoxyCodeLine{05183\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ has\ these\ unexpected\ elements:\ 92,\ 46,\(\backslash\)n"{}}}
\DoxyCodeLine{05184\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\ doesn't\ have\ these\ expected\ elements:\ 5,\ 8"{}},}
\DoxyCodeLine{05185\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ test\_set));}
\DoxyCodeLine{05186\ \}}
\DoxyCodeLine{05187\ }
\DoxyCodeLine{05188\ \textcolor{comment}{//\ Tests\ to\ see\ that\ duplicate\ elements\ are\ detected,}}
\DoxyCodeLine{05189\ \textcolor{comment}{//\ but\ (as\ above)\ not\ reported\ in\ the\ explanation.}}
\DoxyCodeLine{05190\ TEST(ContainerEqExtraTest,\ MultiSetOfIntDuplicateDifference)\ \{}
\DoxyCodeLine{05191\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vals[]\ =\ \{1,\ 1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05192\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ test\_vals[]\ =\ \{1,\ 2,\ 3,\ 5,\ 8\};}
\DoxyCodeLine{05193\ \ \ vector<int>\ my\_set(vals,\ vals\ +\ 6);}
\DoxyCodeLine{05194\ \ \ vector<int>\ test\_set(test\_vals,\ test\_vals\ +\ 5);}
\DoxyCodeLine{05195\ \ \ \textcolor{keyword}{const}\ Matcher<vector<int>\ >\ m\ =\ ContainerEq(my\_set);}
\DoxyCodeLine{05196\ \ \ EXPECT\_TRUE(m.Matches(my\_set));}
\DoxyCodeLine{05197\ \ \ EXPECT\_FALSE(m.Matches(test\_set));}
\DoxyCodeLine{05198\ \ \ \textcolor{comment}{//\ There\ is\ nothing\ to\ report\ when\ both\ sets\ contain\ all\ the\ same\ values.}}
\DoxyCodeLine{05199\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ test\_set));}
\DoxyCodeLine{05200\ \}}
\DoxyCodeLine{05201\ }
\DoxyCodeLine{05202\ \textcolor{comment}{//\ Tests\ that\ ContainerEq\ works\ for\ non-\/trivial\ associative\ containers,}}
\DoxyCodeLine{05203\ \textcolor{comment}{//\ like\ maps.}}
\DoxyCodeLine{05204\ TEST(ContainerEqExtraTest,\ WorksForMaps)\ \{}
\DoxyCodeLine{05205\ \ \ map<int,\ std::string>\ my\_map;}
\DoxyCodeLine{05206\ \ \ my\_map[0]\ =\ \textcolor{stringliteral}{"{}a"{}};}
\DoxyCodeLine{05207\ \ \ my\_map[1]\ =\ \textcolor{stringliteral}{"{}b"{}};}
\DoxyCodeLine{05208\ }
\DoxyCodeLine{05209\ \ \ map<int,\ std::string>\ test\_map;}
\DoxyCodeLine{05210\ \ \ test\_map[0]\ =\ \textcolor{stringliteral}{"{}aa"{}};}
\DoxyCodeLine{05211\ \ \ test\_map[1]\ =\ \textcolor{stringliteral}{"{}b"{}};}
\DoxyCodeLine{05212\ }
\DoxyCodeLine{05213\ \ \ \textcolor{keyword}{const}\ Matcher<const\ map<int,\ std::string>\&>\ m\ =\ ContainerEq(my\_map);}
\DoxyCodeLine{05214\ \ \ EXPECT\_TRUE(m.Matches(my\_map));}
\DoxyCodeLine{05215\ \ \ EXPECT\_FALSE(m.Matches(test\_map));}
\DoxyCodeLine{05216\ }
\DoxyCodeLine{05217\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ has\ these\ unexpected\ elements:\ (0,\ \(\backslash\)"{}aa\(\backslash\)"{}),\(\backslash\)n"{}}}
\DoxyCodeLine{05218\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\ doesn't\ have\ these\ expected\ elements:\ (0,\ \(\backslash\)"{}a\(\backslash\)"{})"{}},}
\DoxyCodeLine{05219\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ test\_map));}
\DoxyCodeLine{05220\ \}}
\DoxyCodeLine{05221\ }
\DoxyCodeLine{05222\ TEST(ContainerEqExtraTest,\ WorksForNativeArray)\ \{}
\DoxyCodeLine{05223\ \ \ \textcolor{keywordtype}{int}\ a1[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{05224\ \ \ \textcolor{keywordtype}{int}\ a2[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{05225\ \ \ \textcolor{keywordtype}{int}\ b[]\ =\ \{1,\ 2,\ 4\};}
\DoxyCodeLine{05226\ }
\DoxyCodeLine{05227\ \ \ EXPECT\_THAT(a1,\ ContainerEq(a2));}
\DoxyCodeLine{05228\ \ \ EXPECT\_THAT(a1,\ Not(ContainerEq(b)));}
\DoxyCodeLine{05229\ \}}
\DoxyCodeLine{05230\ }
\DoxyCodeLine{05231\ TEST(ContainerEqExtraTest,\ WorksForTwoDimensionalNativeArray)\ \{}
\DoxyCodeLine{05232\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ a1[][3]\ =\ \{\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}lo"{}}\};}
\DoxyCodeLine{05233\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ a2[][3]\ =\ \{\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}lo"{}}\};}
\DoxyCodeLine{05234\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ b[][3]\ =\ \{\textcolor{stringliteral}{"{}lo"{}},\ \textcolor{stringliteral}{"{}hi"{}}\};}
\DoxyCodeLine{05235\ }
\DoxyCodeLine{05236\ \ \ \textcolor{comment}{//\ Tests\ using\ ContainerEq()\ in\ the\ first\ dimension.}}
\DoxyCodeLine{05237\ \ \ EXPECT\_THAT(a1,\ ContainerEq(a2));}
\DoxyCodeLine{05238\ \ \ EXPECT\_THAT(a1,\ Not(ContainerEq(b)));}
\DoxyCodeLine{05239\ }
\DoxyCodeLine{05240\ \ \ \textcolor{comment}{//\ Tests\ using\ ContainerEq()\ in\ the\ second\ dimension.}}
\DoxyCodeLine{05241\ \ \ EXPECT\_THAT(a1,\ ElementsAre(ContainerEq(a2[0]),\ ContainerEq(a2[1])));}
\DoxyCodeLine{05242\ \ \ EXPECT\_THAT(a1,\ ElementsAre(Not(ContainerEq(b[0])),\ ContainerEq(a2[1])));}
\DoxyCodeLine{05243\ \}}
\DoxyCodeLine{05244\ }
\DoxyCodeLine{05245\ TEST(ContainerEqExtraTest,\ WorksForNativeArrayAsTuple)\ \{}
\DoxyCodeLine{05246\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a1[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{05247\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a2[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{05248\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ b[]\ =\ \{1,\ 2,\ 3,\ 4\};}
\DoxyCodeLine{05249\ }
\DoxyCodeLine{05250\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ \textcolor{keyword}{const}\ p1\ =\ a1;}
\DoxyCodeLine{05251\ \ \ EXPECT\_THAT(std::make\_tuple(p1,\ 3),\ ContainerEq(a2));}
\DoxyCodeLine{05252\ \ \ EXPECT\_THAT(std::make\_tuple(p1,\ 3),\ Not(ContainerEq(b)));}
\DoxyCodeLine{05253\ }
\DoxyCodeLine{05254\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ c[]\ =\ \{1,\ 3,\ 2\};}
\DoxyCodeLine{05255\ \ \ EXPECT\_THAT(std::make\_tuple(p1,\ 3),\ Not(ContainerEq(c)));}
\DoxyCodeLine{05256\ \}}
\DoxyCodeLine{05257\ }
\DoxyCodeLine{05258\ TEST(ContainerEqExtraTest,\ CopiesNativeArrayParameter)\ \{}
\DoxyCodeLine{05259\ \ \ std::string\ a1[][3]\ =\ \{}
\DoxyCodeLine{05260\ \ \ \ \ \{\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}hello"{}},\ \textcolor{stringliteral}{"{}ciao"{}}\},}
\DoxyCodeLine{05261\ \ \ \ \ \{\textcolor{stringliteral}{"{}bye"{}},\ \textcolor{stringliteral}{"{}see\ you"{}},\ \textcolor{stringliteral}{"{}ciao"{}}\}}
\DoxyCodeLine{05262\ \ \ \};}
\DoxyCodeLine{05263\ }
\DoxyCodeLine{05264\ \ \ std::string\ a2[][3]\ =\ \{}
\DoxyCodeLine{05265\ \ \ \ \ \{\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}hello"{}},\ \textcolor{stringliteral}{"{}ciao"{}}\},}
\DoxyCodeLine{05266\ \ \ \ \ \{\textcolor{stringliteral}{"{}bye"{}},\ \textcolor{stringliteral}{"{}see\ you"{}},\ \textcolor{stringliteral}{"{}ciao"{}}\}}
\DoxyCodeLine{05267\ \ \ \};}
\DoxyCodeLine{05268\ }
\DoxyCodeLine{05269\ \ \ \textcolor{keyword}{const}\ Matcher<\textcolor{keyword}{const}\ std::string(\&)[2][3]>\ m\ =\ ContainerEq(a2);}
\DoxyCodeLine{05270\ \ \ EXPECT\_THAT(a1,\ m);}
\DoxyCodeLine{05271\ }
\DoxyCodeLine{05272\ \ \ a2[0][0]\ =\ \textcolor{stringliteral}{"{}ha"{}};}
\DoxyCodeLine{05273\ \ \ EXPECT\_THAT(a1,\ m);}
\DoxyCodeLine{05274\ \}}
\DoxyCodeLine{05275\ }
\DoxyCodeLine{05276\ TEST(WhenSortedByTest,\ WorksForEmptyContainer)\ \{}
\DoxyCodeLine{05277\ \ \ \textcolor{keyword}{const}\ vector<int>\ numbers;}
\DoxyCodeLine{05278\ \ \ EXPECT\_THAT(numbers,\ WhenSortedBy(less<int>(),\ ElementsAre()));}
\DoxyCodeLine{05279\ \ \ EXPECT\_THAT(numbers,\ Not(WhenSortedBy(less<int>(),\ ElementsAre(1))));}
\DoxyCodeLine{05280\ \}}
\DoxyCodeLine{05281\ }
\DoxyCodeLine{05282\ TEST(WhenSortedByTest,\ WorksForNonEmptyContainer)\ \{}
\DoxyCodeLine{05283\ \ \ vector<unsigned>\ numbers;}
\DoxyCodeLine{05284\ \ \ numbers.push\_back(3);}
\DoxyCodeLine{05285\ \ \ numbers.push\_back(1);}
\DoxyCodeLine{05286\ \ \ numbers.push\_back(2);}
\DoxyCodeLine{05287\ \ \ numbers.push\_back(2);}
\DoxyCodeLine{05288\ \ \ EXPECT\_THAT(numbers,\ WhenSortedBy(greater<unsigned>(),}
\DoxyCodeLine{05289\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(3,\ 2,\ 2,\ 1)));}
\DoxyCodeLine{05290\ \ \ EXPECT\_THAT(numbers,\ Not(WhenSortedBy(greater<unsigned>(),}
\DoxyCodeLine{05291\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(1,\ 2,\ 2,\ 3))));}
\DoxyCodeLine{05292\ \}}
\DoxyCodeLine{05293\ }
\DoxyCodeLine{05294\ TEST(WhenSortedByTest,\ WorksForNonVectorContainer)\ \{}
\DoxyCodeLine{05295\ \ \ list<std::string>\ words;}
\DoxyCodeLine{05296\ \ \ words.push\_back(\textcolor{stringliteral}{"{}say"{}});}
\DoxyCodeLine{05297\ \ \ words.push\_back(\textcolor{stringliteral}{"{}hello"{}});}
\DoxyCodeLine{05298\ \ \ words.push\_back(\textcolor{stringliteral}{"{}world"{}});}
\DoxyCodeLine{05299\ \ \ EXPECT\_THAT(words,\ WhenSortedBy(less<std::string>(),}
\DoxyCodeLine{05300\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(\textcolor{stringliteral}{"{}hello"{}},\ \textcolor{stringliteral}{"{}say"{}},\ \textcolor{stringliteral}{"{}world"{}})));}
\DoxyCodeLine{05301\ \ \ EXPECT\_THAT(words,\ Not(WhenSortedBy(less<std::string>(),}
\DoxyCodeLine{05302\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(\textcolor{stringliteral}{"{}say"{}},\ \textcolor{stringliteral}{"{}hello"{}},\ \textcolor{stringliteral}{"{}world"{}}))));}
\DoxyCodeLine{05303\ \}}
\DoxyCodeLine{05304\ }
\DoxyCodeLine{05305\ TEST(WhenSortedByTest,\ WorksForNativeArray)\ \{}
\DoxyCodeLine{05306\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ numbers[]\ =\ \{1,\ 3,\ 2,\ 4\};}
\DoxyCodeLine{05307\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ sorted\_numbers[]\ =\ \{1,\ 2,\ 3,\ 4\};}
\DoxyCodeLine{05308\ \ \ EXPECT\_THAT(numbers,\ WhenSortedBy(less<int>(),\ ElementsAre(1,\ 2,\ 3,\ 4)));}
\DoxyCodeLine{05309\ \ \ EXPECT\_THAT(numbers,\ WhenSortedBy(less<int>(),}
\DoxyCodeLine{05310\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAreArray(sorted\_numbers)));}
\DoxyCodeLine{05311\ \ \ EXPECT\_THAT(numbers,\ Not(WhenSortedBy(less<int>(),\ ElementsAre(1,\ 3,\ 2,\ 4))));}
\DoxyCodeLine{05312\ \}}
\DoxyCodeLine{05313\ }
\DoxyCodeLine{05314\ TEST(WhenSortedByTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{05315\ \ \ \textcolor{keyword}{const}\ Matcher<vector<int>\ >\ m\ =\ WhenSortedBy(less<int>(),\ ElementsAre(1,\ 2));}
\DoxyCodeLine{05316\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(when\ sorted)\ has\ 2\ elements\ where\(\backslash\)n"{}}}
\DoxyCodeLine{05317\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#0\ is\ equal\ to\ 1,\(\backslash\)n"{}}}
\DoxyCodeLine{05318\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#1\ is\ equal\ to\ 2"{}},}
\DoxyCodeLine{05319\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{05320\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(when\ sorted)\ doesn't\ have\ 2\ elements,\ or\(\backslash\)n"{}}}
\DoxyCodeLine{05321\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#0\ isn't\ equal\ to\ 1,\ or\(\backslash\)n"{}}}
\DoxyCodeLine{05322\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#1\ isn't\ equal\ to\ 2"{}},}
\DoxyCodeLine{05323\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{05324\ \}}
\DoxyCodeLine{05325\ }
\DoxyCodeLine{05326\ TEST(WhenSortedByTest,\ ExplainsMatchResult)\ \{}
\DoxyCodeLine{05327\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{2,\ 1\};}
\DoxyCodeLine{05328\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ \{\ 1,\ 2\ \}\ when\ sorted,\ whose\ element\ \#0\ doesn't\ match"{}},}
\DoxyCodeLine{05329\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(WhenSortedBy(less<int>(),\ ElementsAre(2,\ 3)),\ a));}
\DoxyCodeLine{05330\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ \{\ 1,\ 2\ \}\ when\ sorted"{}},}
\DoxyCodeLine{05331\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(WhenSortedBy(less<int>(),\ ElementsAre(1,\ 2)),\ a));}
\DoxyCodeLine{05332\ \}}
\DoxyCodeLine{05333\ }
\DoxyCodeLine{05334\ \textcolor{comment}{//\ WhenSorted()\ is\ a\ simple\ wrapper\ on\ WhenSortedBy().\ \ Hence\ we\ don't}}
\DoxyCodeLine{05335\ \textcolor{comment}{//\ need\ to\ test\ it\ as\ exhaustively\ as\ we\ test\ the\ latter.}}
\DoxyCodeLine{05336\ }
\DoxyCodeLine{05337\ TEST(WhenSortedTest,\ WorksForEmptyContainer)\ \{}
\DoxyCodeLine{05338\ \ \ \textcolor{keyword}{const}\ vector<int>\ numbers;}
\DoxyCodeLine{05339\ \ \ EXPECT\_THAT(numbers,\ WhenSorted(ElementsAre()));}
\DoxyCodeLine{05340\ \ \ EXPECT\_THAT(numbers,\ Not(WhenSorted(ElementsAre(1))));}
\DoxyCodeLine{05341\ \}}
\DoxyCodeLine{05342\ }
\DoxyCodeLine{05343\ TEST(WhenSortedTest,\ WorksForNonEmptyContainer)\ \{}
\DoxyCodeLine{05344\ \ \ list<std::string>\ words;}
\DoxyCodeLine{05345\ \ \ words.push\_back(\textcolor{stringliteral}{"{}3"{}});}
\DoxyCodeLine{05346\ \ \ words.push\_back(\textcolor{stringliteral}{"{}1"{}});}
\DoxyCodeLine{05347\ \ \ words.push\_back(\textcolor{stringliteral}{"{}2"{}});}
\DoxyCodeLine{05348\ \ \ words.push\_back(\textcolor{stringliteral}{"{}2"{}});}
\DoxyCodeLine{05349\ \ \ EXPECT\_THAT(words,\ WhenSorted(ElementsAre(\textcolor{stringliteral}{"{}1"{}},\ \textcolor{stringliteral}{"{}2"{}},\ \textcolor{stringliteral}{"{}2"{}},\ \textcolor{stringliteral}{"{}3"{}})));}
\DoxyCodeLine{05350\ \ \ EXPECT\_THAT(words,\ Not(WhenSorted(ElementsAre(\textcolor{stringliteral}{"{}3"{}},\ \textcolor{stringliteral}{"{}1"{}},\ \textcolor{stringliteral}{"{}2"{}},\ \textcolor{stringliteral}{"{}2"{}}))));}
\DoxyCodeLine{05351\ \}}
\DoxyCodeLine{05352\ }
\DoxyCodeLine{05353\ TEST(WhenSortedTest,\ WorksForMapTypes)\ \{}
\DoxyCodeLine{05354\ \ \ map<std::string,\ int>\ word\_counts;}
\DoxyCodeLine{05355\ \ \ word\_counts[\textcolor{stringliteral}{"{}and"{}}]\ =\ 1;}
\DoxyCodeLine{05356\ \ \ word\_counts[\textcolor{stringliteral}{"{}the"{}}]\ =\ 1;}
\DoxyCodeLine{05357\ \ \ word\_counts[\textcolor{stringliteral}{"{}buffalo"{}}]\ =\ 2;}
\DoxyCodeLine{05358\ \ \ EXPECT\_THAT(word\_counts,}
\DoxyCodeLine{05359\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ WhenSorted(ElementsAre(Pair(\textcolor{stringliteral}{"{}and"{}},\ 1),\ Pair(\textcolor{stringliteral}{"{}buffalo"{}},\ 2),}
\DoxyCodeLine{05360\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(\textcolor{stringliteral}{"{}the"{}},\ 1))));}
\DoxyCodeLine{05361\ \ \ EXPECT\_THAT(word\_counts,}
\DoxyCodeLine{05362\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Not(WhenSorted(ElementsAre(Pair(\textcolor{stringliteral}{"{}and"{}},\ 1),\ Pair(\textcolor{stringliteral}{"{}the"{}},\ 1),}
\DoxyCodeLine{05363\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(\textcolor{stringliteral}{"{}buffalo"{}},\ 2)))));}
\DoxyCodeLine{05364\ \}}
\DoxyCodeLine{05365\ }
\DoxyCodeLine{05366\ TEST(WhenSortedTest,\ WorksForMultiMapTypes)\ \{}
\DoxyCodeLine{05367\ \ \ \ \ multimap<int,\ int>\ ifib;}
\DoxyCodeLine{05368\ \ \ \ \ ifib.insert(make\_pair(8,\ 6));}
\DoxyCodeLine{05369\ \ \ \ \ ifib.insert(make\_pair(2,\ 3));}
\DoxyCodeLine{05370\ \ \ \ \ ifib.insert(make\_pair(1,\ 1));}
\DoxyCodeLine{05371\ \ \ \ \ ifib.insert(make\_pair(3,\ 4));}
\DoxyCodeLine{05372\ \ \ \ \ ifib.insert(make\_pair(1,\ 2));}
\DoxyCodeLine{05373\ \ \ \ \ ifib.insert(make\_pair(5,\ 5));}
\DoxyCodeLine{05374\ \ \ \ \ EXPECT\_THAT(ifib,\ WhenSorted(ElementsAre(Pair(1,\ 1),}
\DoxyCodeLine{05375\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(1,\ 2),}
\DoxyCodeLine{05376\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(2,\ 3),}
\DoxyCodeLine{05377\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(3,\ 4),}
\DoxyCodeLine{05378\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(5,\ 5),}
\DoxyCodeLine{05379\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(8,\ 6))));}
\DoxyCodeLine{05380\ \ \ \ \ EXPECT\_THAT(ifib,\ Not(WhenSorted(ElementsAre(Pair(8,\ 6),}
\DoxyCodeLine{05381\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(2,\ 3),}
\DoxyCodeLine{05382\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(1,\ 1),}
\DoxyCodeLine{05383\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(3,\ 4),}
\DoxyCodeLine{05384\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(1,\ 2),}
\DoxyCodeLine{05385\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(5,\ 5)))));}
\DoxyCodeLine{05386\ \}}
\DoxyCodeLine{05387\ }
\DoxyCodeLine{05388\ TEST(WhenSortedTest,\ WorksForPolymorphicMatcher)\ \{}
\DoxyCodeLine{05389\ \ \ \ \ std::deque<int>\ d;}
\DoxyCodeLine{05390\ \ \ \ \ d.push\_back(2);}
\DoxyCodeLine{05391\ \ \ \ \ d.push\_back(1);}
\DoxyCodeLine{05392\ \ \ \ \ EXPECT\_THAT(d,\ WhenSorted(ElementsAre(1,\ 2)));}
\DoxyCodeLine{05393\ \ \ \ \ EXPECT\_THAT(d,\ Not(WhenSorted(ElementsAre(2,\ 1))));}
\DoxyCodeLine{05394\ \}}
\DoxyCodeLine{05395\ }
\DoxyCodeLine{05396\ TEST(WhenSortedTest,\ WorksForVectorConstRefMatcher)\ \{}
\DoxyCodeLine{05397\ \ \ \ \ std::deque<int>\ d;}
\DoxyCodeLine{05398\ \ \ \ \ d.push\_back(2);}
\DoxyCodeLine{05399\ \ \ \ \ d.push\_back(1);}
\DoxyCodeLine{05400\ \ \ \ \ Matcher<const\ std::vector<int>\&>\ vector\_match\ =\ ElementsAre(1,\ 2);}
\DoxyCodeLine{05401\ \ \ \ \ EXPECT\_THAT(d,\ WhenSorted(vector\_match));}
\DoxyCodeLine{05402\ \ \ \ \ Matcher<const\ std::vector<int>\&>\ not\_vector\_match\ =\ ElementsAre(2,\ 1);}
\DoxyCodeLine{05403\ \ \ \ \ EXPECT\_THAT(d,\ Not(WhenSorted(not\_vector\_match)));}
\DoxyCodeLine{05404\ \}}
\DoxyCodeLine{05405\ }
\DoxyCodeLine{05406\ \textcolor{comment}{//\ Deliberately\ bare\ pseudo-\/container.}}
\DoxyCodeLine{05407\ \textcolor{comment}{//\ Offers\ only\ begin()\ and\ end()\ accessors,\ yielding\ InputIterator.}}
\DoxyCodeLine{05408\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{05409\ \textcolor{keyword}{class\ }Streamlike\ \{}
\DoxyCodeLine{05410\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{05411\ \ \ \textcolor{keyword}{class\ }ConstIter;}
\DoxyCodeLine{05412\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05413\ \ \ \textcolor{keyword}{typedef}\ ConstIter\ const\_iterator;}
\DoxyCodeLine{05414\ \ \ \textcolor{keyword}{typedef}\ T\ value\_type;}
\DoxyCodeLine{05415\ }
\DoxyCodeLine{05416\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InIter>}
\DoxyCodeLine{05417\ \ \ Streamlike(InIter\ first,\ InIter\ last)\ :\ remainder\_(first,\ last)\ \{\}}
\DoxyCodeLine{05418\ }
\DoxyCodeLine{05419\ \ \ const\_iterator\ begin()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05420\ \ \ \ \ \textcolor{keywordflow}{return}\ const\_iterator(\textcolor{keyword}{this},\ remainder\_.begin());}
\DoxyCodeLine{05421\ \ \ \}}
\DoxyCodeLine{05422\ \ \ const\_iterator\ end()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{05423\ \ \ \ \ \textcolor{keywordflow}{return}\ const\_iterator(\textcolor{keyword}{this},\ remainder\_.end());}
\DoxyCodeLine{05424\ \ \ \}}
\DoxyCodeLine{05425\ }
\DoxyCodeLine{05426\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{05427\ \ \ \textcolor{keyword}{class\ }ConstIter\ :\ \textcolor{keyword}{public}\ std::iterator<std::input\_iterator\_tag,}
\DoxyCodeLine{05428\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ value\_type,}
\DoxyCodeLine{05429\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ptrdiff\_t,}
\DoxyCodeLine{05430\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ value\_type*,}
\DoxyCodeLine{05431\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ value\_type\&>\ \{}
\DoxyCodeLine{05432\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05433\ \ \ \ \ ConstIter(\textcolor{keyword}{const}\ Streamlike*\ s,}
\DoxyCodeLine{05434\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ std::list<value\_type>::iterator\ pos)}
\DoxyCodeLine{05435\ \ \ \ \ \ \ \ \ :\ s\_(s),\ pos\_(pos)\ \{\}}
\DoxyCodeLine{05436\ }
\DoxyCodeLine{05437\ \ \ \ \ \textcolor{keyword}{const}\ value\_type\&\ operator*()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ *pos\_;\ \}}
\DoxyCodeLine{05438\ \ \ \ \ \textcolor{keyword}{const}\ value\_type*\ operator-\/>()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \&*pos\_;\ \}}
\DoxyCodeLine{05439\ \ \ \ \ ConstIter\&\ operator++()\ \{}
\DoxyCodeLine{05440\ \ \ \ \ \ \ s\_-\/>remainder\_.erase(pos\_++);}
\DoxyCodeLine{05441\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{05442\ \ \ \ \ \}}
\DoxyCodeLine{05443\ }
\DoxyCodeLine{05444\ \ \ \ \ \textcolor{comment}{//\ *iter++\ is\ required\ to\ work\ (see\ std::istreambuf\_iterator).}}
\DoxyCodeLine{05445\ \ \ \ \ \textcolor{comment}{//\ (void)iter++\ is\ also\ required\ to\ work.}}
\DoxyCodeLine{05446\ \ \ \ \ \textcolor{keyword}{class\ }PostIncrProxy\ \{}
\DoxyCodeLine{05447\ \ \ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{05448\ \ \ \ \ \ \ \textcolor{keyword}{explicit}\ PostIncrProxy(\textcolor{keyword}{const}\ value\_type\&\ value)\ :\ value\_(value)\ \{\}}
\DoxyCodeLine{05449\ \ \ \ \ \ \ value\_type\ operator*()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ value\_;\ \}}
\DoxyCodeLine{05450\ \ \ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{05451\ \ \ \ \ \ \ value\_type\ value\_;}
\DoxyCodeLine{05452\ \ \ \ \ \};}
\DoxyCodeLine{05453\ \ \ \ \ PostIncrProxy\ operator++(\textcolor{keywordtype}{int})\ \{}
\DoxyCodeLine{05454\ \ \ \ \ \ \ PostIncrProxy\ proxy(**\textcolor{keyword}{this});}
\DoxyCodeLine{05455\ \ \ \ \ \ \ ++(*this);}
\DoxyCodeLine{05456\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ proxy;}
\DoxyCodeLine{05457\ \ \ \ \ \}}
\DoxyCodeLine{05458\ }
\DoxyCodeLine{05459\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keywordtype}{bool}\ operator==(\textcolor{keyword}{const}\ ConstIter\&\ a,\ \textcolor{keyword}{const}\ ConstIter\&\ b)\ \{}
\DoxyCodeLine{05460\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ a.s\_\ ==\ b.s\_\ \&\&\ a.pos\_\ ==\ b.pos\_;}
\DoxyCodeLine{05461\ \ \ \ \ \}}
\DoxyCodeLine{05462\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keywordtype}{bool}\ operator!=(\textcolor{keyword}{const}\ ConstIter\&\ a,\ \textcolor{keyword}{const}\ ConstIter\&\ b)\ \{}
\DoxyCodeLine{05463\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ !(a\ ==\ b);}
\DoxyCodeLine{05464\ \ \ \ \ \}}
\DoxyCodeLine{05465\ }
\DoxyCodeLine{05466\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{05467\ \ \ \ \ \textcolor{keyword}{const}\ Streamlike*\ s\_;}
\DoxyCodeLine{05468\ \ \ \ \ \textcolor{keyword}{typename}\ std::list<value\_type>::iterator\ pos\_;}
\DoxyCodeLine{05469\ \ \ \};}
\DoxyCodeLine{05470\ }
\DoxyCodeLine{05471\ \ \ \textcolor{keyword}{friend}\ std::ostream\&\ operator<<(std::ostream\&\ os,\ \textcolor{keyword}{const}\ Streamlike\&\ s)\ \{}
\DoxyCodeLine{05472\ \ \ \ \ os\ <<\ \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{05473\ \ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ std::list<value\_type>::const\_iterator\ Iter;}
\DoxyCodeLine{05474\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ sep\ =\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{05475\ \ \ \ \ \textcolor{keywordflow}{for}\ (Iter\ it\ =\ s.remainder\_.begin();\ it\ !=\ s.remainder\_.end();\ ++it)\ \{}
\DoxyCodeLine{05476\ \ \ \ \ \ \ os\ <<\ sep\ <<\ *it;}
\DoxyCodeLine{05477\ \ \ \ \ \ \ sep\ =\ \textcolor{stringliteral}{"{},"{}};}
\DoxyCodeLine{05478\ \ \ \ \ \}}
\DoxyCodeLine{05479\ \ \ \ \ os\ <<\ \textcolor{stringliteral}{"{}]"{}};}
\DoxyCodeLine{05480\ \ \ \ \ \textcolor{keywordflow}{return}\ os;}
\DoxyCodeLine{05481\ \ \ \}}
\DoxyCodeLine{05482\ }
\DoxyCodeLine{05483\ \ \ \textcolor{keyword}{mutable}\ std::list<value\_type>\ remainder\_;\ \ \textcolor{comment}{//\ modified\ by\ iteration}}
\DoxyCodeLine{05484\ \};}
\DoxyCodeLine{05485\ }
\DoxyCodeLine{05486\ TEST(StreamlikeTest,\ Iteration)\ \{}
\DoxyCodeLine{05487\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{2,\ 1,\ 4,\ 5,\ 3\};}
\DoxyCodeLine{05488\ \ \ Streamlike<int>\ s(a,\ a\ +\ 5);}
\DoxyCodeLine{05489\ \ \ Streamlike<int>::const\_iterator\ it\ =\ s.begin();}
\DoxyCodeLine{05490\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ ip\ =\ a;}
\DoxyCodeLine{05491\ \ \ \textcolor{keywordflow}{while}\ (it\ !=\ s.end())\ \{}
\DoxyCodeLine{05492\ \ \ \ \ SCOPED\_TRACE(ip\ -\/\ a);}
\DoxyCodeLine{05493\ \ \ \ \ EXPECT\_EQ(*ip++,\ *it++);}
\DoxyCodeLine{05494\ \ \ \}}
\DoxyCodeLine{05495\ \}}
\DoxyCodeLine{05496\ }
\DoxyCodeLine{05497\ TEST(BeginEndDistanceIsTest,\ WorksWithForwardList)\ \{}
\DoxyCodeLine{05498\ \ \ std::forward\_list<int>\ container;}
\DoxyCodeLine{05499\ \ \ EXPECT\_THAT(container,\ BeginEndDistanceIs(0));}
\DoxyCodeLine{05500\ \ \ EXPECT\_THAT(container,\ Not(BeginEndDistanceIs(1)));}
\DoxyCodeLine{05501\ \ \ container.push\_front(0);}
\DoxyCodeLine{05502\ \ \ EXPECT\_THAT(container,\ Not(BeginEndDistanceIs(0)));}
\DoxyCodeLine{05503\ \ \ EXPECT\_THAT(container,\ BeginEndDistanceIs(1));}
\DoxyCodeLine{05504\ \ \ container.push\_front(0);}
\DoxyCodeLine{05505\ \ \ EXPECT\_THAT(container,\ Not(BeginEndDistanceIs(0)));}
\DoxyCodeLine{05506\ \ \ EXPECT\_THAT(container,\ BeginEndDistanceIs(2));}
\DoxyCodeLine{05507\ \}}
\DoxyCodeLine{05508\ }
\DoxyCodeLine{05509\ TEST(BeginEndDistanceIsTest,\ WorksWithNonStdList)\ \{}
\DoxyCodeLine{05510\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{1,\ 2,\ 3,\ 4,\ 5\};}
\DoxyCodeLine{05511\ \ \ Streamlike<int>\ s(a,\ a\ +\ 5);}
\DoxyCodeLine{05512\ \ \ EXPECT\_THAT(s,\ BeginEndDistanceIs(5));}
\DoxyCodeLine{05513\ \}}
\DoxyCodeLine{05514\ }
\DoxyCodeLine{05515\ TEST(BeginEndDistanceIsTest,\ CanDescribeSelf)\ \{}
\DoxyCodeLine{05516\ \ \ Matcher<vector<int>\ >\ m\ =\ BeginEndDistanceIs(2);}
\DoxyCodeLine{05517\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}distance\ between\ begin()\ and\ end()\ is\ equal\ to\ 2"{}},\ Describe(m));}
\DoxyCodeLine{05518\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}distance\ between\ begin()\ and\ end()\ isn't\ equal\ to\ 2"{}},}
\DoxyCodeLine{05519\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{05520\ \}}
\DoxyCodeLine{05521\ }
\DoxyCodeLine{05522\ TEST(BeginEndDistanceIsTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{05523\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{05524\ \ \ EXPECT\_CALL(helper,\ Call(BeginEndDistanceIs(2)));}
\DoxyCodeLine{05525\ \ \ helper.Call(MakeUniquePtrs(\{1,\ 2\}));}
\DoxyCodeLine{05526\ \}}
\DoxyCodeLine{05527\ }
\DoxyCodeLine{05528\ TEST(BeginEndDistanceIsTest,\ ExplainsResult)\ \{}
\DoxyCodeLine{05529\ \ \ Matcher<vector<int>\ >\ m1\ =\ BeginEndDistanceIs(2);}
\DoxyCodeLine{05530\ \ \ Matcher<vector<int>\ >\ m2\ =\ BeginEndDistanceIs(Lt(2));}
\DoxyCodeLine{05531\ \ \ Matcher<vector<int>\ >\ m3\ =\ BeginEndDistanceIs(AnyOf(0,\ 3));}
\DoxyCodeLine{05532\ \ \ Matcher<vector<int>\ >\ m4\ =\ BeginEndDistanceIs(GreaterThan(1));}
\DoxyCodeLine{05533\ \ \ vector<int>\ container;}
\DoxyCodeLine{05534\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ 0\ doesn't\ match"{}},}
\DoxyCodeLine{05535\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m1,\ container));}
\DoxyCodeLine{05536\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ 0\ matches"{}},}
\DoxyCodeLine{05537\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m2,\ container));}
\DoxyCodeLine{05538\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ 0\ matches"{}},}
\DoxyCodeLine{05539\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m3,\ container));}
\DoxyCodeLine{05540\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{05541\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ 0\ doesn't\ match,\ which\ is\ 1\ "{}}}
\DoxyCodeLine{05542\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}less\ than\ 1"{}},}
\DoxyCodeLine{05543\ \ \ \ \ \ \ Explain(m4,\ container));}
\DoxyCodeLine{05544\ \ \ container.push\_back(0);}
\DoxyCodeLine{05545\ \ \ container.push\_back(0);}
\DoxyCodeLine{05546\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ 2\ matches"{}},}
\DoxyCodeLine{05547\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m1,\ container));}
\DoxyCodeLine{05548\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ 2\ doesn't\ match"{}},}
\DoxyCodeLine{05549\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m2,\ container));}
\DoxyCodeLine{05550\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ 2\ doesn't\ match"{}},}
\DoxyCodeLine{05551\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m3,\ container));}
\DoxyCodeLine{05552\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{05553\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ distance\ between\ begin()\ and\ end()\ 2\ matches,\ which\ is\ 1\ more\ "{}}}
\DoxyCodeLine{05554\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}than\ 1"{}},}
\DoxyCodeLine{05555\ \ \ \ \ \ \ Explain(m4,\ container));}
\DoxyCodeLine{05556\ \}}
\DoxyCodeLine{05557\ }
\DoxyCodeLine{05558\ TEST(WhenSortedTest,\ WorksForStreamlike)\ \{}
\DoxyCodeLine{05559\ \ \ \textcolor{comment}{//\ Streamlike\ 'container'\ provides\ only\ minimal\ iterator\ support.}}
\DoxyCodeLine{05560\ \ \ \textcolor{comment}{//\ Its\ iterators\ are\ tagged\ with\ input\_iterator\_tag.}}
\DoxyCodeLine{05561\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{2,\ 1,\ 4,\ 5,\ 3\};}
\DoxyCodeLine{05562\ \ \ Streamlike<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05563\ \ \ EXPECT\_THAT(s,\ WhenSorted(ElementsAre(1,\ 2,\ 3,\ 4,\ 5)));}
\DoxyCodeLine{05564\ \ \ EXPECT\_THAT(s,\ Not(WhenSorted(ElementsAre(2,\ 1,\ 4,\ 5,\ 3))));}
\DoxyCodeLine{05565\ \}}
\DoxyCodeLine{05566\ }
\DoxyCodeLine{05567\ TEST(WhenSortedTest,\ WorksForVectorConstRefMatcherOnStreamlike)\ \{}
\DoxyCodeLine{05568\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{2,\ 1,\ 4,\ 5,\ 3\};}
\DoxyCodeLine{05569\ \ \ Streamlike<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05570\ \ \ Matcher<const\ std::vector<int>\&>\ vector\_match\ =\ ElementsAre(1,\ 2,\ 3,\ 4,\ 5);}
\DoxyCodeLine{05571\ \ \ EXPECT\_THAT(s,\ WhenSorted(vector\_match));}
\DoxyCodeLine{05572\ \ \ EXPECT\_THAT(s,\ Not(WhenSorted(ElementsAre(2,\ 1,\ 4,\ 5,\ 3))));}
\DoxyCodeLine{05573\ \}}
\DoxyCodeLine{05574\ }
\DoxyCodeLine{05575\ TEST(IsSupersetOfTest,\ WorksForNativeArray)\ \{}
\DoxyCodeLine{05576\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ subset[]\ =\ \{1,\ 4\};}
\DoxyCodeLine{05577\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ superset[]\ =\ \{1,\ 2,\ 4\};}
\DoxyCodeLine{05578\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ disjoint[]\ =\ \{1,\ 0,\ 3\};}
\DoxyCodeLine{05579\ \ \ EXPECT\_THAT(subset,\ IsSupersetOf(subset));}
\DoxyCodeLine{05580\ \ \ EXPECT\_THAT(subset,\ Not(IsSupersetOf(superset)));}
\DoxyCodeLine{05581\ \ \ EXPECT\_THAT(superset,\ IsSupersetOf(subset));}
\DoxyCodeLine{05582\ \ \ EXPECT\_THAT(subset,\ Not(IsSupersetOf(disjoint)));}
\DoxyCodeLine{05583\ \ \ EXPECT\_THAT(disjoint,\ Not(IsSupersetOf(subset)));}
\DoxyCodeLine{05584\ \}}
\DoxyCodeLine{05585\ }
\DoxyCodeLine{05586\ TEST(IsSupersetOfTest,\ WorksWithDuplicates)\ \{}
\DoxyCodeLine{05587\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ not\_enough[]\ =\ \{1,\ 2\};}
\DoxyCodeLine{05588\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ enough[]\ =\ \{1,\ 1,\ 2\};}
\DoxyCodeLine{05589\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ expected[]\ =\ \{1,\ 1\};}
\DoxyCodeLine{05590\ \ \ EXPECT\_THAT(not\_enough,\ Not(IsSupersetOf(expected)));}
\DoxyCodeLine{05591\ \ \ EXPECT\_THAT(enough,\ IsSupersetOf(expected));}
\DoxyCodeLine{05592\ \}}
\DoxyCodeLine{05593\ }
\DoxyCodeLine{05594\ TEST(IsSupersetOfTest,\ WorksForEmpty)\ \{}
\DoxyCodeLine{05595\ \ \ vector<int>\ numbers;}
\DoxyCodeLine{05596\ \ \ vector<int>\ expected;}
\DoxyCodeLine{05597\ \ \ EXPECT\_THAT(numbers,\ IsSupersetOf(expected));}
\DoxyCodeLine{05598\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05599\ \ \ EXPECT\_THAT(numbers,\ Not(IsSupersetOf(expected)));}
\DoxyCodeLine{05600\ \ \ expected.clear();}
\DoxyCodeLine{05601\ \ \ numbers.push\_back(1);}
\DoxyCodeLine{05602\ \ \ numbers.push\_back(2);}
\DoxyCodeLine{05603\ \ \ EXPECT\_THAT(numbers,\ IsSupersetOf(expected));}
\DoxyCodeLine{05604\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05605\ \ \ EXPECT\_THAT(numbers,\ IsSupersetOf(expected));}
\DoxyCodeLine{05606\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05607\ \ \ EXPECT\_THAT(numbers,\ IsSupersetOf(expected));}
\DoxyCodeLine{05608\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05609\ \ \ EXPECT\_THAT(numbers,\ Not(IsSupersetOf(expected)));}
\DoxyCodeLine{05610\ \}}
\DoxyCodeLine{05611\ }
\DoxyCodeLine{05612\ TEST(IsSupersetOfTest,\ WorksForStreamlike)\ \{}
\DoxyCodeLine{05613\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{1,\ 2,\ 3,\ 4,\ 5\};}
\DoxyCodeLine{05614\ \ \ Streamlike<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05615\ }
\DoxyCodeLine{05616\ \ \ vector<int>\ expected;}
\DoxyCodeLine{05617\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05618\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05619\ \ \ expected.push\_back(5);}
\DoxyCodeLine{05620\ \ \ EXPECT\_THAT(s,\ IsSupersetOf(expected));}
\DoxyCodeLine{05621\ }
\DoxyCodeLine{05622\ \ \ expected.push\_back(0);}
\DoxyCodeLine{05623\ \ \ EXPECT\_THAT(s,\ Not(IsSupersetOf(expected)));}
\DoxyCodeLine{05624\ \}}
\DoxyCodeLine{05625\ }
\DoxyCodeLine{05626\ TEST(IsSupersetOfTest,\ TakesStlContainer)\ \{}
\DoxyCodeLine{05627\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ actual[]\ =\ \{3,\ 1,\ 2\};}
\DoxyCodeLine{05628\ }
\DoxyCodeLine{05629\ \ \ ::std::list<int>\ expected;}
\DoxyCodeLine{05630\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05631\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05632\ \ \ EXPECT\_THAT(actual,\ IsSupersetOf(expected));}
\DoxyCodeLine{05633\ }
\DoxyCodeLine{05634\ \ \ expected.push\_back(4);}
\DoxyCodeLine{05635\ \ \ EXPECT\_THAT(actual,\ Not(IsSupersetOf(expected)));}
\DoxyCodeLine{05636\ \}}
\DoxyCodeLine{05637\ }
\DoxyCodeLine{05638\ TEST(IsSupersetOfTest,\ Describe)\ \{}
\DoxyCodeLine{05639\ \ \ \textcolor{keyword}{typedef}\ std::vector<int>\ IntVec;}
\DoxyCodeLine{05640\ \ \ IntVec\ expected;}
\DoxyCodeLine{05641\ \ \ expected.push\_back(111);}
\DoxyCodeLine{05642\ \ \ expected.push\_back(222);}
\DoxyCodeLine{05643\ \ \ expected.push\_back(333);}
\DoxyCodeLine{05644\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{05645\ \ \ \ \ \ \ Describe<IntVec>(IsSupersetOf(expected)),}
\DoxyCodeLine{05646\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}a\ surjection\ from\ elements\ to\ requirements\ exists\ such\ that:\(\backslash\)n"{}}}
\DoxyCodeLine{05647\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 111\(\backslash\)n"{}}}
\DoxyCodeLine{05648\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 222\(\backslash\)n"{}}}
\DoxyCodeLine{05649\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 333"{}}));}
\DoxyCodeLine{05650\ \}}
\DoxyCodeLine{05651\ }
\DoxyCodeLine{05652\ TEST(IsSupersetOfTest,\ DescribeNegation)\ \{}
\DoxyCodeLine{05653\ \ \ \textcolor{keyword}{typedef}\ std::vector<int>\ IntVec;}
\DoxyCodeLine{05654\ \ \ IntVec\ expected;}
\DoxyCodeLine{05655\ \ \ expected.push\_back(111);}
\DoxyCodeLine{05656\ \ \ expected.push\_back(222);}
\DoxyCodeLine{05657\ \ \ expected.push\_back(333);}
\DoxyCodeLine{05658\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{05659\ \ \ \ \ \ \ DescribeNegation<IntVec>(IsSupersetOf(expected)),}
\DoxyCodeLine{05660\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}no\ surjection\ from\ elements\ to\ requirements\ exists\ such\ that:\(\backslash\)n"{}}}
\DoxyCodeLine{05661\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 111\(\backslash\)n"{}}}
\DoxyCodeLine{05662\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 222\(\backslash\)n"{}}}
\DoxyCodeLine{05663\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 333"{}}));}
\DoxyCodeLine{05664\ \}}
\DoxyCodeLine{05665\ }
\DoxyCodeLine{05666\ TEST(IsSupersetOfTest,\ MatchAndExplain)\ \{}
\DoxyCodeLine{05667\ \ \ std::vector<int>\ v;}
\DoxyCodeLine{05668\ \ \ v.push\_back(2);}
\DoxyCodeLine{05669\ \ \ v.push\_back(3);}
\DoxyCodeLine{05670\ \ \ std::vector<int>\ expected;}
\DoxyCodeLine{05671\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05672\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05673\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{05674\ \ \ ASSERT\_FALSE(ExplainMatchResult(IsSupersetOf(expected),\ v,\ \&listener))}
\DoxyCodeLine{05675\ \ \ \ \ \ \ <<\ listener.str();}
\DoxyCodeLine{05676\ \ \ EXPECT\_THAT(listener.str(),}
\DoxyCodeLine{05677\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}where\ the\ following\ matchers\ don't\ match\ any\ elements:\(\backslash\)n"{}}}
\DoxyCodeLine{05678\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}matcher\ \#0:\ is\ equal\ to\ 1"{}}));}
\DoxyCodeLine{05679\ }
\DoxyCodeLine{05680\ \ \ v.push\_back(1);}
\DoxyCodeLine{05681\ \ \ listener.Clear();}
\DoxyCodeLine{05682\ \ \ ASSERT\_TRUE(ExplainMatchResult(IsSupersetOf(expected),\ v,\ \&listener))}
\DoxyCodeLine{05683\ \ \ \ \ \ \ <<\ listener.str();}
\DoxyCodeLine{05684\ \ \ EXPECT\_THAT(listener.str(),\ Eq(\textcolor{stringliteral}{"{}where:\(\backslash\)n"{}}}
\DoxyCodeLine{05685\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#0\ is\ matched\ by\ matcher\ \#1,\(\backslash\)n"{}}}
\DoxyCodeLine{05686\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#2\ is\ matched\ by\ matcher\ \#0"{}}));}
\DoxyCodeLine{05687\ \}}
\DoxyCodeLine{05688\ }
\DoxyCodeLine{05689\ TEST(IsSupersetOfTest,\ WorksForRhsInitializerList)\ \{}
\DoxyCodeLine{05690\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ numbers[]\ =\ \{1,\ 3,\ 6,\ 2,\ 4,\ 5\};}
\DoxyCodeLine{05691\ \ \ EXPECT\_THAT(numbers,\ IsSupersetOf(\{1,\ 2\}));}
\DoxyCodeLine{05692\ \ \ EXPECT\_THAT(numbers,\ Not(IsSupersetOf(\{3,\ 0\})));}
\DoxyCodeLine{05693\ \}}
\DoxyCodeLine{05694\ }
\DoxyCodeLine{05695\ TEST(IsSupersetOfTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{05696\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{05697\ \ \ EXPECT\_CALL(helper,\ Call(IsSupersetOf(\{Pointee(1)\})));}
\DoxyCodeLine{05698\ \ \ helper.Call(MakeUniquePtrs(\{1,\ 2\}));}
\DoxyCodeLine{05699\ \ \ EXPECT\_CALL(helper,\ Call(Not(IsSupersetOf(\{Pointee(1),\ Pointee(2)\}))));}
\DoxyCodeLine{05700\ \ \ helper.Call(MakeUniquePtrs(\{2\}));}
\DoxyCodeLine{05701\ \}}
\DoxyCodeLine{05702\ }
\DoxyCodeLine{05703\ TEST(IsSubsetOfTest,\ WorksForNativeArray)\ \{}
\DoxyCodeLine{05704\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ subset[]\ =\ \{1,\ 4\};}
\DoxyCodeLine{05705\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ superset[]\ =\ \{1,\ 2,\ 4\};}
\DoxyCodeLine{05706\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ disjoint[]\ =\ \{1,\ 0,\ 3\};}
\DoxyCodeLine{05707\ \ \ EXPECT\_THAT(subset,\ IsSubsetOf(subset));}
\DoxyCodeLine{05708\ \ \ EXPECT\_THAT(subset,\ IsSubsetOf(superset));}
\DoxyCodeLine{05709\ \ \ EXPECT\_THAT(superset,\ Not(IsSubsetOf(subset)));}
\DoxyCodeLine{05710\ \ \ EXPECT\_THAT(subset,\ Not(IsSubsetOf(disjoint)));}
\DoxyCodeLine{05711\ \ \ EXPECT\_THAT(disjoint,\ Not(IsSubsetOf(subset)));}
\DoxyCodeLine{05712\ \}}
\DoxyCodeLine{05713\ }
\DoxyCodeLine{05714\ TEST(IsSubsetOfTest,\ WorksWithDuplicates)\ \{}
\DoxyCodeLine{05715\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ not\_enough[]\ =\ \{1,\ 2\};}
\DoxyCodeLine{05716\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ enough[]\ =\ \{1,\ 1,\ 2\};}
\DoxyCodeLine{05717\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ actual[]\ =\ \{1,\ 1\};}
\DoxyCodeLine{05718\ \ \ EXPECT\_THAT(actual,\ Not(IsSubsetOf(not\_enough)));}
\DoxyCodeLine{05719\ \ \ EXPECT\_THAT(actual,\ IsSubsetOf(enough));}
\DoxyCodeLine{05720\ \}}
\DoxyCodeLine{05721\ }
\DoxyCodeLine{05722\ TEST(IsSubsetOfTest,\ WorksForEmpty)\ \{}
\DoxyCodeLine{05723\ \ \ vector<int>\ numbers;}
\DoxyCodeLine{05724\ \ \ vector<int>\ expected;}
\DoxyCodeLine{05725\ \ \ EXPECT\_THAT(numbers,\ IsSubsetOf(expected));}
\DoxyCodeLine{05726\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05727\ \ \ EXPECT\_THAT(numbers,\ IsSubsetOf(expected));}
\DoxyCodeLine{05728\ \ \ expected.clear();}
\DoxyCodeLine{05729\ \ \ numbers.push\_back(1);}
\DoxyCodeLine{05730\ \ \ numbers.push\_back(2);}
\DoxyCodeLine{05731\ \ \ EXPECT\_THAT(numbers,\ Not(IsSubsetOf(expected)));}
\DoxyCodeLine{05732\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05733\ \ \ EXPECT\_THAT(numbers,\ Not(IsSubsetOf(expected)));}
\DoxyCodeLine{05734\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05735\ \ \ EXPECT\_THAT(numbers,\ IsSubsetOf(expected));}
\DoxyCodeLine{05736\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05737\ \ \ EXPECT\_THAT(numbers,\ IsSubsetOf(expected));}
\DoxyCodeLine{05738\ \}}
\DoxyCodeLine{05739\ }
\DoxyCodeLine{05740\ TEST(IsSubsetOfTest,\ WorksForStreamlike)\ \{}
\DoxyCodeLine{05741\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{1,\ 2\};}
\DoxyCodeLine{05742\ \ \ Streamlike<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05743\ }
\DoxyCodeLine{05744\ \ \ vector<int>\ expected;}
\DoxyCodeLine{05745\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05746\ \ \ EXPECT\_THAT(s,\ Not(IsSubsetOf(expected)));}
\DoxyCodeLine{05747\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05748\ \ \ expected.push\_back(5);}
\DoxyCodeLine{05749\ \ \ EXPECT\_THAT(s,\ IsSubsetOf(expected));}
\DoxyCodeLine{05750\ \}}
\DoxyCodeLine{05751\ }
\DoxyCodeLine{05752\ TEST(IsSubsetOfTest,\ TakesStlContainer)\ \{}
\DoxyCodeLine{05753\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ actual[]\ =\ \{3,\ 1,\ 2\};}
\DoxyCodeLine{05754\ }
\DoxyCodeLine{05755\ \ \ ::std::list<int>\ expected;}
\DoxyCodeLine{05756\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05757\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05758\ \ \ EXPECT\_THAT(actual,\ Not(IsSubsetOf(expected)));}
\DoxyCodeLine{05759\ }
\DoxyCodeLine{05760\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05761\ \ \ expected.push\_back(4);}
\DoxyCodeLine{05762\ \ \ EXPECT\_THAT(actual,\ IsSubsetOf(expected));}
\DoxyCodeLine{05763\ \}}
\DoxyCodeLine{05764\ }
\DoxyCodeLine{05765\ TEST(IsSubsetOfTest,\ Describe)\ \{}
\DoxyCodeLine{05766\ \ \ \textcolor{keyword}{typedef}\ std::vector<int>\ IntVec;}
\DoxyCodeLine{05767\ \ \ IntVec\ expected;}
\DoxyCodeLine{05768\ \ \ expected.push\_back(111);}
\DoxyCodeLine{05769\ \ \ expected.push\_back(222);}
\DoxyCodeLine{05770\ \ \ expected.push\_back(333);}
\DoxyCodeLine{05771\ }
\DoxyCodeLine{05772\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{05773\ \ \ \ \ \ \ Describe<IntVec>(IsSubsetOf(expected)),}
\DoxyCodeLine{05774\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}an\ injection\ from\ elements\ to\ requirements\ exists\ such\ that:\(\backslash\)n"{}}}
\DoxyCodeLine{05775\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 111\(\backslash\)n"{}}}
\DoxyCodeLine{05776\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 222\(\backslash\)n"{}}}
\DoxyCodeLine{05777\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 333"{}}));}
\DoxyCodeLine{05778\ \}}
\DoxyCodeLine{05779\ }
\DoxyCodeLine{05780\ TEST(IsSubsetOfTest,\ DescribeNegation)\ \{}
\DoxyCodeLine{05781\ \ \ \textcolor{keyword}{typedef}\ std::vector<int>\ IntVec;}
\DoxyCodeLine{05782\ \ \ IntVec\ expected;}
\DoxyCodeLine{05783\ \ \ expected.push\_back(111);}
\DoxyCodeLine{05784\ \ \ expected.push\_back(222);}
\DoxyCodeLine{05785\ \ \ expected.push\_back(333);}
\DoxyCodeLine{05786\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{05787\ \ \ \ \ \ \ DescribeNegation<IntVec>(IsSubsetOf(expected)),}
\DoxyCodeLine{05788\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}no\ injection\ from\ elements\ to\ requirements\ exists\ such\ that:\(\backslash\)n"{}}}
\DoxyCodeLine{05789\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 111\(\backslash\)n"{}}}
\DoxyCodeLine{05790\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 222\(\backslash\)n"{}}}
\DoxyCodeLine{05791\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ an\ element\ is\ equal\ to\ 333"{}}));}
\DoxyCodeLine{05792\ \}}
\DoxyCodeLine{05793\ }
\DoxyCodeLine{05794\ TEST(IsSubsetOfTest,\ MatchAndExplain)\ \{}
\DoxyCodeLine{05795\ \ \ std::vector<int>\ v;}
\DoxyCodeLine{05796\ \ \ v.push\_back(2);}
\DoxyCodeLine{05797\ \ \ v.push\_back(3);}
\DoxyCodeLine{05798\ \ \ std::vector<int>\ expected;}
\DoxyCodeLine{05799\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05800\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05801\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{05802\ \ \ ASSERT\_FALSE(ExplainMatchResult(IsSubsetOf(expected),\ v,\ \&listener))}
\DoxyCodeLine{05803\ \ \ \ \ \ \ <<\ listener.str();}
\DoxyCodeLine{05804\ \ \ EXPECT\_THAT(listener.str(),}
\DoxyCodeLine{05805\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}where\ the\ following\ elements\ don't\ match\ any\ matchers:\(\backslash\)n"{}}}
\DoxyCodeLine{05806\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#1:\ 3"{}}));}
\DoxyCodeLine{05807\ }
\DoxyCodeLine{05808\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05809\ \ \ listener.Clear();}
\DoxyCodeLine{05810\ \ \ ASSERT\_TRUE(ExplainMatchResult(IsSubsetOf(expected),\ v,\ \&listener))}
\DoxyCodeLine{05811\ \ \ \ \ \ \ <<\ listener.str();}
\DoxyCodeLine{05812\ \ \ EXPECT\_THAT(listener.str(),\ Eq(\textcolor{stringliteral}{"{}where:\(\backslash\)n"{}}}
\DoxyCodeLine{05813\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#0\ is\ matched\ by\ matcher\ \#1,\(\backslash\)n"{}}}
\DoxyCodeLine{05814\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#1\ is\ matched\ by\ matcher\ \#2"{}}));}
\DoxyCodeLine{05815\ \}}
\DoxyCodeLine{05816\ }
\DoxyCodeLine{05817\ TEST(IsSubsetOfTest,\ WorksForRhsInitializerList)\ \{}
\DoxyCodeLine{05818\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ numbers[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{05819\ \ \ EXPECT\_THAT(numbers,\ IsSubsetOf(\{1,\ 2,\ 3,\ 4\}));}
\DoxyCodeLine{05820\ \ \ EXPECT\_THAT(numbers,\ Not(IsSubsetOf(\{1,\ 2\})));}
\DoxyCodeLine{05821\ \}}
\DoxyCodeLine{05822\ }
\DoxyCodeLine{05823\ TEST(IsSubsetOfTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{05824\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{05825\ \ \ EXPECT\_CALL(helper,\ Call(IsSubsetOf(\{Pointee(1),\ Pointee(2)\})));}
\DoxyCodeLine{05826\ \ \ helper.Call(MakeUniquePtrs(\{1\}));}
\DoxyCodeLine{05827\ \ \ EXPECT\_CALL(helper,\ Call(Not(IsSubsetOf(\{Pointee(1)\}))));}
\DoxyCodeLine{05828\ \ \ helper.Call(MakeUniquePtrs(\{2\}));}
\DoxyCodeLine{05829\ \}}
\DoxyCodeLine{05830\ }
\DoxyCodeLine{05831\ \textcolor{comment}{//\ Tests\ using\ ElementsAre()\ and\ ElementsAreArray()\ with\ stream-\/like}}
\DoxyCodeLine{05832\ \textcolor{comment}{//\ "{}containers"{}.}}
\DoxyCodeLine{05833\ }
\DoxyCodeLine{05834\ TEST(ElemensAreStreamTest,\ WorksForStreamlike)\ \{}
\DoxyCodeLine{05835\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{1,\ 2,\ 3,\ 4,\ 5\};}
\DoxyCodeLine{05836\ \ \ Streamlike<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05837\ \ \ EXPECT\_THAT(s,\ ElementsAre(1,\ 2,\ 3,\ 4,\ 5));}
\DoxyCodeLine{05838\ \ \ EXPECT\_THAT(s,\ Not(ElementsAre(2,\ 1,\ 4,\ 5,\ 3)));}
\DoxyCodeLine{05839\ \}}
\DoxyCodeLine{05840\ }
\DoxyCodeLine{05841\ TEST(ElemensAreArrayStreamTest,\ WorksForStreamlike)\ \{}
\DoxyCodeLine{05842\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{1,\ 2,\ 3,\ 4,\ 5\};}
\DoxyCodeLine{05843\ \ \ Streamlike<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05844\ }
\DoxyCodeLine{05845\ \ \ vector<int>\ expected;}
\DoxyCodeLine{05846\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05847\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05848\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05849\ \ \ expected.push\_back(4);}
\DoxyCodeLine{05850\ \ \ expected.push\_back(5);}
\DoxyCodeLine{05851\ \ \ EXPECT\_THAT(s,\ ElementsAreArray(expected));}
\DoxyCodeLine{05852\ }
\DoxyCodeLine{05853\ \ \ expected[3]\ =\ 0;}
\DoxyCodeLine{05854\ \ \ EXPECT\_THAT(s,\ Not(ElementsAreArray(expected)));}
\DoxyCodeLine{05855\ \}}
\DoxyCodeLine{05856\ }
\DoxyCodeLine{05857\ TEST(ElementsAreTest,\ WorksWithUncopyable)\ \{}
\DoxyCodeLine{05858\ \ \ Uncopyable\ objs[2];}
\DoxyCodeLine{05859\ \ \ objs[0].set\_value(-\/3);}
\DoxyCodeLine{05860\ \ \ objs[1].set\_value(1);}
\DoxyCodeLine{05861\ \ \ EXPECT\_THAT(objs,\ ElementsAre(UncopyableIs(-\/3),\ Truly(ValueIsPositive)));}
\DoxyCodeLine{05862\ \}}
\DoxyCodeLine{05863\ }
\DoxyCodeLine{05864\ TEST(ElementsAreTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{05865\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{05866\ \ \ EXPECT\_CALL(helper,\ Call(ElementsAre(Pointee(1),\ Pointee(2))));}
\DoxyCodeLine{05867\ \ \ helper.Call(MakeUniquePtrs(\{1,\ 2\}));}
\DoxyCodeLine{05868\ }
\DoxyCodeLine{05869\ \ \ EXPECT\_CALL(helper,\ Call(ElementsAreArray(\{Pointee(3),\ Pointee(4)\})));}
\DoxyCodeLine{05870\ \ \ helper.Call(MakeUniquePtrs(\{3,\ 4\}));}
\DoxyCodeLine{05871\ \}}
\DoxyCodeLine{05872\ }
\DoxyCodeLine{05873\ TEST(ElementsAreTest,\ TakesStlContainer)\ \{}
\DoxyCodeLine{05874\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ actual[]\ =\ \{3,\ 1,\ 2\};}
\DoxyCodeLine{05875\ }
\DoxyCodeLine{05876\ \ \ ::std::list<int>\ expected;}
\DoxyCodeLine{05877\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05878\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05879\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05880\ \ \ EXPECT\_THAT(actual,\ ElementsAreArray(expected));}
\DoxyCodeLine{05881\ }
\DoxyCodeLine{05882\ \ \ expected.push\_back(4);}
\DoxyCodeLine{05883\ \ \ EXPECT\_THAT(actual,\ Not(ElementsAreArray(expected)));}
\DoxyCodeLine{05884\ \}}
\DoxyCodeLine{05885\ }
\DoxyCodeLine{05886\ \textcolor{comment}{//\ Tests\ for\ UnorderedElementsAreArray()}}
\DoxyCodeLine{05887\ }
\DoxyCodeLine{05888\ TEST(UnorderedElementsAreArrayTest,\ SucceedsWhenExpected)\ \{}
\DoxyCodeLine{05889\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{0,\ 1,\ 2,\ 3,\ 4\};}
\DoxyCodeLine{05890\ \ \ std::vector<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05891\ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{05892\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{05893\ \ \ \ \ EXPECT\_TRUE(ExplainMatchResult(UnorderedElementsAreArray(a),}
\DoxyCodeLine{05894\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{05895\ \ \ \}\ \textcolor{keywordflow}{while}\ (std::next\_permutation(s.begin(),\ s.end()));}
\DoxyCodeLine{05896\ \}}
\DoxyCodeLine{05897\ }
\DoxyCodeLine{05898\ TEST(UnorderedElementsAreArrayTest,\ VectorBool)\ \{}
\DoxyCodeLine{05899\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ a[]\ =\ \{0,\ 1,\ 0,\ 1,\ 1\};}
\DoxyCodeLine{05900\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ b[]\ =\ \{1,\ 0,\ 1,\ 1,\ 0\};}
\DoxyCodeLine{05901\ \ \ std::vector<bool>\ expected(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05902\ \ \ std::vector<bool>\ actual(std::begin(b),\ std::end(b));}
\DoxyCodeLine{05903\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{05904\ \ \ EXPECT\_TRUE(ExplainMatchResult(UnorderedElementsAreArray(expected),}
\DoxyCodeLine{05905\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ actual,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{05906\ \}}
\DoxyCodeLine{05907\ }
\DoxyCodeLine{05908\ TEST(UnorderedElementsAreArrayTest,\ WorksForStreamlike)\ \{}
\DoxyCodeLine{05909\ \ \ \textcolor{comment}{//\ Streamlike\ 'container'\ provides\ only\ minimal\ iterator\ support.}}
\DoxyCodeLine{05910\ \ \ \textcolor{comment}{//\ Its\ iterators\ are\ tagged\ with\ input\_iterator\_tag,\ and\ it\ has\ no}}
\DoxyCodeLine{05911\ \ \ \textcolor{comment}{//\ size()\ or\ empty()\ methods.}}
\DoxyCodeLine{05912\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{2,\ 1,\ 4,\ 5,\ 3\};}
\DoxyCodeLine{05913\ \ \ Streamlike<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05914\ }
\DoxyCodeLine{05915\ \ \ ::std::vector<int>\ expected;}
\DoxyCodeLine{05916\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05917\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05918\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05919\ \ \ expected.push\_back(4);}
\DoxyCodeLine{05920\ \ \ expected.push\_back(5);}
\DoxyCodeLine{05921\ \ \ EXPECT\_THAT(s,\ UnorderedElementsAreArray(expected));}
\DoxyCodeLine{05922\ }
\DoxyCodeLine{05923\ \ \ expected.push\_back(6);}
\DoxyCodeLine{05924\ \ \ EXPECT\_THAT(s,\ Not(UnorderedElementsAreArray(expected)));}
\DoxyCodeLine{05925\ \}}
\DoxyCodeLine{05926\ }
\DoxyCodeLine{05927\ TEST(UnorderedElementsAreArrayTest,\ TakesStlContainer)\ \{}
\DoxyCodeLine{05928\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ actual[]\ =\ \{3,\ 1,\ 2\};}
\DoxyCodeLine{05929\ }
\DoxyCodeLine{05930\ \ \ ::std::list<int>\ expected;}
\DoxyCodeLine{05931\ \ \ expected.push\_back(1);}
\DoxyCodeLine{05932\ \ \ expected.push\_back(2);}
\DoxyCodeLine{05933\ \ \ expected.push\_back(3);}
\DoxyCodeLine{05934\ \ \ EXPECT\_THAT(actual,\ UnorderedElementsAreArray(expected));}
\DoxyCodeLine{05935\ }
\DoxyCodeLine{05936\ \ \ expected.push\_back(4);}
\DoxyCodeLine{05937\ \ \ EXPECT\_THAT(actual,\ Not(UnorderedElementsAreArray(expected)));}
\DoxyCodeLine{05938\ \}}
\DoxyCodeLine{05939\ }
\DoxyCodeLine{05940\ }
\DoxyCodeLine{05941\ TEST(UnorderedElementsAreArrayTest,\ TakesInitializerList)\ \{}
\DoxyCodeLine{05942\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{2,\ 1,\ 4,\ 5,\ 3\};}
\DoxyCodeLine{05943\ \ \ EXPECT\_THAT(a,\ UnorderedElementsAreArray(\{1,\ 2,\ 3,\ 4,\ 5\}));}
\DoxyCodeLine{05944\ \ \ EXPECT\_THAT(a,\ Not(UnorderedElementsAreArray(\{1,\ 2,\ 3,\ 4,\ 6\})));}
\DoxyCodeLine{05945\ \}}
\DoxyCodeLine{05946\ }
\DoxyCodeLine{05947\ TEST(UnorderedElementsAreArrayTest,\ TakesInitializerListOfCStrings)\ \{}
\DoxyCodeLine{05948\ \ \ \textcolor{keyword}{const}\ std::string\ a[5]\ =\ \{\textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{stringliteral}{"{}c"{}},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}}\};}
\DoxyCodeLine{05949\ \ \ EXPECT\_THAT(a,\ UnorderedElementsAreArray(\{\textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{stringliteral}{"{}c"{}},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}}\}));}
\DoxyCodeLine{05950\ \ \ EXPECT\_THAT(a,\ Not(UnorderedElementsAreArray(\{\textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{stringliteral}{"{}c"{}},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}ef"{}}\})));}
\DoxyCodeLine{05951\ \}}
\DoxyCodeLine{05952\ }
\DoxyCodeLine{05953\ TEST(UnorderedElementsAreArrayTest,\ TakesInitializerListOfSameTypedMatchers)\ \{}
\DoxyCodeLine{05954\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{2,\ 1,\ 4,\ 5,\ 3\};}
\DoxyCodeLine{05955\ \ \ EXPECT\_THAT(a,\ UnorderedElementsAreArray(}
\DoxyCodeLine{05956\ \ \ \ \ \ \ \{Eq(1),\ Eq(2),\ Eq(3),\ Eq(4),\ Eq(5)\}));}
\DoxyCodeLine{05957\ \ \ EXPECT\_THAT(a,\ Not(UnorderedElementsAreArray(}
\DoxyCodeLine{05958\ \ \ \ \ \ \ \{Eq(1),\ Eq(2),\ Eq(3),\ Eq(4),\ Eq(6)\})));}
\DoxyCodeLine{05959\ \}}
\DoxyCodeLine{05960\ }
\DoxyCodeLine{05961\ TEST(UnorderedElementsAreArrayTest,}
\DoxyCodeLine{05962\ \ \ \ \ \ TakesInitializerListOfDifferentTypedMatchers)\ \{}
\DoxyCodeLine{05963\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{2,\ 1,\ 4,\ 5,\ 3\};}
\DoxyCodeLine{05964\ \ \ \textcolor{comment}{//\ The\ compiler\ cannot\ infer\ the\ type\ of\ the\ initializer\ list\ if\ its}}
\DoxyCodeLine{05965\ \ \ \textcolor{comment}{//\ elements\ have\ different\ types.\ \ We\ must\ explicitly\ specify\ the}}
\DoxyCodeLine{05966\ \ \ \textcolor{comment}{//\ unified\ element\ type\ in\ this\ case.}}
\DoxyCodeLine{05967\ \ \ EXPECT\_THAT(a,\ UnorderedElementsAreArray<Matcher<int>\ >(}
\DoxyCodeLine{05968\ \ \ \ \ \ \ \{Eq(1),\ Ne(-\/2),\ Ge(3),\ Le(4),\ Eq(5)\}));}
\DoxyCodeLine{05969\ \ \ EXPECT\_THAT(a,\ Not(UnorderedElementsAreArray<Matcher<int>\ >(}
\DoxyCodeLine{05970\ \ \ \ \ \ \ \{Eq(1),\ Ne(-\/2),\ Ge(3),\ Le(4),\ Eq(6)\})));}
\DoxyCodeLine{05971\ \}}
\DoxyCodeLine{05972\ }
\DoxyCodeLine{05973\ }
\DoxyCodeLine{05974\ TEST(UnorderedElementsAreArrayTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{05975\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{05976\ \ \ EXPECT\_CALL(helper,}
\DoxyCodeLine{05977\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Call(UnorderedElementsAreArray(\{Pointee(1),\ Pointee(2)\})));}
\DoxyCodeLine{05978\ \ \ helper.Call(MakeUniquePtrs(\{2,\ 1\}));}
\DoxyCodeLine{05979\ \}}
\DoxyCodeLine{05980\ }
\DoxyCodeLine{05981\ \textcolor{keyword}{class\ }UnorderedElementsAreTest\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classtesting_1_1_test}{testing::Test}}\ \{}
\DoxyCodeLine{05982\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{05983\ \ \ \textcolor{keyword}{typedef}\ std::vector<int>\ IntVec;}
\DoxyCodeLine{05984\ \};}
\DoxyCodeLine{05985\ }
\DoxyCodeLine{05986\ TEST\_F(UnorderedElementsAreTest,\ WorksWithUncopyable)\ \{}
\DoxyCodeLine{05987\ \ \ Uncopyable\ objs[2];}
\DoxyCodeLine{05988\ \ \ objs[0].set\_value(-\/3);}
\DoxyCodeLine{05989\ \ \ objs[1].set\_value(1);}
\DoxyCodeLine{05990\ \ \ EXPECT\_THAT(objs,}
\DoxyCodeLine{05991\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ UnorderedElementsAre(Truly(ValueIsPositive),\ UncopyableIs(-\/3)));}
\DoxyCodeLine{05992\ \}}
\DoxyCodeLine{05993\ }
\DoxyCodeLine{05994\ TEST\_F(UnorderedElementsAreTest,\ SucceedsWhenExpected)\ \{}
\DoxyCodeLine{05995\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{05996\ \ \ std::vector<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{05997\ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{05998\ \ \ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{05999\ \ \ \ \ EXPECT\_TRUE(ExplainMatchResult(UnorderedElementsAre(1,\ 2,\ 3),}
\DoxyCodeLine{06000\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06001\ \ \ \}\ \textcolor{keywordflow}{while}\ (std::next\_permutation(s.begin(),\ s.end()));}
\DoxyCodeLine{06002\ \}}
\DoxyCodeLine{06003\ }
\DoxyCodeLine{06004\ TEST\_F(UnorderedElementsAreTest,\ FailsWhenAnElementMatchesNoMatcher)\ \{}
\DoxyCodeLine{06005\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06006\ \ \ std::vector<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{06007\ \ \ std::vector<Matcher<int>\ >\ mv;}
\DoxyCodeLine{06008\ \ \ mv.push\_back(1);}
\DoxyCodeLine{06009\ \ \ mv.push\_back(2);}
\DoxyCodeLine{06010\ \ \ mv.push\_back(2);}
\DoxyCodeLine{06011\ \ \ \textcolor{comment}{//\ The\ element\ with\ value\ '3'\ matches\ nothing:\ fail\ fast.}}
\DoxyCodeLine{06012\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06013\ \ \ EXPECT\_FALSE(ExplainMatchResult(UnorderedElementsAreArray(mv),}
\DoxyCodeLine{06014\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06015\ \}}
\DoxyCodeLine{06016\ }
\DoxyCodeLine{06017\ TEST\_F(UnorderedElementsAreTest,\ WorksForStreamlike)\ \{}
\DoxyCodeLine{06018\ \ \ \textcolor{comment}{//\ Streamlike\ 'container'\ provides\ only\ minimal\ iterator\ support.}}
\DoxyCodeLine{06019\ \ \ \textcolor{comment}{//\ Its\ iterators\ are\ tagged\ with\ input\_iterator\_tag,\ and\ it\ has\ no}}
\DoxyCodeLine{06020\ \ \ \textcolor{comment}{//\ size()\ or\ empty()\ methods.}}
\DoxyCodeLine{06021\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{2,\ 1,\ 4,\ 5,\ 3\};}
\DoxyCodeLine{06022\ \ \ Streamlike<int>\ s(std::begin(a),\ std::end(a));}
\DoxyCodeLine{06023\ }
\DoxyCodeLine{06024\ \ \ EXPECT\_THAT(s,\ UnorderedElementsAre(1,\ 2,\ 3,\ 4,\ 5));}
\DoxyCodeLine{06025\ \ \ EXPECT\_THAT(s,\ Not(UnorderedElementsAre(2,\ 2,\ 3,\ 4,\ 5)));}
\DoxyCodeLine{06026\ \}}
\DoxyCodeLine{06027\ }
\DoxyCodeLine{06028\ TEST\_F(UnorderedElementsAreTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{06029\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{06030\ \ \ EXPECT\_CALL(helper,\ Call(UnorderedElementsAre(Pointee(1),\ Pointee(2))));}
\DoxyCodeLine{06031\ \ \ helper.Call(MakeUniquePtrs(\{2,\ 1\}));}
\DoxyCodeLine{06032\ \}}
\DoxyCodeLine{06033\ }
\DoxyCodeLine{06034\ \textcolor{comment}{//\ One\ naive\ implementation\ of\ the\ matcher\ runs\ in\ O(N!)\ time,\ which\ is\ too}}
\DoxyCodeLine{06035\ \textcolor{comment}{//\ slow\ for\ many\ real-\/world\ inputs.\ This\ test\ shows\ that\ our\ matcher\ can\ match}}
\DoxyCodeLine{06036\ \textcolor{comment}{//\ 100\ inputs\ very\ quickly\ (a\ few\ milliseconds).\ \ An\ O(100!)\ is\ 10\string^158}}
\DoxyCodeLine{06037\ \textcolor{comment}{//\ iterations\ and\ obviously\ effectively\ incomputable.}}
\DoxyCodeLine{06038\ \textcolor{comment}{//\ [\ RUN\ \ \ \ \ \ ]\ UnorderedElementsAreTest.Performance}}
\DoxyCodeLine{06039\ \textcolor{comment}{//\ [\ \ \ \ \ \ \ OK\ ]\ UnorderedElementsAreTest.Performance\ (4\ ms)}}
\DoxyCodeLine{06040\ TEST\_F(UnorderedElementsAreTest,\ Performance)\ \{}
\DoxyCodeLine{06041\ \ \ std::vector<int>\ s;}
\DoxyCodeLine{06042\ \ \ std::vector<Matcher<int>\ >\ mv;}
\DoxyCodeLine{06043\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ 100;\ ++i)\ \{}
\DoxyCodeLine{06044\ \ \ \ \ s.push\_back(i);}
\DoxyCodeLine{06045\ \ \ \ \ mv.push\_back(\_);}
\DoxyCodeLine{06046\ \ \ \}}
\DoxyCodeLine{06047\ \ \ mv[50]\ =\ Eq(0);}
\DoxyCodeLine{06048\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06049\ \ \ EXPECT\_TRUE(ExplainMatchResult(UnorderedElementsAreArray(mv),}
\DoxyCodeLine{06050\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06051\ \}}
\DoxyCodeLine{06052\ }
\DoxyCodeLine{06053\ \textcolor{comment}{//\ Another\ variant\ of\ 'Performance'\ with\ similar\ expectations.}}
\DoxyCodeLine{06054\ \textcolor{comment}{//\ [\ RUN\ \ \ \ \ \ ]\ UnorderedElementsAreTest.PerformanceHalfStrict}}
\DoxyCodeLine{06055\ \textcolor{comment}{//\ [\ \ \ \ \ \ \ OK\ ]\ UnorderedElementsAreTest.PerformanceHalfStrict\ (4\ ms)}}
\DoxyCodeLine{06056\ TEST\_F(UnorderedElementsAreTest,\ PerformanceHalfStrict)\ \{}
\DoxyCodeLine{06057\ \ \ std::vector<int>\ s;}
\DoxyCodeLine{06058\ \ \ std::vector<Matcher<int>\ >\ mv;}
\DoxyCodeLine{06059\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ 100;\ ++i)\ \{}
\DoxyCodeLine{06060\ \ \ \ \ s.push\_back(i);}
\DoxyCodeLine{06061\ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ \&\ 1)\ \{}
\DoxyCodeLine{06062\ \ \ \ \ \ \ mv.push\_back(\_);}
\DoxyCodeLine{06063\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{06064\ \ \ \ \ \ \ mv.push\_back(i);}
\DoxyCodeLine{06065\ \ \ \ \ \}}
\DoxyCodeLine{06066\ \ \ \}}
\DoxyCodeLine{06067\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06068\ \ \ EXPECT\_TRUE(ExplainMatchResult(UnorderedElementsAreArray(mv),}
\DoxyCodeLine{06069\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06070\ \}}
\DoxyCodeLine{06071\ }
\DoxyCodeLine{06072\ TEST\_F(UnorderedElementsAreTest,\ FailMessageCountWrong)\ \{}
\DoxyCodeLine{06073\ \ \ std::vector<int>\ v;}
\DoxyCodeLine{06074\ \ \ v.push\_back(4);}
\DoxyCodeLine{06075\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06076\ \ \ EXPECT\_FALSE(ExplainMatchResult(UnorderedElementsAre(1,\ 2,\ 3),}
\DoxyCodeLine{06077\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06078\ \ \ EXPECT\_THAT(listener.str(),\ Eq(\textcolor{stringliteral}{"{}which\ has\ 1\ element"{}}));}
\DoxyCodeLine{06079\ \}}
\DoxyCodeLine{06080\ }
\DoxyCodeLine{06081\ TEST\_F(UnorderedElementsAreTest,\ FailMessageCountWrongZero)\ \{}
\DoxyCodeLine{06082\ \ \ std::vector<int>\ v;}
\DoxyCodeLine{06083\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06084\ \ \ EXPECT\_FALSE(ExplainMatchResult(UnorderedElementsAre(1,\ 2,\ 3),}
\DoxyCodeLine{06085\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06086\ \ \ EXPECT\_THAT(listener.str(),\ Eq(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{06087\ \}}
\DoxyCodeLine{06088\ }
\DoxyCodeLine{06089\ TEST\_F(UnorderedElementsAreTest,\ FailMessageUnmatchedMatchers)\ \{}
\DoxyCodeLine{06090\ \ \ std::vector<int>\ v;}
\DoxyCodeLine{06091\ \ \ v.push\_back(1);}
\DoxyCodeLine{06092\ \ \ v.push\_back(1);}
\DoxyCodeLine{06093\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06094\ \ \ EXPECT\_FALSE(ExplainMatchResult(UnorderedElementsAre(1,\ 2),}
\DoxyCodeLine{06095\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06096\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{06097\ \ \ \ \ \ \ listener.str(),}
\DoxyCodeLine{06098\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}where\ the\ following\ matchers\ don't\ match\ any\ elements:\(\backslash\)n"{}}}
\DoxyCodeLine{06099\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}matcher\ \#1:\ is\ equal\ to\ 2"{}}));}
\DoxyCodeLine{06100\ \}}
\DoxyCodeLine{06101\ }
\DoxyCodeLine{06102\ TEST\_F(UnorderedElementsAreTest,\ FailMessageUnmatchedElements)\ \{}
\DoxyCodeLine{06103\ \ \ std::vector<int>\ v;}
\DoxyCodeLine{06104\ \ \ v.push\_back(1);}
\DoxyCodeLine{06105\ \ \ v.push\_back(2);}
\DoxyCodeLine{06106\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06107\ \ \ EXPECT\_FALSE(ExplainMatchResult(UnorderedElementsAre(1,\ 1),}
\DoxyCodeLine{06108\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06109\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{06110\ \ \ \ \ \ \ listener.str(),}
\DoxyCodeLine{06111\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}where\ the\ following\ elements\ don't\ match\ any\ matchers:\(\backslash\)n"{}}}
\DoxyCodeLine{06112\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#1:\ 2"{}}));}
\DoxyCodeLine{06113\ \}}
\DoxyCodeLine{06114\ }
\DoxyCodeLine{06115\ TEST\_F(UnorderedElementsAreTest,\ FailMessageUnmatchedMatcherAndElement)\ \{}
\DoxyCodeLine{06116\ \ \ std::vector<int>\ v;}
\DoxyCodeLine{06117\ \ \ v.push\_back(2);}
\DoxyCodeLine{06118\ \ \ v.push\_back(3);}
\DoxyCodeLine{06119\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06120\ \ \ EXPECT\_FALSE(ExplainMatchResult(UnorderedElementsAre(1,\ 2),}
\DoxyCodeLine{06121\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v,\ \&listener))\ <<\ listener.str();}
\DoxyCodeLine{06122\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{06123\ \ \ \ \ \ \ listener.str(),}
\DoxyCodeLine{06124\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}where"{}}}
\DoxyCodeLine{06125\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ the\ following\ matchers\ don't\ match\ any\ elements:\(\backslash\)n"{}}}
\DoxyCodeLine{06126\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}matcher\ \#0:\ is\ equal\ to\ 1\(\backslash\)n"{}}}
\DoxyCodeLine{06127\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and"{}}}
\DoxyCodeLine{06128\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ where"{}}}
\DoxyCodeLine{06129\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ the\ following\ elements\ don't\ match\ any\ matchers:\(\backslash\)n"{}}}
\DoxyCodeLine{06130\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#1:\ 3"{}}));}
\DoxyCodeLine{06131\ \}}
\DoxyCodeLine{06132\ }
\DoxyCodeLine{06133\ \textcolor{comment}{//\ Test\ helper\ for\ formatting\ element,\ matcher\ index\ pairs\ in\ expectations.}}
\DoxyCodeLine{06134\ \textcolor{keyword}{static}\ std::string\ EMString(\textcolor{keywordtype}{int}\ element,\ \textcolor{keywordtype}{int}\ matcher)\ \{}
\DoxyCodeLine{06135\ \ \ stringstream\ ss;}
\DoxyCodeLine{06136\ \ \ ss\ <<\ \textcolor{stringliteral}{"{}(element\ \#"{}}\ <<\ element\ <<\ \textcolor{stringliteral}{"{},\ matcher\ \#"{}}\ <<\ matcher\ <<\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{06137\ \ \ \textcolor{keywordflow}{return}\ ss.str();}
\DoxyCodeLine{06138\ \}}
\DoxyCodeLine{06139\ }
\DoxyCodeLine{06140\ TEST\_F(UnorderedElementsAreTest,\ FailMessageImperfectMatchOnly)\ \{}
\DoxyCodeLine{06141\ \ \ \textcolor{comment}{//\ A\ situation\ where\ all\ elements\ and\ matchers\ have\ a\ match}}
\DoxyCodeLine{06142\ \ \ \textcolor{comment}{//\ associated\ with\ them,\ but\ the\ max\ matching\ is\ not\ perfect.}}
\DoxyCodeLine{06143\ \ \ std::vector<std::string>\ v;}
\DoxyCodeLine{06144\ \ \ v.push\_back(\textcolor{stringliteral}{"{}a"{}});}
\DoxyCodeLine{06145\ \ \ v.push\_back(\textcolor{stringliteral}{"{}b"{}});}
\DoxyCodeLine{06146\ \ \ v.push\_back(\textcolor{stringliteral}{"{}c"{}});}
\DoxyCodeLine{06147\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{06148\ \ \ EXPECT\_FALSE(ExplainMatchResult(}
\DoxyCodeLine{06149\ \ \ \ \ \ \ UnorderedElementsAre(\textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}a"{}},\ AnyOf(\textcolor{stringliteral}{"{}b"{}},\ \textcolor{stringliteral}{"{}c"{}})),\ v,\ \&listener))}
\DoxyCodeLine{06150\ \ \ \ \ \ \ <<\ listener.str();}
\DoxyCodeLine{06151\ }
\DoxyCodeLine{06152\ \ \ std::string\ prefix\ =}
\DoxyCodeLine{06153\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}where\ no\ permutation\ of\ the\ elements\ can\ satisfy\ all\ matchers,\ "{}}}
\DoxyCodeLine{06154\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\ the\ closest\ match\ is\ 2\ of\ 3\ matchers\ with\ the\ "{}}}
\DoxyCodeLine{06155\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}pairings:\(\backslash\)n"{}};}
\DoxyCodeLine{06156\ }
\DoxyCodeLine{06157\ \ \ \textcolor{comment}{//\ We\ have\ to\ be\ a\ bit\ loose\ here,\ because\ there\ are\ 4\ valid\ max\ matches.}}
\DoxyCodeLine{06158\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{06159\ \ \ \ \ \ \ listener.str(),}
\DoxyCodeLine{06160\ \ \ \ \ \ \ AnyOf(prefix\ +\ \textcolor{stringliteral}{"{}\{\(\backslash\)n\ \ "{}}\ +\ EMString(0,\ 0)\ +}
\DoxyCodeLine{06161\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\(\backslash\)n\ \ "{}}\ +\ EMString(1,\ 2)\ +\ \textcolor{stringliteral}{"{}\(\backslash\)n\}"{}},}
\DoxyCodeLine{06162\ \ \ \ \ \ \ \ \ \ \ \ \ prefix\ +\ \textcolor{stringliteral}{"{}\{\(\backslash\)n\ \ "{}}\ +\ EMString(0,\ 1)\ +}
\DoxyCodeLine{06163\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\(\backslash\)n\ \ "{}}\ +\ EMString(1,\ 2)\ +\ \textcolor{stringliteral}{"{}\(\backslash\)n\}"{}},}
\DoxyCodeLine{06164\ \ \ \ \ \ \ \ \ \ \ \ \ prefix\ +\ \textcolor{stringliteral}{"{}\{\(\backslash\)n\ \ "{}}\ +\ EMString(0,\ 0)\ +}
\DoxyCodeLine{06165\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\(\backslash\)n\ \ "{}}\ +\ EMString(2,\ 2)\ +\ \textcolor{stringliteral}{"{}\(\backslash\)n\}"{}},}
\DoxyCodeLine{06166\ \ \ \ \ \ \ \ \ \ \ \ \ prefix\ +\ \textcolor{stringliteral}{"{}\{\(\backslash\)n\ \ "{}}\ +\ EMString(0,\ 1)\ +}
\DoxyCodeLine{06167\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{},\(\backslash\)n\ \ "{}}\ +\ EMString(2,\ 2)\ +\ \textcolor{stringliteral}{"{}\(\backslash\)n\}"{}}));}
\DoxyCodeLine{06168\ \}}
\DoxyCodeLine{06169\ }
\DoxyCodeLine{06170\ TEST\_F(UnorderedElementsAreTest,\ Describe)\ \{}
\DoxyCodeLine{06171\ \ \ EXPECT\_THAT(Describe<IntVec>(UnorderedElementsAre()),}
\DoxyCodeLine{06172\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}is\ empty"{}}));}
\DoxyCodeLine{06173\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{06174\ \ \ \ \ \ \ Describe<IntVec>(UnorderedElementsAre(345)),}
\DoxyCodeLine{06175\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}has\ 1\ element\ and\ that\ element\ is\ equal\ to\ 345"{}}));}
\DoxyCodeLine{06176\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{06177\ \ \ \ \ \ \ Describe<IntVec>(UnorderedElementsAre(111,\ 222,\ 333)),}
\DoxyCodeLine{06178\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}has\ 3\ elements\ and\ there\ exists\ some\ permutation\ "{}}}
\DoxyCodeLine{06179\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}of\ elements\ such\ that:\(\backslash\)n"{}}}
\DoxyCodeLine{06180\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#0\ is\ equal\ to\ 111,\ and\(\backslash\)n"{}}}
\DoxyCodeLine{06181\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#1\ is\ equal\ to\ 222,\ and\(\backslash\)n"{}}}
\DoxyCodeLine{06182\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#2\ is\ equal\ to\ 333"{}}));}
\DoxyCodeLine{06183\ \}}
\DoxyCodeLine{06184\ }
\DoxyCodeLine{06185\ TEST\_F(UnorderedElementsAreTest,\ DescribeNegation)\ \{}
\DoxyCodeLine{06186\ \ \ EXPECT\_THAT(DescribeNegation<IntVec>(UnorderedElementsAre()),}
\DoxyCodeLine{06187\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}isn't\ empty"{}}));}
\DoxyCodeLine{06188\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{06189\ \ \ \ \ \ \ DescribeNegation<IntVec>(UnorderedElementsAre(345)),}
\DoxyCodeLine{06190\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}doesn't\ have\ 1\ element,\ or\ has\ 1\ element\ that\ isn't\ equal\ to\ 345"{}}));}
\DoxyCodeLine{06191\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{06192\ \ \ \ \ \ \ DescribeNegation<IntVec>(UnorderedElementsAre(123,\ 234,\ 345)),}
\DoxyCodeLine{06193\ \ \ \ \ \ \ Eq(\textcolor{stringliteral}{"{}doesn't\ have\ 3\ elements,\ or\ there\ exists\ no\ permutation\ "{}}}
\DoxyCodeLine{06194\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}of\ elements\ such\ that:\(\backslash\)n"{}}}
\DoxyCodeLine{06195\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#0\ is\ equal\ to\ 123,\ and\(\backslash\)n"{}}}
\DoxyCodeLine{06196\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#1\ is\ equal\ to\ 234,\ and\(\backslash\)n"{}}}
\DoxyCodeLine{06197\ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#2\ is\ equal\ to\ 345"{}}));}
\DoxyCodeLine{06198\ \}}
\DoxyCodeLine{06199\ }
\DoxyCodeLine{06200\ \textcolor{keyword}{namespace\ }\{}
\DoxyCodeLine{06201\ }
\DoxyCodeLine{06202\ \textcolor{comment}{//\ Used\ as\ a\ check\ on\ the\ more\ complex\ max\ flow\ method\ used\ in\ the}}
\DoxyCodeLine{06203\ \textcolor{comment}{//\ real\ testing::internal::FindMaxBipartiteMatching.\ This\ method\ is}}
\DoxyCodeLine{06204\ \textcolor{comment}{//\ compatible\ but\ runs\ in\ worst-\/case\ factorial\ time,\ so\ we\ only}}
\DoxyCodeLine{06205\ \textcolor{comment}{//\ use\ it\ in\ testing\ for\ small\ problem\ sizes.}}
\DoxyCodeLine{06206\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Graph>}
\DoxyCodeLine{06207\ \textcolor{keyword}{class\ }BacktrackingMaxBPMState\ \{}
\DoxyCodeLine{06208\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{06209\ \ \ \textcolor{comment}{//\ Does\ not\ take\ ownership\ of\ 'g'.}}
\DoxyCodeLine{06210\ \ \ \textcolor{keyword}{explicit}\ BacktrackingMaxBPMState(\textcolor{keyword}{const}\ \mbox{\hyperlink{class_graph}{Graph}}*\ g)\ :\ graph\_(g)\ \{\ \}}
\DoxyCodeLine{06211\ }
\DoxyCodeLine{06212\ \ \ ElementMatcherPairs\ Compute()\ \{}
\DoxyCodeLine{06213\ \ \ \ \ \textcolor{keywordflow}{if}\ (graph\_-\/>LhsSize()\ ==\ 0\ ||\ graph\_-\/>RhsSize()\ ==\ 0)\ \{}
\DoxyCodeLine{06214\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ best\_so\_far\_;}
\DoxyCodeLine{06215\ \ \ \ \ \}}
\DoxyCodeLine{06216\ \ \ \ \ lhs\_used\_.assign(graph\_-\/>LhsSize(),\ kUnused);}
\DoxyCodeLine{06217\ \ \ \ \ rhs\_used\_.assign(graph\_-\/>RhsSize(),\ kUnused);}
\DoxyCodeLine{06218\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ irhs\ =\ 0;\ irhs\ <\ graph\_-\/>RhsSize();\ ++irhs)\ \{}
\DoxyCodeLine{06219\ \ \ \ \ \ \ matches\_.clear();}
\DoxyCodeLine{06220\ \ \ \ \ \ \ RecurseInto(irhs);}
\DoxyCodeLine{06221\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (best\_so\_far\_.size()\ ==\ graph\_-\/>RhsSize())}
\DoxyCodeLine{06222\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{06223\ \ \ \ \ \}}
\DoxyCodeLine{06224\ \ \ \ \ \textcolor{keywordflow}{return}\ best\_so\_far\_;}
\DoxyCodeLine{06225\ \ \ \}}
\DoxyCodeLine{06226\ }
\DoxyCodeLine{06227\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{06228\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ kUnused\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{06229\ }
\DoxyCodeLine{06230\ \ \ \textcolor{keywordtype}{void}\ PushMatch(\textcolor{keywordtype}{size\_t}\ lhs,\ \textcolor{keywordtype}{size\_t}\ rhs)\ \{}
\DoxyCodeLine{06231\ \ \ \ \ matches\_.push\_back(ElementMatcherPair(lhs,\ rhs));}
\DoxyCodeLine{06232\ \ \ \ \ lhs\_used\_[lhs]\ =\ rhs;}
\DoxyCodeLine{06233\ \ \ \ \ rhs\_used\_[rhs]\ =\ lhs;}
\DoxyCodeLine{06234\ \ \ \ \ \textcolor{keywordflow}{if}\ (matches\_.size()\ >\ best\_so\_far\_.size())\ \{}
\DoxyCodeLine{06235\ \ \ \ \ \ \ best\_so\_far\_\ =\ matches\_;}
\DoxyCodeLine{06236\ \ \ \ \ \}}
\DoxyCodeLine{06237\ \ \ \}}
\DoxyCodeLine{06238\ }
\DoxyCodeLine{06239\ \ \ \textcolor{keywordtype}{void}\ PopMatch()\ \{}
\DoxyCodeLine{06240\ \ \ \ \ \textcolor{keyword}{const}\ ElementMatcherPair\&\ back\ =\ matches\_.back();}
\DoxyCodeLine{06241\ \ \ \ \ lhs\_used\_[back.first]\ =\ kUnused;}
\DoxyCodeLine{06242\ \ \ \ \ rhs\_used\_[back.second]\ =\ kUnused;}
\DoxyCodeLine{06243\ \ \ \ \ matches\_.pop\_back();}
\DoxyCodeLine{06244\ \ \ \}}
\DoxyCodeLine{06245\ }
\DoxyCodeLine{06246\ \ \ \textcolor{keywordtype}{bool}\ RecurseInto(\textcolor{keywordtype}{size\_t}\ irhs)\ \{}
\DoxyCodeLine{06247\ \ \ \ \ \textcolor{keywordflow}{if}\ (rhs\_used\_[irhs]\ !=\ kUnused)\ \{}
\DoxyCodeLine{06248\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{06249\ \ \ \ \ \}}
\DoxyCodeLine{06250\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ ilhs\ =\ 0;\ ilhs\ <\ graph\_-\/>LhsSize();\ ++ilhs)\ \{}
\DoxyCodeLine{06251\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (lhs\_used\_[ilhs]\ !=\ kUnused)\ \{}
\DoxyCodeLine{06252\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{06253\ \ \ \ \ \ \ \}}
\DoxyCodeLine{06254\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!graph\_-\/>HasEdge(ilhs,\ irhs))\ \{}
\DoxyCodeLine{06255\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{06256\ \ \ \ \ \ \ \}}
\DoxyCodeLine{06257\ \ \ \ \ \ \ PushMatch(ilhs,\ irhs);}
\DoxyCodeLine{06258\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (best\_so\_far\_.size()\ ==\ graph\_-\/>RhsSize())\ \{}
\DoxyCodeLine{06259\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{06260\ \ \ \ \ \ \ \}}
\DoxyCodeLine{06261\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ mi\ =\ irhs\ +\ 1;\ mi\ <\ graph\_-\/>RhsSize();\ ++mi)\ \{}
\DoxyCodeLine{06262\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!RecurseInto(mi))\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{06263\ \ \ \ \ \ \ \}}
\DoxyCodeLine{06264\ \ \ \ \ \ \ PopMatch();}
\DoxyCodeLine{06265\ \ \ \ \ \}}
\DoxyCodeLine{06266\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{06267\ \ \ \}}
\DoxyCodeLine{06268\ }
\DoxyCodeLine{06269\ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{class_graph}{Graph}}*\ graph\_;\ \ \textcolor{comment}{//\ not\ owned}}
\DoxyCodeLine{06270\ \ \ std::vector<size\_t>\ lhs\_used\_;}
\DoxyCodeLine{06271\ \ \ std::vector<size\_t>\ rhs\_used\_;}
\DoxyCodeLine{06272\ \ \ ElementMatcherPairs\ matches\_;}
\DoxyCodeLine{06273\ \ \ ElementMatcherPairs\ best\_so\_far\_;}
\DoxyCodeLine{06274\ \};}
\DoxyCodeLine{06275\ }
\DoxyCodeLine{06276\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Graph>}
\DoxyCodeLine{06277\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ BacktrackingMaxBPMState<Graph>::kUnused;}
\DoxyCodeLine{06278\ }
\DoxyCodeLine{06279\ \}\ \ \textcolor{comment}{//\ namespace}}
\DoxyCodeLine{06280\ }
\DoxyCodeLine{06281\ \textcolor{comment}{//\ Implement\ a\ simple\ backtracking\ algorithm\ to\ determine\ if\ it\ is\ possible}}
\DoxyCodeLine{06282\ \textcolor{comment}{//\ to\ find\ one\ element\ per\ matcher,\ without\ reusing\ elements.}}
\DoxyCodeLine{06283\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Graph>}
\DoxyCodeLine{06284\ ElementMatcherPairs}
\DoxyCodeLine{06285\ FindBacktrackingMaxBPM(\textcolor{keyword}{const}\ \mbox{\hyperlink{class_graph}{Graph}}\&\ g)\ \{}
\DoxyCodeLine{06286\ \ \ \textcolor{keywordflow}{return}\ BacktrackingMaxBPMState<Graph>(\&g).Compute();}
\DoxyCodeLine{06287\ \}}
\DoxyCodeLine{06288\ }
\DoxyCodeLine{06289\ \textcolor{keyword}{class\ }BacktrackingBPMTest\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classtesting_1_1_test}{::testing::Test}}\ \{\ \};}
\DoxyCodeLine{06290\ }
\DoxyCodeLine{06291\ \textcolor{comment}{//\ Tests\ the\ MaxBipartiteMatching\ algorithm\ with\ square\ matrices.}}
\DoxyCodeLine{06292\ \textcolor{comment}{//\ The\ single\ int\ param\ is\ the\ \#\ of\ nodes\ on\ each\ of\ the\ left\ and\ right\ sides.}}
\DoxyCodeLine{06293\ \textcolor{keyword}{class\ }BipartiteTest\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classtesting_1_1_test_with_param}{::testing::TestWithParam}}<size\_t>\ \{\};}
\DoxyCodeLine{06294\ }
\DoxyCodeLine{06295\ \textcolor{comment}{//\ Verify\ all\ match\ graphs\ up\ to\ some\ moderate\ number\ of\ edges.}}
\DoxyCodeLine{06296\ TEST\_P(BipartiteTest,\ Exhaustive)\ \{}
\DoxyCodeLine{06297\ \ \ \textcolor{keywordtype}{size\_t}\ nodes\ =\ GetParam();}
\DoxyCodeLine{06298\ \ \ MatchMatrix\ graph(nodes,\ nodes);}
\DoxyCodeLine{06299\ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{06300\ \ \ \ \ ElementMatcherPairs\ matches\ =}
\DoxyCodeLine{06301\ \ \ \ \ \ \ \ \ internal::FindMaxBipartiteMatching(graph);}
\DoxyCodeLine{06302\ \ \ \ \ EXPECT\_EQ(FindBacktrackingMaxBPM(graph).size(),\ matches.size())}
\DoxyCodeLine{06303\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}graph:\ "{}}\ <<\ graph.DebugString();}
\DoxyCodeLine{06304\ \ \ \ \ \textcolor{comment}{//\ Check\ that\ all\ elements\ of\ matches\ are\ in\ the\ graph.}}
\DoxyCodeLine{06305\ \ \ \ \ \textcolor{comment}{//\ Check\ that\ elements\ of\ first\ and\ second\ are\ unique.}}
\DoxyCodeLine{06306\ \ \ \ \ std::vector<bool>\ seen\_element(graph.LhsSize());}
\DoxyCodeLine{06307\ \ \ \ \ std::vector<bool>\ seen\_matcher(graph.RhsSize());}
\DoxyCodeLine{06308\ \ \ \ \ SCOPED\_TRACE(PrintToString(matches));}
\DoxyCodeLine{06309\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ matches.size();\ ++i)\ \{}
\DoxyCodeLine{06310\ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ ilhs\ =\ matches[i].first;}
\DoxyCodeLine{06311\ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ irhs\ =\ matches[i].second;}
\DoxyCodeLine{06312\ \ \ \ \ \ \ EXPECT\_TRUE(graph.HasEdge(ilhs,\ irhs));}
\DoxyCodeLine{06313\ \ \ \ \ \ \ EXPECT\_FALSE(seen\_element[ilhs]);}
\DoxyCodeLine{06314\ \ \ \ \ \ \ EXPECT\_FALSE(seen\_matcher[irhs]);}
\DoxyCodeLine{06315\ \ \ \ \ \ \ seen\_element[ilhs]\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{06316\ \ \ \ \ \ \ seen\_matcher[irhs]\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{06317\ \ \ \ \ \}}
\DoxyCodeLine{06318\ \ \ \}\ \textcolor{keywordflow}{while}\ (graph.NextGraph());}
\DoxyCodeLine{06319\ \}}
\DoxyCodeLine{06320\ }
\DoxyCodeLine{06321\ INSTANTIATE\_TEST\_SUITE\_P(AllGraphs,\ BipartiteTest,}
\DoxyCodeLine{06322\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::testing::Range(\textcolor{keywordtype}{size\_t}\{0\},\ \textcolor{keywordtype}{size\_t}\{5\}));}
\DoxyCodeLine{06323\ }
\DoxyCodeLine{06324\ \textcolor{comment}{//\ Parameterized\ by\ a\ pair\ interpreted\ as\ (LhsSize,\ RhsSize).}}
\DoxyCodeLine{06325\ \textcolor{keyword}{class\ }BipartiteNonSquareTest}
\DoxyCodeLine{06326\ \ \ \ \ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classtesting_1_1_test_with_param}{::testing::TestWithParam}}<std::pair<size\_t,\ size\_t>\ >\ \{}
\DoxyCodeLine{06327\ \};}
\DoxyCodeLine{06328\ }
\DoxyCodeLine{06329\ TEST\_F(BipartiteNonSquareTest,\ SimpleBacktracking)\ \{}
\DoxyCodeLine{06330\ \ \ \textcolor{comment}{//\ \ \ .......}}
\DoxyCodeLine{06331\ \ \ \textcolor{comment}{//\ 0:-\/-\/-\/-\/-\/\(\backslash\)\ :}}
\DoxyCodeLine{06332\ \ \ \textcolor{comment}{//\ 1:-\/-\/-\/\(\backslash\)\ |\ :}}
\DoxyCodeLine{06333\ \ \ \textcolor{comment}{//\ 2:-\/-\/-\/\(\backslash\)\ |\ :}}
\DoxyCodeLine{06334\ \ \ \textcolor{comment}{//\ 3:-\/\(\backslash\)\ |\ |\ :}}
\DoxyCodeLine{06335\ \ \ \textcolor{comment}{//\ \ :.......:}}
\DoxyCodeLine{06336\ \ \ \textcolor{comment}{//\ \ \ \ 0\ 1\ 2}}
\DoxyCodeLine{06337\ \ \ MatchMatrix\ g(4,\ 3);}
\DoxyCodeLine{06338\ \ \ \textcolor{keyword}{constexpr}\ std::array<std::array<size\_t,\ 2>,\ 4>\ kEdges\ =\ \{}
\DoxyCodeLine{06339\ \ \ \ \ \ \ \{\{\{0,\ 2\}\},\ \{\{1,\ 1\}\},\ \{\{2,\ 1\}\},\ \{\{3,\ 0\}\}\}\};}
\DoxyCodeLine{06340\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ kEdges.size();\ ++i)\ \{}
\DoxyCodeLine{06341\ \ \ \ \ g.SetEdge(kEdges[i][0],\ kEdges[i][1],\ \textcolor{keyword}{true});}
\DoxyCodeLine{06342\ \ \ \}}
\DoxyCodeLine{06343\ \ \ EXPECT\_THAT(FindBacktrackingMaxBPM(g),}
\DoxyCodeLine{06344\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(Pair(3,\ 0),}
\DoxyCodeLine{06345\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(AnyOf(1,\ 2),\ 1),}
\DoxyCodeLine{06346\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair(0,\ 2)))\ <<\ g.DebugString();}
\DoxyCodeLine{06347\ \}}
\DoxyCodeLine{06348\ }
\DoxyCodeLine{06349\ \textcolor{comment}{//\ Verify\ a\ few\ nonsquare\ matrices.}}
\DoxyCodeLine{06350\ TEST\_P(BipartiteNonSquareTest,\ Exhaustive)\ \{}
\DoxyCodeLine{06351\ \ \ \textcolor{keywordtype}{size\_t}\ nlhs\ =\ GetParam().first;}
\DoxyCodeLine{06352\ \ \ \textcolor{keywordtype}{size\_t}\ nrhs\ =\ GetParam().second;}
\DoxyCodeLine{06353\ \ \ MatchMatrix\ graph(nlhs,\ nrhs);}
\DoxyCodeLine{06354\ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{06355\ \ \ \ \ EXPECT\_EQ(FindBacktrackingMaxBPM(graph).size(),}
\DoxyCodeLine{06356\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ internal::FindMaxBipartiteMatching(graph).size())}
\DoxyCodeLine{06357\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}graph:\ "{}}\ <<\ graph.DebugString()}
\DoxyCodeLine{06358\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)nbacktracking:\ "{}}}
\DoxyCodeLine{06359\ \ \ \ \ \ \ \ \ <<\ PrintToString(FindBacktrackingMaxBPM(graph))}
\DoxyCodeLine{06360\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)nmax\ flow:\ "{}}}
\DoxyCodeLine{06361\ \ \ \ \ \ \ \ \ <<\ PrintToString(internal::FindMaxBipartiteMatching(graph));}
\DoxyCodeLine{06362\ \ \ \}\ \textcolor{keywordflow}{while}\ (graph.NextGraph());}
\DoxyCodeLine{06363\ \}}
\DoxyCodeLine{06364\ }
\DoxyCodeLine{06365\ INSTANTIATE\_TEST\_SUITE\_P(AllGraphs,\ BipartiteNonSquareTest,}
\DoxyCodeLine{06366\ \ \ \ \ testing::Values(}
\DoxyCodeLine{06367\ \ \ \ \ \ \ \ \ std::make\_pair(1,\ 2),}
\DoxyCodeLine{06368\ \ \ \ \ \ \ \ \ std::make\_pair(2,\ 1),}
\DoxyCodeLine{06369\ \ \ \ \ \ \ \ \ std::make\_pair(3,\ 2),}
\DoxyCodeLine{06370\ \ \ \ \ \ \ \ \ std::make\_pair(2,\ 3),}
\DoxyCodeLine{06371\ \ \ \ \ \ \ \ \ std::make\_pair(4,\ 1),}
\DoxyCodeLine{06372\ \ \ \ \ \ \ \ \ std::make\_pair(1,\ 4),}
\DoxyCodeLine{06373\ \ \ \ \ \ \ \ \ std::make\_pair(4,\ 3),}
\DoxyCodeLine{06374\ \ \ \ \ \ \ \ \ std::make\_pair(3,\ 4)));}
\DoxyCodeLine{06375\ }
\DoxyCodeLine{06376\ \textcolor{keyword}{class\ }BipartiteRandomTest}
\DoxyCodeLine{06377\ \ \ \ \ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classtesting_1_1_test_with_param}{::testing::TestWithParam}}<std::pair<int,\ int>\ >\ \{}
\DoxyCodeLine{06378\ \};}
\DoxyCodeLine{06379\ }
\DoxyCodeLine{06380\ \textcolor{comment}{//\ Verifies\ a\ large\ sample\ of\ larger\ graphs.}}
\DoxyCodeLine{06381\ TEST\_P(BipartiteRandomTest,\ LargerNets)\ \{}
\DoxyCodeLine{06382\ \ \ \textcolor{keywordtype}{int}\ nodes\ =\ GetParam().first;}
\DoxyCodeLine{06383\ \ \ \textcolor{keywordtype}{int}\ iters\ =\ GetParam().second;}
\DoxyCodeLine{06384\ \ \ MatchMatrix\ graph(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(nodes),\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(nodes));}
\DoxyCodeLine{06385\ }
\DoxyCodeLine{06386\ \ \ \textcolor{keyword}{auto}\ seed\ =\ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(GTEST\_FLAG\_GET(random\_seed));}
\DoxyCodeLine{06387\ \ \ \textcolor{keywordflow}{if}\ (seed\ ==\ 0)\ \{}
\DoxyCodeLine{06388\ \ \ \ \ seed\ =\ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(time(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{06389\ \ \ \}}
\DoxyCodeLine{06390\ }
\DoxyCodeLine{06391\ \ \ \textcolor{keywordflow}{for}\ (;\ iters\ >\ 0;\ -\/-\/iters,\ ++seed)\ \{}
\DoxyCodeLine{06392\ \ \ \ \ srand(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{int}\textcolor{keyword}{>}(seed));}
\DoxyCodeLine{06393\ \ \ \ \ graph.Randomize();}
\DoxyCodeLine{06394\ \ \ \ \ EXPECT\_EQ(FindBacktrackingMaxBPM(graph).size(),}
\DoxyCodeLine{06395\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ internal::FindMaxBipartiteMatching(graph).size())}
\DoxyCodeLine{06396\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ graph:\ "{}}\ <<\ graph.DebugString()}
\DoxyCodeLine{06397\ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\(\backslash\)nTo\ reproduce\ the\ failure,\ rerun\ the\ test\ with\ the\ flag"{}}}
\DoxyCodeLine{06398\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/-\/"{}}\ <<\ GTEST\_FLAG\_PREFIX\_\ <<\ \textcolor{stringliteral}{"{}random\_seed="{}}\ <<\ seed;}
\DoxyCodeLine{06399\ \ \ \}}
\DoxyCodeLine{06400\ \}}
\DoxyCodeLine{06401\ }
\DoxyCodeLine{06402\ \textcolor{comment}{//\ Test\ argument\ is\ a\ std::pair<int,\ int>\ representing\ (nodes,\ iters).}}
\DoxyCodeLine{06403\ INSTANTIATE\_TEST\_SUITE\_P(Samples,\ BipartiteRandomTest,}
\DoxyCodeLine{06404\ \ \ \ \ testing::Values(}
\DoxyCodeLine{06405\ \ \ \ \ \ \ \ \ std::make\_pair(5,\ 10000),}
\DoxyCodeLine{06406\ \ \ \ \ \ \ \ \ std::make\_pair(6,\ 5000),}
\DoxyCodeLine{06407\ \ \ \ \ \ \ \ \ std::make\_pair(7,\ 2000),}
\DoxyCodeLine{06408\ \ \ \ \ \ \ \ \ std::make\_pair(8,\ 500),}
\DoxyCodeLine{06409\ \ \ \ \ \ \ \ \ std::make\_pair(9,\ 100)));}
\DoxyCodeLine{06410\ }
\DoxyCodeLine{06411\ \textcolor{comment}{//\ Tests\ IsReadableTypeName().}}
\DoxyCodeLine{06412\ }
\DoxyCodeLine{06413\ TEST(IsReadableTypeNameTest,\ ReturnsTrueForShortNames)\ \{}
\DoxyCodeLine{06414\ \ \ EXPECT\_TRUE(IsReadableTypeName(\textcolor{stringliteral}{"{}int"{}}));}
\DoxyCodeLine{06415\ \ \ EXPECT\_TRUE(IsReadableTypeName(\textcolor{stringliteral}{"{}const\ unsigned\ char*"{}}));}
\DoxyCodeLine{06416\ \ \ EXPECT\_TRUE(IsReadableTypeName(\textcolor{stringliteral}{"{}MyMap<int,\ void*>"{}}));}
\DoxyCodeLine{06417\ \ \ EXPECT\_TRUE(IsReadableTypeName(\textcolor{stringliteral}{"{}void\ (*)(int,\ bool)"{}}));}
\DoxyCodeLine{06418\ \}}
\DoxyCodeLine{06419\ }
\DoxyCodeLine{06420\ TEST(IsReadableTypeNameTest,\ ReturnsTrueForLongNonTemplateNonFunctionNames)\ \{}
\DoxyCodeLine{06421\ \ \ EXPECT\_TRUE(IsReadableTypeName(\textcolor{stringliteral}{"{}my\_long\_namespace::MyClassName"{}}));}
\DoxyCodeLine{06422\ \ \ EXPECT\_TRUE(IsReadableTypeName(\textcolor{stringliteral}{"{}int\ [5][6][7][8][9][10][11]"{}}));}
\DoxyCodeLine{06423\ \ \ EXPECT\_TRUE(IsReadableTypeName(\textcolor{stringliteral}{"{}my\_namespace::MyOuterClass::MyInnerClass"{}}));}
\DoxyCodeLine{06424\ \}}
\DoxyCodeLine{06425\ }
\DoxyCodeLine{06426\ TEST(IsReadableTypeNameTest,\ ReturnsFalseForLongTemplateNames)\ \{}
\DoxyCodeLine{06427\ \ \ EXPECT\_FALSE(}
\DoxyCodeLine{06428\ \ \ \ \ \ \ IsReadableTypeName(\textcolor{stringliteral}{"{}basic\_string<char,\ std::char\_traits<char>\ >"{}}));}
\DoxyCodeLine{06429\ \ \ EXPECT\_FALSE(IsReadableTypeName(\textcolor{stringliteral}{"{}std::vector<int,\ std::alloc\_traits<int>\ >"{}}));}
\DoxyCodeLine{06430\ \}}
\DoxyCodeLine{06431\ }
\DoxyCodeLine{06432\ TEST(IsReadableTypeNameTest,\ ReturnsFalseForLongFunctionTypeNames)\ \{}
\DoxyCodeLine{06433\ \ \ EXPECT\_FALSE(IsReadableTypeName(\textcolor{stringliteral}{"{}void\ (\&)(int,\ bool,\ char,\ float)"{}}));}
\DoxyCodeLine{06434\ \}}
\DoxyCodeLine{06435\ }
\DoxyCodeLine{06436\ \textcolor{comment}{//\ Tests\ FormatMatcherDescription().}}
\DoxyCodeLine{06437\ }
\DoxyCodeLine{06438\ TEST(FormatMatcherDescriptionTest,\ WorksForEmptyDescription)\ \{}
\DoxyCodeLine{06439\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ even"{}},}
\DoxyCodeLine{06440\ \ \ \ \ \ \ \ \ \ \ \ \ FormatMatcherDescription(\textcolor{keyword}{false},\ \textcolor{stringliteral}{"{}IsEven"{}},\ Strings()));}
\DoxyCodeLine{06441\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}not\ (is\ even)"{}},}
\DoxyCodeLine{06442\ \ \ \ \ \ \ \ \ \ \ \ \ FormatMatcherDescription(\textcolor{keyword}{true},\ \textcolor{stringliteral}{"{}IsEven"{}},\ Strings()));}
\DoxyCodeLine{06443\ }
\DoxyCodeLine{06444\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ params[]\ =\ \{\textcolor{stringliteral}{"{}5"{}}\};}
\DoxyCodeLine{06445\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}equals\ 5"{}},}
\DoxyCodeLine{06446\ \ \ \ \ \ \ \ \ \ \ \ \ FormatMatcherDescription(\textcolor{keyword}{false},\ \textcolor{stringliteral}{"{}Equals"{}},}
\DoxyCodeLine{06447\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Strings(params,\ params\ +\ 1)));}
\DoxyCodeLine{06448\ }
\DoxyCodeLine{06449\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ params2[]\ =\ \{\textcolor{stringliteral}{"{}5"{}},\ \textcolor{stringliteral}{"{}8"{}}\};}
\DoxyCodeLine{06450\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ in\ range\ (5,\ 8)"{}},}
\DoxyCodeLine{06451\ \ \ \ \ \ \ \ \ \ \ \ \ FormatMatcherDescription(\textcolor{keyword}{false},\ \textcolor{stringliteral}{"{}IsInRange"{}},}
\DoxyCodeLine{06452\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Strings(params2,\ params2\ +\ 2)));}
\DoxyCodeLine{06453\ \}}
\DoxyCodeLine{06454\ }
\DoxyCodeLine{06455\ \textcolor{comment}{//\ Tests\ PolymorphicMatcher::mutable\_impl().}}
\DoxyCodeLine{06456\ TEST(PolymorphicMatcherTest,\ CanAccessMutableImpl)\ \{}
\DoxyCodeLine{06457\ \ \ PolymorphicMatcher<DivisibleByImpl>\ m(DivisibleByImpl(42));}
\DoxyCodeLine{06458\ \ \ DivisibleByImpl\&\ impl\ =\ m.mutable\_impl();}
\DoxyCodeLine{06459\ \ \ EXPECT\_EQ(42,\ impl.divider());}
\DoxyCodeLine{06460\ }
\DoxyCodeLine{06461\ \ \ impl.set\_divider(0);}
\DoxyCodeLine{06462\ \ \ EXPECT\_EQ(0,\ m.mutable\_impl().divider());}
\DoxyCodeLine{06463\ \}}
\DoxyCodeLine{06464\ }
\DoxyCodeLine{06465\ \textcolor{comment}{//\ Tests\ PolymorphicMatcher::impl().}}
\DoxyCodeLine{06466\ TEST(PolymorphicMatcherTest,\ CanAccessImpl)\ \{}
\DoxyCodeLine{06467\ \ \ \textcolor{keyword}{const}\ PolymorphicMatcher<DivisibleByImpl>\ m(DivisibleByImpl(42));}
\DoxyCodeLine{06468\ \ \ \textcolor{keyword}{const}\ DivisibleByImpl\&\ impl\ =\ m.impl();}
\DoxyCodeLine{06469\ \ \ EXPECT\_EQ(42,\ impl.divider());}
\DoxyCodeLine{06470\ \}}
\DoxyCodeLine{06471\ }
\DoxyCodeLine{06472\ TEST(MatcherTupleTest,\ ExplainsMatchFailure)\ \{}
\DoxyCodeLine{06473\ \ \ stringstream\ ss1;}
\DoxyCodeLine{06474\ \ \ ExplainMatchFailureTupleTo(}
\DoxyCodeLine{06475\ \ \ \ \ \ \ std::make\_tuple(Matcher<char>(Eq(\textcolor{charliteral}{'a'})),\ GreaterThan(5)),}
\DoxyCodeLine{06476\ \ \ \ \ \ \ std::make\_tuple(\textcolor{charliteral}{'a'},\ 10),\ \&ss1);}
\DoxyCodeLine{06477\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ ss1.str());\ \ \textcolor{comment}{//\ Successful\ match.}}
\DoxyCodeLine{06478\ }
\DoxyCodeLine{06479\ \ \ stringstream\ ss2;}
\DoxyCodeLine{06480\ \ \ ExplainMatchFailureTupleTo(}
\DoxyCodeLine{06481\ \ \ \ \ \ \ std::make\_tuple(GreaterThan(5),\ Matcher<char>(Eq(\textcolor{charliteral}{'a'}))),}
\DoxyCodeLine{06482\ \ \ \ \ \ \ std::make\_tuple(2,\ \textcolor{charliteral}{'b'}),\ \&ss2);}
\DoxyCodeLine{06483\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}\ \ Expected\ arg\ \#0:\ is\ >\ 5\(\backslash\)n"{}}}
\DoxyCodeLine{06484\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ \ \ \ \ \ \ \ \ \ Actual:\ 2,\ which\ is\ 3\ less\ than\ 5\(\backslash\)n"{}}}
\DoxyCodeLine{06485\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ Expected\ arg\ \#1:\ is\ equal\ to\ 'a'\ (97,\ 0x61)\(\backslash\)n"{}}}
\DoxyCodeLine{06486\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ \ \ \ \ \ \ \ \ \ Actual:\ 'b'\ (98,\ 0x62)\(\backslash\)n"{}},}
\DoxyCodeLine{06487\ \ \ \ \ \ \ \ \ \ \ \ \ ss2.str());\ \ \textcolor{comment}{//\ Failed\ match\ where\ both\ arguments\ need\ explanation.}}
\DoxyCodeLine{06488\ }
\DoxyCodeLine{06489\ \ \ stringstream\ ss3;}
\DoxyCodeLine{06490\ \ \ ExplainMatchFailureTupleTo(}
\DoxyCodeLine{06491\ \ \ \ \ \ \ std::make\_tuple(GreaterThan(5),\ Matcher<char>(Eq(\textcolor{charliteral}{'a'}))),}
\DoxyCodeLine{06492\ \ \ \ \ \ \ std::make\_tuple(2,\ \textcolor{charliteral}{'a'}),\ \&ss3);}
\DoxyCodeLine{06493\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}\ \ Expected\ arg\ \#0:\ is\ >\ 5\(\backslash\)n"{}}}
\DoxyCodeLine{06494\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ \ \ \ \ \ \ \ \ \ Actual:\ 2,\ which\ is\ 3\ less\ than\ 5\(\backslash\)n"{}},}
\DoxyCodeLine{06495\ \ \ \ \ \ \ \ \ \ \ \ \ ss3.str());\ \ \textcolor{comment}{//\ Failed\ match\ where\ only\ one\ argument\ needs}}
\DoxyCodeLine{06496\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ explanation.}}
\DoxyCodeLine{06497\ \}}
\DoxyCodeLine{06498\ }
\DoxyCodeLine{06499\ \textcolor{comment}{//\ Tests\ Each().}}
\DoxyCodeLine{06500\ }
\DoxyCodeLine{06501\ TEST(EachTest,\ ExplainsMatchResultCorrectly)\ \{}
\DoxyCodeLine{06502\ \ \ set<int>\ a;\ \ \textcolor{comment}{//\ empty}}
\DoxyCodeLine{06503\ }
\DoxyCodeLine{06504\ \ \ Matcher<set<int>\ >\ m\ =\ Each(2);}
\DoxyCodeLine{06505\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ a));}
\DoxyCodeLine{06506\ }
\DoxyCodeLine{06507\ \ \ Matcher<\textcolor{keyword}{const}\ int(\&)[1]>\ n\ =\ Each(1);\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{06508\ }
\DoxyCodeLine{06509\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ b[1]\ =\ \{1\};}
\DoxyCodeLine{06510\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(n,\ b));}
\DoxyCodeLine{06511\ }
\DoxyCodeLine{06512\ \ \ n\ =\ Each(3);}
\DoxyCodeLine{06513\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ element\ \#0\ doesn't\ match"{}},\ Explain(n,\ b));}
\DoxyCodeLine{06514\ }
\DoxyCodeLine{06515\ \ \ a.insert(1);}
\DoxyCodeLine{06516\ \ \ a.insert(2);}
\DoxyCodeLine{06517\ \ \ a.insert(3);}
\DoxyCodeLine{06518\ \ \ m\ =\ Each(GreaterThan(0));}
\DoxyCodeLine{06519\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ a));}
\DoxyCodeLine{06520\ }
\DoxyCodeLine{06521\ \ \ m\ =\ Each(GreaterThan(10));}
\DoxyCodeLine{06522\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ element\ \#0\ doesn't\ match,\ which\ is\ 9\ less\ than\ 10"{}},}
\DoxyCodeLine{06523\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{06524\ \}}
\DoxyCodeLine{06525\ }
\DoxyCodeLine{06526\ TEST(EachTest,\ DescribesItselfCorrectly)\ \{}
\DoxyCodeLine{06527\ \ \ Matcher<vector<int>\ >\ m\ =\ Each(1);}
\DoxyCodeLine{06528\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}only\ contains\ elements\ that\ is\ equal\ to\ 1"{}},\ Describe(m));}
\DoxyCodeLine{06529\ }
\DoxyCodeLine{06530\ \ \ Matcher<vector<int>\ >\ m2\ =\ Not(m);}
\DoxyCodeLine{06531\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}contains\ some\ element\ that\ isn't\ equal\ to\ 1"{}},\ Describe(m2));}
\DoxyCodeLine{06532\ \}}
\DoxyCodeLine{06533\ }
\DoxyCodeLine{06534\ TEST(EachTest,\ MatchesVectorWhenAllElementsMatch)\ \{}
\DoxyCodeLine{06535\ \ \ vector<int>\ some\_vector;}
\DoxyCodeLine{06536\ \ \ EXPECT\_THAT(some\_vector,\ Each(1));}
\DoxyCodeLine{06537\ \ \ some\_vector.push\_back(3);}
\DoxyCodeLine{06538\ \ \ EXPECT\_THAT(some\_vector,\ Not(Each(1)));}
\DoxyCodeLine{06539\ \ \ EXPECT\_THAT(some\_vector,\ Each(3));}
\DoxyCodeLine{06540\ \ \ some\_vector.push\_back(1);}
\DoxyCodeLine{06541\ \ \ some\_vector.push\_back(2);}
\DoxyCodeLine{06542\ \ \ EXPECT\_THAT(some\_vector,\ Not(Each(3)));}
\DoxyCodeLine{06543\ \ \ EXPECT\_THAT(some\_vector,\ Each(Lt(3.5)));}
\DoxyCodeLine{06544\ }
\DoxyCodeLine{06545\ \ \ vector<std::string>\ another\_vector;}
\DoxyCodeLine{06546\ \ \ another\_vector.push\_back(\textcolor{stringliteral}{"{}fee"{}});}
\DoxyCodeLine{06547\ \ \ EXPECT\_THAT(another\_vector,\ Each(std::string(\textcolor{stringliteral}{"{}fee"{}})));}
\DoxyCodeLine{06548\ \ \ another\_vector.push\_back(\textcolor{stringliteral}{"{}fie"{}});}
\DoxyCodeLine{06549\ \ \ another\_vector.push\_back(\textcolor{stringliteral}{"{}foe"{}});}
\DoxyCodeLine{06550\ \ \ another\_vector.push\_back(\textcolor{stringliteral}{"{}fum"{}});}
\DoxyCodeLine{06551\ \ \ EXPECT\_THAT(another\_vector,\ Not(Each(std::string(\textcolor{stringliteral}{"{}fee"{}}))));}
\DoxyCodeLine{06552\ \}}
\DoxyCodeLine{06553\ }
\DoxyCodeLine{06554\ TEST(EachTest,\ MatchesMapWhenAllElementsMatch)\ \{}
\DoxyCodeLine{06555\ \ \ map<const\ char*,\ int>\ my\_map;}
\DoxyCodeLine{06556\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ bar\ =\ \textcolor{stringliteral}{"{}a\ string"{}};}
\DoxyCodeLine{06557\ \ \ my\_map[bar]\ =\ 2;}
\DoxyCodeLine{06558\ \ \ EXPECT\_THAT(my\_map,\ Each(make\_pair(bar,\ 2)));}
\DoxyCodeLine{06559\ }
\DoxyCodeLine{06560\ \ \ map<std::string,\ int>\ another\_map;}
\DoxyCodeLine{06561\ \ \ EXPECT\_THAT(another\_map,\ Each(make\_pair(std::string(\textcolor{stringliteral}{"{}fee"{}}),\ 1)));}
\DoxyCodeLine{06562\ \ \ another\_map[\textcolor{stringliteral}{"{}fee"{}}]\ =\ 1;}
\DoxyCodeLine{06563\ \ \ EXPECT\_THAT(another\_map,\ Each(make\_pair(std::string(\textcolor{stringliteral}{"{}fee"{}}),\ 1)));}
\DoxyCodeLine{06564\ \ \ another\_map[\textcolor{stringliteral}{"{}fie"{}}]\ =\ 2;}
\DoxyCodeLine{06565\ \ \ another\_map[\textcolor{stringliteral}{"{}foe"{}}]\ =\ 3;}
\DoxyCodeLine{06566\ \ \ another\_map[\textcolor{stringliteral}{"{}fum"{}}]\ =\ 4;}
\DoxyCodeLine{06567\ \ \ EXPECT\_THAT(another\_map,\ Not(Each(make\_pair(std::string(\textcolor{stringliteral}{"{}fee"{}}),\ 1))));}
\DoxyCodeLine{06568\ \ \ EXPECT\_THAT(another\_map,\ Not(Each(make\_pair(std::string(\textcolor{stringliteral}{"{}fum"{}}),\ 1))));}
\DoxyCodeLine{06569\ \ \ EXPECT\_THAT(another\_map,\ Each(Pair(\_,\ Gt(0))));}
\DoxyCodeLine{06570\ \}}
\DoxyCodeLine{06571\ }
\DoxyCodeLine{06572\ TEST(EachTest,\ AcceptsMatcher)\ \{}
\DoxyCodeLine{06573\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06574\ \ \ EXPECT\_THAT(a,\ Each(Gt(0)));}
\DoxyCodeLine{06575\ \ \ EXPECT\_THAT(a,\ Not(Each(Gt(1))));}
\DoxyCodeLine{06576\ \}}
\DoxyCodeLine{06577\ }
\DoxyCodeLine{06578\ TEST(EachTest,\ WorksForNativeArrayAsTuple)\ \{}
\DoxyCodeLine{06579\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2\};}
\DoxyCodeLine{06580\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ \textcolor{keyword}{const}\ pointer\ =\ a;}
\DoxyCodeLine{06581\ \ \ EXPECT\_THAT(std::make\_tuple(pointer,\ 2),\ Each(Gt(0)));}
\DoxyCodeLine{06582\ \ \ EXPECT\_THAT(std::make\_tuple(pointer,\ 2),\ Not(Each(Gt(1))));}
\DoxyCodeLine{06583\ \}}
\DoxyCodeLine{06584\ }
\DoxyCodeLine{06585\ TEST(EachTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{06586\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{06587\ \ \ EXPECT\_CALL(helper,\ Call(Each(Pointee(Gt(0)))));}
\DoxyCodeLine{06588\ \ \ helper.Call(MakeUniquePtrs(\{1,\ 2\}));}
\DoxyCodeLine{06589\ \}}
\DoxyCodeLine{06590\ }
\DoxyCodeLine{06591\ \textcolor{comment}{//\ For\ testing\ Pointwise().}}
\DoxyCodeLine{06592\ \textcolor{keyword}{class\ }IsHalfOfMatcher\ \{}
\DoxyCodeLine{06593\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{06594\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{06595\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(\textcolor{keyword}{const}\ std::tuple<T1,\ T2>\&\ a\_pair,}
\DoxyCodeLine{06596\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{06597\ \ \ \ \ \textcolor{keywordflow}{if}\ (std::get<0>(a\_pair)\ ==\ std::get<1>(a\_pair)\ /\ 2)\ \{}
\DoxyCodeLine{06598\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}where\ the\ second\ is\ "{}}\ <<\ std::get<1>(a\_pair);}
\DoxyCodeLine{06599\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{06600\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{06601\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}where\ the\ second/2\ is\ "{}}\ <<\ std::get<1>(a\_pair)\ /\ 2;}
\DoxyCodeLine{06602\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{06603\ \ \ \ \ \}}
\DoxyCodeLine{06604\ \ \ \}}
\DoxyCodeLine{06605\ }
\DoxyCodeLine{06606\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{06607\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ a\ pair\ where\ the\ first\ is\ half\ of\ the\ second"{}};}
\DoxyCodeLine{06608\ \ \ \}}
\DoxyCodeLine{06609\ }
\DoxyCodeLine{06610\ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(ostream*\ os)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{06611\ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}are\ a\ pair\ where\ the\ first\ isn't\ half\ of\ the\ second"{}};}
\DoxyCodeLine{06612\ \ \ \}}
\DoxyCodeLine{06613\ \};}
\DoxyCodeLine{06614\ }
\DoxyCodeLine{06615\ PolymorphicMatcher<IsHalfOfMatcher>\ IsHalfOf()\ \{}
\DoxyCodeLine{06616\ \ \ \textcolor{keywordflow}{return}\ MakePolymorphicMatcher(IsHalfOfMatcher());}
\DoxyCodeLine{06617\ \}}
\DoxyCodeLine{06618\ }
\DoxyCodeLine{06619\ TEST(PointwiseTest,\ DescribesSelf)\ \{}
\DoxyCodeLine{06620\ \ \ vector<int>\ rhs;}
\DoxyCodeLine{06621\ \ \ rhs.push\_back(1);}
\DoxyCodeLine{06622\ \ \ rhs.push\_back(2);}
\DoxyCodeLine{06623\ \ \ rhs.push\_back(3);}
\DoxyCodeLine{06624\ \ \ \textcolor{keyword}{const}\ Matcher<const\ vector<int>\&>\ m\ =\ Pointwise(IsHalfOf(),\ rhs);}
\DoxyCodeLine{06625\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}contains\ 3\ values,\ where\ each\ value\ and\ its\ corresponding\ value\ "{}}}
\DoxyCodeLine{06626\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}in\ \{\ 1,\ 2,\ 3\ \}\ are\ a\ pair\ where\ the\ first\ is\ half\ of\ the\ second"{}},}
\DoxyCodeLine{06627\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{06628\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}doesn't\ contain\ exactly\ 3\ values,\ or\ contains\ a\ value\ x\ at\ some\ "{}}}
\DoxyCodeLine{06629\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}index\ i\ where\ x\ and\ the\ i-\/th\ value\ of\ \{\ 1,\ 2,\ 3\ \}\ are\ a\ pair\ "{}}}
\DoxyCodeLine{06630\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}where\ the\ first\ isn't\ half\ of\ the\ second"{}},}
\DoxyCodeLine{06631\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{06632\ \}}
\DoxyCodeLine{06633\ }
\DoxyCodeLine{06634\ TEST(PointwiseTest,\ MakesCopyOfRhs)\ \{}
\DoxyCodeLine{06635\ \ \ list<signed\ char>\ rhs;}
\DoxyCodeLine{06636\ \ \ rhs.push\_back(2);}
\DoxyCodeLine{06637\ \ \ rhs.push\_back(4);}
\DoxyCodeLine{06638\ }
\DoxyCodeLine{06639\ \ \ \textcolor{keywordtype}{int}\ lhs[]\ =\ \{1,\ 2\};}
\DoxyCodeLine{06640\ \ \ \textcolor{keyword}{const}\ Matcher<\textcolor{keyword}{const}\ int\ (\&)[2]>\ m\ =\ Pointwise(IsHalfOf(),\ rhs);}
\DoxyCodeLine{06641\ \ \ EXPECT\_THAT(lhs,\ m);}
\DoxyCodeLine{06642\ }
\DoxyCodeLine{06643\ \ \ \textcolor{comment}{//\ Changing\ rhs\ now\ shouldn't\ affect\ m,\ which\ made\ a\ copy\ of\ rhs.}}
\DoxyCodeLine{06644\ \ \ rhs.push\_back(6);}
\DoxyCodeLine{06645\ \ \ EXPECT\_THAT(lhs,\ m);}
\DoxyCodeLine{06646\ \}}
\DoxyCodeLine{06647\ }
\DoxyCodeLine{06648\ TEST(PointwiseTest,\ WorksForLhsNativeArray)\ \{}
\DoxyCodeLine{06649\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ lhs[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06650\ \ \ vector<int>\ rhs;}
\DoxyCodeLine{06651\ \ \ rhs.push\_back(2);}
\DoxyCodeLine{06652\ \ \ rhs.push\_back(4);}
\DoxyCodeLine{06653\ \ \ rhs.push\_back(6);}
\DoxyCodeLine{06654\ \ \ EXPECT\_THAT(lhs,\ Pointwise(Lt(),\ rhs));}
\DoxyCodeLine{06655\ \ \ EXPECT\_THAT(lhs,\ Not(Pointwise(Gt(),\ rhs)));}
\DoxyCodeLine{06656\ \}}
\DoxyCodeLine{06657\ }
\DoxyCodeLine{06658\ TEST(PointwiseTest,\ WorksForRhsNativeArray)\ \{}
\DoxyCodeLine{06659\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06660\ \ \ vector<int>\ lhs;}
\DoxyCodeLine{06661\ \ \ lhs.push\_back(2);}
\DoxyCodeLine{06662\ \ \ lhs.push\_back(4);}
\DoxyCodeLine{06663\ \ \ lhs.push\_back(6);}
\DoxyCodeLine{06664\ \ \ EXPECT\_THAT(lhs,\ Pointwise(Gt(),\ rhs));}
\DoxyCodeLine{06665\ \ \ EXPECT\_THAT(lhs,\ Not(Pointwise(Lt(),\ rhs)));}
\DoxyCodeLine{06666\ \}}
\DoxyCodeLine{06667\ }
\DoxyCodeLine{06668\ \textcolor{comment}{//\ Test\ is\ effective\ only\ with\ sanitizers.}}
\DoxyCodeLine{06669\ TEST(PointwiseTest,\ WorksForVectorOfBool)\ \{}
\DoxyCodeLine{06670\ \ \ vector<bool>\ rhs(3,\ \textcolor{keyword}{false});}
\DoxyCodeLine{06671\ \ \ rhs[1]\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{06672\ \ \ vector<bool>\ lhs\ =\ rhs;}
\DoxyCodeLine{06673\ \ \ EXPECT\_THAT(lhs,\ Pointwise(Eq(),\ rhs));}
\DoxyCodeLine{06674\ \ \ rhs[0]\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{06675\ \ \ EXPECT\_THAT(lhs,\ Not(Pointwise(Eq(),\ rhs)));}
\DoxyCodeLine{06676\ \}}
\DoxyCodeLine{06677\ }
\DoxyCodeLine{06678\ }
\DoxyCodeLine{06679\ TEST(PointwiseTest,\ WorksForRhsInitializerList)\ \{}
\DoxyCodeLine{06680\ \ \ \textcolor{keyword}{const}\ vector<int>\ lhs\{2,\ 4,\ 6\};}
\DoxyCodeLine{06681\ \ \ EXPECT\_THAT(lhs,\ Pointwise(Gt(),\ \{1,\ 2,\ 3\}));}
\DoxyCodeLine{06682\ \ \ EXPECT\_THAT(lhs,\ Not(Pointwise(Lt(),\ \{3,\ 3,\ 7\})));}
\DoxyCodeLine{06683\ \}}
\DoxyCodeLine{06684\ }
\DoxyCodeLine{06685\ }
\DoxyCodeLine{06686\ TEST(PointwiseTest,\ RejectsWrongSize)\ \{}
\DoxyCodeLine{06687\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[2]\ =\ \{1,\ 2\};}
\DoxyCodeLine{06688\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[1]\ =\ \{0\};}
\DoxyCodeLine{06689\ \ \ EXPECT\_THAT(lhs,\ Not(Pointwise(Gt(),\ rhs)));}
\DoxyCodeLine{06690\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ contains\ 2\ values"{}},}
\DoxyCodeLine{06691\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(Pointwise(Gt(),\ rhs),\ lhs));}
\DoxyCodeLine{06692\ }
\DoxyCodeLine{06693\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs2[3]\ =\ \{0,\ 1,\ 2\};}
\DoxyCodeLine{06694\ \ \ EXPECT\_THAT(lhs,\ Not(Pointwise(Gt(),\ rhs2)));}
\DoxyCodeLine{06695\ \}}
\DoxyCodeLine{06696\ }
\DoxyCodeLine{06697\ TEST(PointwiseTest,\ RejectsWrongContent)\ \{}
\DoxyCodeLine{06698\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[3]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06699\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[3]\ =\ \{2,\ 6,\ 4\};}
\DoxyCodeLine{06700\ \ \ EXPECT\_THAT(lhs,\ Not(Pointwise(IsHalfOf(),\ rhs)));}
\DoxyCodeLine{06701\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}where\ the\ value\ pair\ (2,\ 6)\ at\ index\ \#1\ don't\ match,\ "{}}}
\DoxyCodeLine{06702\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}where\ the\ second/2\ is\ 3"{}},}
\DoxyCodeLine{06703\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(Pointwise(IsHalfOf(),\ rhs),\ lhs));}
\DoxyCodeLine{06704\ \}}
\DoxyCodeLine{06705\ }
\DoxyCodeLine{06706\ TEST(PointwiseTest,\ AcceptsCorrectContent)\ \{}
\DoxyCodeLine{06707\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[3]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06708\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[3]\ =\ \{2,\ 4,\ 6\};}
\DoxyCodeLine{06709\ \ \ EXPECT\_THAT(lhs,\ Pointwise(IsHalfOf(),\ rhs));}
\DoxyCodeLine{06710\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(Pointwise(IsHalfOf(),\ rhs),\ lhs));}
\DoxyCodeLine{06711\ \}}
\DoxyCodeLine{06712\ }
\DoxyCodeLine{06713\ TEST(PointwiseTest,\ AllowsMonomorphicInnerMatcher)\ \{}
\DoxyCodeLine{06714\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[3]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06715\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[3]\ =\ \{2,\ 4,\ 6\};}
\DoxyCodeLine{06716\ \ \ \textcolor{keyword}{const}\ Matcher<std::tuple<const\ double\&,\ const\ int\&>>\ m1\ =\ IsHalfOf();}
\DoxyCodeLine{06717\ \ \ EXPECT\_THAT(lhs,\ Pointwise(m1,\ rhs));}
\DoxyCodeLine{06718\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(Pointwise(m1,\ rhs),\ lhs));}
\DoxyCodeLine{06719\ }
\DoxyCodeLine{06720\ \ \ \textcolor{comment}{//\ This\ type\ works\ as\ a\ std::tuple<const\ double\&,\ const\ int\&>\ can\ be}}
\DoxyCodeLine{06721\ \ \ \textcolor{comment}{//\ implicitly\ cast\ to\ std::tuple<double,\ int>.}}
\DoxyCodeLine{06722\ \ \ \textcolor{keyword}{const}\ Matcher<std::tuple<double,\ int>>\ m2\ =\ IsHalfOf();}
\DoxyCodeLine{06723\ \ \ EXPECT\_THAT(lhs,\ Pointwise(m2,\ rhs));}
\DoxyCodeLine{06724\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(Pointwise(m2,\ rhs),\ lhs));}
\DoxyCodeLine{06725\ \}}
\DoxyCodeLine{06726\ }
\DoxyCodeLine{06727\ MATCHER(PointeeEquals,\ \textcolor{stringliteral}{"{}Points\ to\ an\ equal\ value"{}})\ \{}
\DoxyCodeLine{06728\ \ \ \textcolor{keywordflow}{return}\ ExplainMatchResult(::testing::Pointee(::testing::get<1>(arg)),}
\DoxyCodeLine{06729\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ::testing::get<0>(arg),\ result\_listener);}
\DoxyCodeLine{06730\ \}}
\DoxyCodeLine{06731\ }
\DoxyCodeLine{06732\ TEST(PointwiseTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{06733\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{06734\ \ \ EXPECT\_CALL(helper,\ Call(Pointwise(PointeeEquals(),\ std::vector<int>\{1,\ 2\})));}
\DoxyCodeLine{06735\ \ \ helper.Call(MakeUniquePtrs(\{1,\ 2\}));}
\DoxyCodeLine{06736\ \}}
\DoxyCodeLine{06737\ }
\DoxyCodeLine{06738\ TEST(UnorderedPointwiseTest,\ DescribesSelf)\ \{}
\DoxyCodeLine{06739\ \ \ vector<int>\ rhs;}
\DoxyCodeLine{06740\ \ \ rhs.push\_back(1);}
\DoxyCodeLine{06741\ \ \ rhs.push\_back(2);}
\DoxyCodeLine{06742\ \ \ rhs.push\_back(3);}
\DoxyCodeLine{06743\ \ \ \textcolor{keyword}{const}\ Matcher<const\ vector<int>\&>\ m\ =\ UnorderedPointwise(IsHalfOf(),\ rhs);}
\DoxyCodeLine{06744\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{06745\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}has\ 3\ elements\ and\ there\ exists\ some\ permutation\ of\ elements\ such\ "{}}}
\DoxyCodeLine{06746\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}that:\(\backslash\)n"{}}}
\DoxyCodeLine{06747\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#0\ and\ 1\ are\ a\ pair\ where\ the\ first\ is\ half\ of\ the\ second,\ "{}}}
\DoxyCodeLine{06748\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\(\backslash\)n"{}}}
\DoxyCodeLine{06749\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#1\ and\ 2\ are\ a\ pair\ where\ the\ first\ is\ half\ of\ the\ second,\ "{}}}
\DoxyCodeLine{06750\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\(\backslash\)n"{}}}
\DoxyCodeLine{06751\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#2\ and\ 3\ are\ a\ pair\ where\ the\ first\ is\ half\ of\ the\ second"{}},}
\DoxyCodeLine{06752\ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{06753\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{06754\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}doesn't\ have\ 3\ elements,\ or\ there\ exists\ no\ permutation\ of\ elements\ "{}}}
\DoxyCodeLine{06755\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}such\ that:\(\backslash\)n"{}}}
\DoxyCodeLine{06756\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#0\ and\ 1\ are\ a\ pair\ where\ the\ first\ is\ half\ of\ the\ second,\ "{}}}
\DoxyCodeLine{06757\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\(\backslash\)n"{}}}
\DoxyCodeLine{06758\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#1\ and\ 2\ are\ a\ pair\ where\ the\ first\ is\ half\ of\ the\ second,\ "{}}}
\DoxyCodeLine{06759\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\(\backslash\)n"{}}}
\DoxyCodeLine{06760\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ -\/\ element\ \#2\ and\ 3\ are\ a\ pair\ where\ the\ first\ is\ half\ of\ the\ second"{}},}
\DoxyCodeLine{06761\ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{06762\ \}}
\DoxyCodeLine{06763\ }
\DoxyCodeLine{06764\ TEST(UnorderedPointwiseTest,\ MakesCopyOfRhs)\ \{}
\DoxyCodeLine{06765\ \ \ list<signed\ char>\ rhs;}
\DoxyCodeLine{06766\ \ \ rhs.push\_back(2);}
\DoxyCodeLine{06767\ \ \ rhs.push\_back(4);}
\DoxyCodeLine{06768\ }
\DoxyCodeLine{06769\ \ \ \textcolor{keywordtype}{int}\ lhs[]\ =\ \{2,\ 1\};}
\DoxyCodeLine{06770\ \ \ \textcolor{keyword}{const}\ Matcher<\textcolor{keyword}{const}\ int\ (\&)[2]>\ m\ =\ UnorderedPointwise(IsHalfOf(),\ rhs);}
\DoxyCodeLine{06771\ \ \ EXPECT\_THAT(lhs,\ m);}
\DoxyCodeLine{06772\ }
\DoxyCodeLine{06773\ \ \ \textcolor{comment}{//\ Changing\ rhs\ now\ shouldn't\ affect\ m,\ which\ made\ a\ copy\ of\ rhs.}}
\DoxyCodeLine{06774\ \ \ rhs.push\_back(6);}
\DoxyCodeLine{06775\ \ \ EXPECT\_THAT(lhs,\ m);}
\DoxyCodeLine{06776\ \}}
\DoxyCodeLine{06777\ }
\DoxyCodeLine{06778\ TEST(UnorderedPointwiseTest,\ WorksForLhsNativeArray)\ \{}
\DoxyCodeLine{06779\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ lhs[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06780\ \ \ vector<int>\ rhs;}
\DoxyCodeLine{06781\ \ \ rhs.push\_back(4);}
\DoxyCodeLine{06782\ \ \ rhs.push\_back(6);}
\DoxyCodeLine{06783\ \ \ rhs.push\_back(2);}
\DoxyCodeLine{06784\ \ \ EXPECT\_THAT(lhs,\ UnorderedPointwise(Lt(),\ rhs));}
\DoxyCodeLine{06785\ \ \ EXPECT\_THAT(lhs,\ Not(UnorderedPointwise(Gt(),\ rhs)));}
\DoxyCodeLine{06786\ \}}
\DoxyCodeLine{06787\ }
\DoxyCodeLine{06788\ TEST(UnorderedPointwiseTest,\ WorksForRhsNativeArray)\ \{}
\DoxyCodeLine{06789\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06790\ \ \ vector<int>\ lhs;}
\DoxyCodeLine{06791\ \ \ lhs.push\_back(4);}
\DoxyCodeLine{06792\ \ \ lhs.push\_back(2);}
\DoxyCodeLine{06793\ \ \ lhs.push\_back(6);}
\DoxyCodeLine{06794\ \ \ EXPECT\_THAT(lhs,\ UnorderedPointwise(Gt(),\ rhs));}
\DoxyCodeLine{06795\ \ \ EXPECT\_THAT(lhs,\ Not(UnorderedPointwise(Lt(),\ rhs)));}
\DoxyCodeLine{06796\ \}}
\DoxyCodeLine{06797\ }
\DoxyCodeLine{06798\ }
\DoxyCodeLine{06799\ TEST(UnorderedPointwiseTest,\ WorksForRhsInitializerList)\ \{}
\DoxyCodeLine{06800\ \ \ \textcolor{keyword}{const}\ vector<int>\ lhs\{2,\ 4,\ 6\};}
\DoxyCodeLine{06801\ \ \ EXPECT\_THAT(lhs,\ UnorderedPointwise(Gt(),\ \{5,\ 1,\ 3\}));}
\DoxyCodeLine{06802\ \ \ EXPECT\_THAT(lhs,\ Not(UnorderedPointwise(Lt(),\ \{1,\ 1,\ 7\})));}
\DoxyCodeLine{06803\ \}}
\DoxyCodeLine{06804\ }
\DoxyCodeLine{06805\ }
\DoxyCodeLine{06806\ TEST(UnorderedPointwiseTest,\ RejectsWrongSize)\ \{}
\DoxyCodeLine{06807\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[2]\ =\ \{1,\ 2\};}
\DoxyCodeLine{06808\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[1]\ =\ \{0\};}
\DoxyCodeLine{06809\ \ \ EXPECT\_THAT(lhs,\ Not(UnorderedPointwise(Gt(),\ rhs)));}
\DoxyCodeLine{06810\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ has\ 2\ elements"{}},}
\DoxyCodeLine{06811\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(UnorderedPointwise(Gt(),\ rhs),\ lhs));}
\DoxyCodeLine{06812\ }
\DoxyCodeLine{06813\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs2[3]\ =\ \{0,\ 1,\ 2\};}
\DoxyCodeLine{06814\ \ \ EXPECT\_THAT(lhs,\ Not(UnorderedPointwise(Gt(),\ rhs2)));}
\DoxyCodeLine{06815\ \}}
\DoxyCodeLine{06816\ }
\DoxyCodeLine{06817\ TEST(UnorderedPointwiseTest,\ RejectsWrongContent)\ \{}
\DoxyCodeLine{06818\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[3]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06819\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[3]\ =\ \{2,\ 6,\ 6\};}
\DoxyCodeLine{06820\ \ \ EXPECT\_THAT(lhs,\ Not(UnorderedPointwise(IsHalfOf(),\ rhs)));}
\DoxyCodeLine{06821\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}where\ the\ following\ elements\ don't\ match\ any\ matchers:\(\backslash\)n"{}}}
\DoxyCodeLine{06822\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#1:\ 2"{}},}
\DoxyCodeLine{06823\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(UnorderedPointwise(IsHalfOf(),\ rhs),\ lhs));}
\DoxyCodeLine{06824\ \}}
\DoxyCodeLine{06825\ }
\DoxyCodeLine{06826\ TEST(UnorderedPointwiseTest,\ AcceptsCorrectContentInSameOrder)\ \{}
\DoxyCodeLine{06827\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[3]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06828\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[3]\ =\ \{2,\ 4,\ 6\};}
\DoxyCodeLine{06829\ \ \ EXPECT\_THAT(lhs,\ UnorderedPointwise(IsHalfOf(),\ rhs));}
\DoxyCodeLine{06830\ \}}
\DoxyCodeLine{06831\ }
\DoxyCodeLine{06832\ TEST(UnorderedPointwiseTest,\ AcceptsCorrectContentInDifferentOrder)\ \{}
\DoxyCodeLine{06833\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[3]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06834\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[3]\ =\ \{6,\ 4,\ 2\};}
\DoxyCodeLine{06835\ \ \ EXPECT\_THAT(lhs,\ UnorderedPointwise(IsHalfOf(),\ rhs));}
\DoxyCodeLine{06836\ \}}
\DoxyCodeLine{06837\ }
\DoxyCodeLine{06838\ TEST(UnorderedPointwiseTest,\ AllowsMonomorphicInnerMatcher)\ \{}
\DoxyCodeLine{06839\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{double}\ lhs[3]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{06840\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ rhs[3]\ =\ \{4,\ 6,\ 2\};}
\DoxyCodeLine{06841\ \ \ \textcolor{keyword}{const}\ Matcher<std::tuple<const\ double\&,\ const\ int\&>>\ m1\ =\ IsHalfOf();}
\DoxyCodeLine{06842\ \ \ EXPECT\_THAT(lhs,\ UnorderedPointwise(m1,\ rhs));}
\DoxyCodeLine{06843\ }
\DoxyCodeLine{06844\ \ \ \textcolor{comment}{//\ This\ type\ works\ as\ a\ std::tuple<const\ double\&,\ const\ int\&>\ can\ be}}
\DoxyCodeLine{06845\ \ \ \textcolor{comment}{//\ implicitly\ cast\ to\ std::tuple<double,\ int>.}}
\DoxyCodeLine{06846\ \ \ \textcolor{keyword}{const}\ Matcher<std::tuple<double,\ int>>\ m2\ =\ IsHalfOf();}
\DoxyCodeLine{06847\ \ \ EXPECT\_THAT(lhs,\ UnorderedPointwise(m2,\ rhs));}
\DoxyCodeLine{06848\ \}}
\DoxyCodeLine{06849\ }
\DoxyCodeLine{06850\ TEST(UnorderedPointwiseTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{06851\ \ \ ContainerHelper\ helper;}
\DoxyCodeLine{06852\ \ \ EXPECT\_CALL(helper,\ Call(UnorderedPointwise(PointeeEquals(),}
\DoxyCodeLine{06853\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<int>\{1,\ 2\})));}
\DoxyCodeLine{06854\ \ \ helper.Call(MakeUniquePtrs(\{2,\ 1\}));}
\DoxyCodeLine{06855\ \}}
\DoxyCodeLine{06856\ }
\DoxyCodeLine{06857\ \textcolor{comment}{//\ Sample\ optional\ type\ implementation\ with\ minimal\ requirements\ for\ use\ with}}
\DoxyCodeLine{06858\ \textcolor{comment}{//\ Optional\ matcher.}}
\DoxyCodeLine{06859\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{06860\ \textcolor{keyword}{class\ }SampleOptional\ \{}
\DoxyCodeLine{06861\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{06862\ \ \ \textcolor{keyword}{using\ }value\_type\ =\ T;}
\DoxyCodeLine{06863\ \ \ \textcolor{keyword}{explicit}\ SampleOptional(T\ value)}
\DoxyCodeLine{06864\ \ \ \ \ \ \ :\ value\_(std::move(value)),\ has\_value\_(true)\ \{\}}
\DoxyCodeLine{06865\ \ \ SampleOptional()\ :\ value\_(),\ has\_value\_(false)\ \{\}}
\DoxyCodeLine{06866\ \ \ \textcolor{keyword}{operator}\ bool()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ has\_value\_;\ \}}
\DoxyCodeLine{06867\ \ \ \textcolor{keyword}{const}\ T\&\ operator*()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ value\_;\ \}}
\DoxyCodeLine{06868\ }
\DoxyCodeLine{06869\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{06870\ \ \ T\ value\_;}
\DoxyCodeLine{06871\ \ \ \textcolor{keywordtype}{bool}\ has\_value\_;}
\DoxyCodeLine{06872\ \};}
\DoxyCodeLine{06873\ }
\DoxyCodeLine{06874\ TEST(OptionalTest,\ DescribesSelf)\ \{}
\DoxyCodeLine{06875\ \ \ \textcolor{keyword}{const}\ Matcher<SampleOptional<int>>\ m\ =\ Optional(Eq(1));}
\DoxyCodeLine{06876\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}value\ is\ equal\ to\ 1"{}},\ Describe(m));}
\DoxyCodeLine{06877\ \}}
\DoxyCodeLine{06878\ }
\DoxyCodeLine{06879\ TEST(OptionalTest,\ ExplainsSelf)\ \{}
\DoxyCodeLine{06880\ \ \ \textcolor{keyword}{const}\ Matcher<SampleOptional<int>>\ m\ =\ Optional(Eq(1));}
\DoxyCodeLine{06881\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ value\ 1\ matches"{}},\ Explain(m,\ SampleOptional<int>(1)));}
\DoxyCodeLine{06882\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ value\ 2\ doesn't\ match"{}},\ Explain(m,\ SampleOptional<int>(2)));}
\DoxyCodeLine{06883\ \}}
\DoxyCodeLine{06884\ }
\DoxyCodeLine{06885\ TEST(OptionalTest,\ MatchesNonEmptyOptional)\ \{}
\DoxyCodeLine{06886\ \ \ \textcolor{keyword}{const}\ Matcher<SampleOptional<int>>\ m1\ =\ Optional(1);}
\DoxyCodeLine{06887\ \ \ \textcolor{keyword}{const}\ Matcher<SampleOptional<int>>\ m2\ =\ Optional(Eq(2));}
\DoxyCodeLine{06888\ \ \ \textcolor{keyword}{const}\ Matcher<SampleOptional<int>>\ m3\ =\ Optional(Lt(3));}
\DoxyCodeLine{06889\ \ \ SampleOptional<int>\ opt(1);}
\DoxyCodeLine{06890\ \ \ EXPECT\_TRUE(m1.Matches(opt));}
\DoxyCodeLine{06891\ \ \ EXPECT\_FALSE(m2.Matches(opt));}
\DoxyCodeLine{06892\ \ \ EXPECT\_TRUE(m3.Matches(opt));}
\DoxyCodeLine{06893\ \}}
\DoxyCodeLine{06894\ }
\DoxyCodeLine{06895\ TEST(OptionalTest,\ DoesNotMatchNullopt)\ \{}
\DoxyCodeLine{06896\ \ \ \textcolor{keyword}{const}\ Matcher<SampleOptional<int>>\ m\ =\ Optional(1);}
\DoxyCodeLine{06897\ \ \ SampleOptional<int>\ empty;}
\DoxyCodeLine{06898\ \ \ EXPECT\_FALSE(m.Matches(empty));}
\DoxyCodeLine{06899\ \}}
\DoxyCodeLine{06900\ }
\DoxyCodeLine{06901\ TEST(OptionalTest,\ WorksWithMoveOnly)\ \{}
\DoxyCodeLine{06902\ \ \ Matcher<SampleOptional<std::unique\_ptr<int>>>\ m\ =\ Optional(Eq(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{06903\ \ \ EXPECT\_TRUE(m.Matches(SampleOptional<std::unique\_ptr<int>>(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{06904\ \}}
\DoxyCodeLine{06905\ }
\DoxyCodeLine{06906\ \textcolor{keyword}{class\ }SampleVariantIntString\ \{}
\DoxyCodeLine{06907\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{06908\ \ \ SampleVariantIntString(\textcolor{keywordtype}{int}\ i)\ :\ i\_(i),\ has\_int\_(true)\ \{\}}
\DoxyCodeLine{06909\ \ \ SampleVariantIntString(\textcolor{keyword}{const}\ std::string\&\ s)\ :\ s\_(s),\ has\_int\_(false)\ \{\}}
\DoxyCodeLine{06910\ }
\DoxyCodeLine{06911\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{06912\ \ \ \textcolor{keyword}{friend}\ \textcolor{keywordtype}{bool}\ holds\_alternative(\textcolor{keyword}{const}\ SampleVariantIntString\&\ value)\ \{}
\DoxyCodeLine{06913\ \ \ \ \ \textcolor{keywordflow}{return}\ value.has\_int\_\ ==\ std::is\_same<T,\ int>::value;}
\DoxyCodeLine{06914\ \ \ \}}
\DoxyCodeLine{06915\ }
\DoxyCodeLine{06916\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{06917\ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{const}\ T\&\ get(\textcolor{keyword}{const}\ SampleVariantIntString\&\ value)\ \{}
\DoxyCodeLine{06918\ \ \ \ \ \textcolor{keywordflow}{return}\ value.get\_impl(\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{06919\ \ \ \}}
\DoxyCodeLine{06920\ }
\DoxyCodeLine{06921\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{06922\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\&\ get\_impl(\textcolor{keywordtype}{int}*)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ i\_;\ \}}
\DoxyCodeLine{06923\ \ \ \textcolor{keyword}{const}\ std::string\&\ get\_impl(std::string*)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ s\_;\ \}}
\DoxyCodeLine{06924\ }
\DoxyCodeLine{06925\ \ \ \textcolor{keywordtype}{int}\ i\_;}
\DoxyCodeLine{06926\ \ \ std::string\ s\_;}
\DoxyCodeLine{06927\ \ \ \textcolor{keywordtype}{bool}\ has\_int\_;}
\DoxyCodeLine{06928\ \};}
\DoxyCodeLine{06929\ }
\DoxyCodeLine{06930\ TEST(VariantTest,\ DescribesSelf)\ \{}
\DoxyCodeLine{06931\ \ \ \textcolor{keyword}{const}\ Matcher<SampleVariantIntString>\ m\ =\ VariantWith<int>(Eq(1));}
\DoxyCodeLine{06932\ \ \ EXPECT\_THAT(Describe(m),\ ContainsRegex(\textcolor{stringliteral}{"{}is\ a\ variant<>\ with\ value\ of\ type\ "{}}}
\DoxyCodeLine{06933\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}'.*'\ and\ the\ value\ is\ equal\ to\ 1"{}}));}
\DoxyCodeLine{06934\ \}}
\DoxyCodeLine{06935\ }
\DoxyCodeLine{06936\ TEST(VariantTest,\ ExplainsSelf)\ \{}
\DoxyCodeLine{06937\ \ \ \textcolor{keyword}{const}\ Matcher<SampleVariantIntString>\ m\ =\ VariantWith<int>(Eq(1));}
\DoxyCodeLine{06938\ \ \ EXPECT\_THAT(Explain(m,\ SampleVariantIntString(1)),}
\DoxyCodeLine{06939\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ContainsRegex(\textcolor{stringliteral}{"{}whose\ value\ 1"{}}));}
\DoxyCodeLine{06940\ \ \ EXPECT\_THAT(Explain(m,\ SampleVariantIntString(\textcolor{stringliteral}{"{}A"{}})),}
\DoxyCodeLine{06941\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ HasSubstr(\textcolor{stringliteral}{"{}whose\ value\ is\ not\ of\ type\ '"{}}));}
\DoxyCodeLine{06942\ \ \ EXPECT\_THAT(Explain(m,\ SampleVariantIntString(2)),}
\DoxyCodeLine{06943\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ value\ 2\ doesn't\ match"{}});}
\DoxyCodeLine{06944\ \}}
\DoxyCodeLine{06945\ }
\DoxyCodeLine{06946\ TEST(VariantTest,\ FullMatch)\ \{}
\DoxyCodeLine{06947\ \ \ Matcher<SampleVariantIntString>\ m\ =\ VariantWith<int>(Eq(1));}
\DoxyCodeLine{06948\ \ \ EXPECT\_TRUE(m.Matches(SampleVariantIntString(1)));}
\DoxyCodeLine{06949\ }
\DoxyCodeLine{06950\ \ \ m\ =\ VariantWith<std::string>(Eq(\textcolor{stringliteral}{"{}1"{}}));}
\DoxyCodeLine{06951\ \ \ EXPECT\_TRUE(m.Matches(SampleVariantIntString(\textcolor{stringliteral}{"{}1"{}})));}
\DoxyCodeLine{06952\ \}}
\DoxyCodeLine{06953\ }
\DoxyCodeLine{06954\ TEST(VariantTest,\ TypeDoesNotMatch)\ \{}
\DoxyCodeLine{06955\ \ \ Matcher<SampleVariantIntString>\ m\ =\ VariantWith<int>(Eq(1));}
\DoxyCodeLine{06956\ \ \ EXPECT\_FALSE(m.Matches(SampleVariantIntString(\textcolor{stringliteral}{"{}1"{}})));}
\DoxyCodeLine{06957\ }
\DoxyCodeLine{06958\ \ \ m\ =\ VariantWith<std::string>(Eq(\textcolor{stringliteral}{"{}1"{}}));}
\DoxyCodeLine{06959\ \ \ EXPECT\_FALSE(m.Matches(SampleVariantIntString(1)));}
\DoxyCodeLine{06960\ \}}
\DoxyCodeLine{06961\ }
\DoxyCodeLine{06962\ TEST(VariantTest,\ InnerDoesNotMatch)\ \{}
\DoxyCodeLine{06963\ \ \ Matcher<SampleVariantIntString>\ m\ =\ VariantWith<int>(Eq(1));}
\DoxyCodeLine{06964\ \ \ EXPECT\_FALSE(m.Matches(SampleVariantIntString(2)));}
\DoxyCodeLine{06965\ }
\DoxyCodeLine{06966\ \ \ m\ =\ VariantWith<std::string>(Eq(\textcolor{stringliteral}{"{}1"{}}));}
\DoxyCodeLine{06967\ \ \ EXPECT\_FALSE(m.Matches(SampleVariantIntString(\textcolor{stringliteral}{"{}2"{}})));}
\DoxyCodeLine{06968\ \}}
\DoxyCodeLine{06969\ }
\DoxyCodeLine{06970\ \textcolor{keyword}{class\ }SampleAnyType\ \{}
\DoxyCodeLine{06971\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{06972\ \ \ \textcolor{keyword}{explicit}\ SampleAnyType(\textcolor{keywordtype}{int}\ i)\ :\ index\_(0),\ i\_(i)\ \{\}}
\DoxyCodeLine{06973\ \ \ \textcolor{keyword}{explicit}\ SampleAnyType(\textcolor{keyword}{const}\ std::string\&\ s)\ :\ index\_(1),\ s\_(s)\ \{\}}
\DoxyCodeLine{06974\ }
\DoxyCodeLine{06975\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{06976\ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{const}\ T*\ any\_cast(\textcolor{keyword}{const}\ SampleAnyType*\ any)\ \{}
\DoxyCodeLine{06977\ \ \ \ \ \textcolor{keywordflow}{return}\ any-\/>get\_impl(\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{06978\ \ \ \}}
\DoxyCodeLine{06979\ }
\DoxyCodeLine{06980\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{06981\ \ \ \textcolor{keywordtype}{int}\ index\_;}
\DoxyCodeLine{06982\ \ \ \textcolor{keywordtype}{int}\ i\_;}
\DoxyCodeLine{06983\ \ \ std::string\ s\_;}
\DoxyCodeLine{06984\ }
\DoxyCodeLine{06985\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ get\_impl(\textcolor{keywordtype}{int}*)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ index\_\ ==\ 0\ ?\ \&i\_\ :\ \textcolor{keyword}{nullptr};\ \}}
\DoxyCodeLine{06986\ \ \ \textcolor{keyword}{const}\ std::string*\ get\_impl(std::string*)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{06987\ \ \ \ \ \textcolor{keywordflow}{return}\ index\_\ ==\ 1\ ?\ \&s\_\ :\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{06988\ \ \ \}}
\DoxyCodeLine{06989\ \};}
\DoxyCodeLine{06990\ }
\DoxyCodeLine{06991\ TEST(AnyWithTest,\ FullMatch)\ \{}
\DoxyCodeLine{06992\ \ \ Matcher<SampleAnyType>\ m\ =\ AnyWith<int>(Eq(1));}
\DoxyCodeLine{06993\ \ \ EXPECT\_TRUE(m.Matches(SampleAnyType(1)));}
\DoxyCodeLine{06994\ \}}
\DoxyCodeLine{06995\ }
\DoxyCodeLine{06996\ TEST(AnyWithTest,\ TestBadCastType)\ \{}
\DoxyCodeLine{06997\ \ \ Matcher<SampleAnyType>\ m\ =\ AnyWith<std::string>(Eq(\textcolor{stringliteral}{"{}fail"{}}));}
\DoxyCodeLine{06998\ \ \ EXPECT\_FALSE(m.Matches(SampleAnyType(1)));}
\DoxyCodeLine{06999\ \}}
\DoxyCodeLine{07000\ }
\DoxyCodeLine{07001\ TEST(AnyWithTest,\ TestUseInContainers)\ \{}
\DoxyCodeLine{07002\ \ \ std::vector<SampleAnyType>\ a;}
\DoxyCodeLine{07003\ \ \ a.emplace\_back(1);}
\DoxyCodeLine{07004\ \ \ a.emplace\_back(2);}
\DoxyCodeLine{07005\ \ \ a.emplace\_back(3);}
\DoxyCodeLine{07006\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{07007\ \ \ \ \ \ \ a,\ ElementsAreArray(\{AnyWith<int>(1),\ AnyWith<int>(2),\ AnyWith<int>(3)\}));}
\DoxyCodeLine{07008\ }
\DoxyCodeLine{07009\ \ \ std::vector<SampleAnyType>\ b;}
\DoxyCodeLine{07010\ \ \ b.emplace\_back(\textcolor{stringliteral}{"{}hello"{}});}
\DoxyCodeLine{07011\ \ \ b.emplace\_back(\textcolor{stringliteral}{"{}merhaba"{}});}
\DoxyCodeLine{07012\ \ \ b.emplace\_back(\textcolor{stringliteral}{"{}salut"{}});}
\DoxyCodeLine{07013\ \ \ EXPECT\_THAT(b,\ ElementsAreArray(\{AnyWith<std::string>(\textcolor{stringliteral}{"{}hello"{}}),}
\DoxyCodeLine{07014\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AnyWith<std::string>(\textcolor{stringliteral}{"{}merhaba"{}}),}
\DoxyCodeLine{07015\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ AnyWith<std::string>(\textcolor{stringliteral}{"{}salut"{}})\}));}
\DoxyCodeLine{07016\ \}}
\DoxyCodeLine{07017\ TEST(AnyWithTest,\ TestCompare)\ \{}
\DoxyCodeLine{07018\ \ \ EXPECT\_THAT(SampleAnyType(1),\ AnyWith<int>(Gt(0)));}
\DoxyCodeLine{07019\ \}}
\DoxyCodeLine{07020\ }
\DoxyCodeLine{07021\ TEST(AnyWithTest,\ DescribesSelf)\ \{}
\DoxyCodeLine{07022\ \ \ \textcolor{keyword}{const}\ Matcher<const\ SampleAnyType\&>\ m\ =\ AnyWith<int>(Eq(1));}
\DoxyCodeLine{07023\ \ \ EXPECT\_THAT(Describe(m),\ ContainsRegex(\textcolor{stringliteral}{"{}is\ an\ 'any'\ type\ with\ value\ of\ type\ "{}}}
\DoxyCodeLine{07024\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}'.*'\ and\ the\ value\ is\ equal\ to\ 1"{}}));}
\DoxyCodeLine{07025\ \}}
\DoxyCodeLine{07026\ }
\DoxyCodeLine{07027\ TEST(AnyWithTest,\ ExplainsSelf)\ \{}
\DoxyCodeLine{07028\ \ \ \textcolor{keyword}{const}\ Matcher<const\ SampleAnyType\&>\ m\ =\ AnyWith<int>(Eq(1));}
\DoxyCodeLine{07029\ }
\DoxyCodeLine{07030\ \ \ EXPECT\_THAT(Explain(m,\ SampleAnyType(1)),\ ContainsRegex(\textcolor{stringliteral}{"{}whose\ value\ 1"{}}));}
\DoxyCodeLine{07031\ \ \ EXPECT\_THAT(Explain(m,\ SampleAnyType(\textcolor{stringliteral}{"{}A"{}})),}
\DoxyCodeLine{07032\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ HasSubstr(\textcolor{stringliteral}{"{}whose\ value\ is\ not\ of\ type\ '"{}}));}
\DoxyCodeLine{07033\ \ \ EXPECT\_THAT(Explain(m,\ SampleAnyType(2)),\ \textcolor{stringliteral}{"{}whose\ value\ 2\ doesn't\ match"{}});}
\DoxyCodeLine{07034\ \}}
\DoxyCodeLine{07035\ }
\DoxyCodeLine{07036\ TEST(PointeeTest,\ WorksOnMoveOnlyType)\ \{}
\DoxyCodeLine{07037\ \ \ std::unique\_ptr<int>\ p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(3));}
\DoxyCodeLine{07038\ \ \ EXPECT\_THAT(p,\ Pointee(Eq(3)));}
\DoxyCodeLine{07039\ \ \ EXPECT\_THAT(p,\ Not(Pointee(Eq(2))));}
\DoxyCodeLine{07040\ \}}
\DoxyCodeLine{07041\ }
\DoxyCodeLine{07042\ TEST(NotTest,\ WorksOnMoveOnlyType)\ \{}
\DoxyCodeLine{07043\ \ \ std::unique\_ptr<int>\ p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(3));}
\DoxyCodeLine{07044\ \ \ EXPECT\_THAT(p,\ Pointee(Eq(3)));}
\DoxyCodeLine{07045\ \ \ EXPECT\_THAT(p,\ Not(Pointee(Eq(2))));}
\DoxyCodeLine{07046\ \}}
\DoxyCodeLine{07047\ }
\DoxyCodeLine{07048\ \textcolor{comment}{//\ Tests\ Args<k0,\ ...,\ kn>(m).}}
\DoxyCodeLine{07049\ }
\DoxyCodeLine{07050\ TEST(ArgsTest,\ AcceptsZeroTemplateArg)\ \{}
\DoxyCodeLine{07051\ \ \ \textcolor{keyword}{const}\ std::tuple<int,\ bool>\ t(5,\ \textcolor{keyword}{true});}
\DoxyCodeLine{07052\ \ \ EXPECT\_THAT(t,\ Args<>(Eq(std::tuple<>())));}
\DoxyCodeLine{07053\ \ \ EXPECT\_THAT(t,\ Not(Args<>(Ne(std::tuple<>()))));}
\DoxyCodeLine{07054\ \}}
\DoxyCodeLine{07055\ }
\DoxyCodeLine{07056\ TEST(ArgsTest,\ AcceptsOneTemplateArg)\ \{}
\DoxyCodeLine{07057\ \ \ \textcolor{keyword}{const}\ std::tuple<int,\ bool>\ t(5,\ \textcolor{keyword}{true});}
\DoxyCodeLine{07058\ \ \ EXPECT\_THAT(t,\ Args<0>(Eq(std::make\_tuple(5))));}
\DoxyCodeLine{07059\ \ \ EXPECT\_THAT(t,\ Args<1>(Eq(std::make\_tuple(\textcolor{keyword}{true}))));}
\DoxyCodeLine{07060\ \ \ EXPECT\_THAT(t,\ Not(Args<1>(Eq(std::make\_tuple(\textcolor{keyword}{false})))));}
\DoxyCodeLine{07061\ \}}
\DoxyCodeLine{07062\ }
\DoxyCodeLine{07063\ TEST(ArgsTest,\ AcceptsTwoTemplateArgs)\ \{}
\DoxyCodeLine{07064\ \ \ \textcolor{keyword}{const}\ std::tuple<short,\ int,\ long>\ t(4,\ 5,\ 6L);\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{07065\ }
\DoxyCodeLine{07066\ \ \ EXPECT\_THAT(t,\ (Args<0,\ 1>(Lt())));}
\DoxyCodeLine{07067\ \ \ EXPECT\_THAT(t,\ (Args<1,\ 2>(Lt())));}
\DoxyCodeLine{07068\ \ \ EXPECT\_THAT(t,\ Not(Args<0,\ 2>(Gt())));}
\DoxyCodeLine{07069\ \}}
\DoxyCodeLine{07070\ }
\DoxyCodeLine{07071\ TEST(ArgsTest,\ AcceptsRepeatedTemplateArgs)\ \{}
\DoxyCodeLine{07072\ \ \ \textcolor{keyword}{const}\ std::tuple<short,\ int,\ long>\ t(4,\ 5,\ 6L);\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{07073\ \ \ EXPECT\_THAT(t,\ (Args<0,\ 0>(Eq())));}
\DoxyCodeLine{07074\ \ \ EXPECT\_THAT(t,\ Not(Args<1,\ 1>(Ne())));}
\DoxyCodeLine{07075\ \}}
\DoxyCodeLine{07076\ }
\DoxyCodeLine{07077\ TEST(ArgsTest,\ AcceptsDecreasingTemplateArgs)\ \{}
\DoxyCodeLine{07078\ \ \ \textcolor{keyword}{const}\ std::tuple<short,\ int,\ long>\ t(4,\ 5,\ 6L);\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{07079\ \ \ EXPECT\_THAT(t,\ (Args<2,\ 0>(Gt())));}
\DoxyCodeLine{07080\ \ \ EXPECT\_THAT(t,\ Not(Args<2,\ 1>(Lt())));}
\DoxyCodeLine{07081\ \}}
\DoxyCodeLine{07082\ }
\DoxyCodeLine{07083\ MATCHER(SumIsZero,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07084\ \ \ \textcolor{keywordflow}{return}\ std::get<0>(arg)\ +\ std::get<1>(arg)\ +\ std::get<2>(arg)\ ==\ 0;}
\DoxyCodeLine{07085\ \}}
\DoxyCodeLine{07086\ }
\DoxyCodeLine{07087\ TEST(ArgsTest,\ AcceptsMoreTemplateArgsThanArityOfOriginalTuple)\ \{}
\DoxyCodeLine{07088\ \ \ EXPECT\_THAT(std::make\_tuple(-\/1,\ 2),\ (Args<0,\ 0,\ 1>(SumIsZero())));}
\DoxyCodeLine{07089\ \ \ EXPECT\_THAT(std::make\_tuple(1,\ 2),\ Not(Args<0,\ 0,\ 1>(SumIsZero())));}
\DoxyCodeLine{07090\ \}}
\DoxyCodeLine{07091\ }
\DoxyCodeLine{07092\ TEST(ArgsTest,\ CanBeNested)\ \{}
\DoxyCodeLine{07093\ \ \ \textcolor{keyword}{const}\ std::tuple<short,\ int,\ long,\ int>\ t(4,\ 5,\ 6L,\ 6);\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{07094\ \ \ EXPECT\_THAT(t,\ (Args<1,\ 2,\ 3>(Args<1,\ 2>(Eq()))));}
\DoxyCodeLine{07095\ \ \ EXPECT\_THAT(t,\ (Args<0,\ 1,\ 3>(Args<0,\ 2>(Lt()))));}
\DoxyCodeLine{07096\ \}}
\DoxyCodeLine{07097\ }
\DoxyCodeLine{07098\ TEST(ArgsTest,\ CanMatchTupleByValue)\ \{}
\DoxyCodeLine{07099\ \ \ \textcolor{keyword}{typedef}\ std::tuple<char,\ int,\ int>\ Tuple3;}
\DoxyCodeLine{07100\ \ \ \textcolor{keyword}{const}\ Matcher<Tuple3>\ m\ =\ Args<1,\ 2>(Lt());}
\DoxyCodeLine{07101\ \ \ EXPECT\_TRUE(m.Matches(Tuple3(\textcolor{charliteral}{'a'},\ 1,\ 2)));}
\DoxyCodeLine{07102\ \ \ EXPECT\_FALSE(m.Matches(Tuple3(\textcolor{charliteral}{'b'},\ 2,\ 2)));}
\DoxyCodeLine{07103\ \}}
\DoxyCodeLine{07104\ }
\DoxyCodeLine{07105\ TEST(ArgsTest,\ CanMatchTupleByReference)\ \{}
\DoxyCodeLine{07106\ \ \ \textcolor{keyword}{typedef}\ std::tuple<char,\ char,\ int>\ Tuple3;}
\DoxyCodeLine{07107\ \ \ \textcolor{keyword}{const}\ Matcher<const\ Tuple3\&>\ m\ =\ Args<0,\ 1>(Lt());}
\DoxyCodeLine{07108\ \ \ EXPECT\_TRUE(m.Matches(Tuple3(\textcolor{charliteral}{'a'},\ \textcolor{charliteral}{'b'},\ 2)));}
\DoxyCodeLine{07109\ \ \ EXPECT\_FALSE(m.Matches(Tuple3(\textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'b'},\ 2)));}
\DoxyCodeLine{07110\ \}}
\DoxyCodeLine{07111\ }
\DoxyCodeLine{07112\ \textcolor{comment}{//\ Validates\ that\ arg\ is\ printed\ as\ str.}}
\DoxyCodeLine{07113\ MATCHER\_P(PrintsAs,\ str,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07114\ \ \ \textcolor{keywordflow}{return}\ testing::PrintToString(arg)\ ==\ str;}
\DoxyCodeLine{07115\ \}}
\DoxyCodeLine{07116\ }
\DoxyCodeLine{07117\ TEST(ArgsTest,\ AcceptsTenTemplateArgs)\ \{}
\DoxyCodeLine{07118\ \ \ EXPECT\_THAT(std::make\_tuple(0,\ 1L,\ 2,\ 3L,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9),}
\DoxyCodeLine{07119\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (Args<9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0>(}
\DoxyCodeLine{07120\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PrintsAs(\textcolor{stringliteral}{"{}(9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0)"{}}))));}
\DoxyCodeLine{07121\ \ \ EXPECT\_THAT(std::make\_tuple(0,\ 1L,\ 2,\ 3L,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9),}
\DoxyCodeLine{07122\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Not(Args<9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0>(}
\DoxyCodeLine{07123\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PrintsAs(\textcolor{stringliteral}{"{}(0,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0)"{}}))));}
\DoxyCodeLine{07124\ \}}
\DoxyCodeLine{07125\ }
\DoxyCodeLine{07126\ TEST(ArgsTest,\ DescirbesSelfCorrectly)\ \{}
\DoxyCodeLine{07127\ \ \ \textcolor{keyword}{const}\ Matcher<std::tuple<int,\ bool,\ char>\ >\ m\ =\ Args<2,\ 0>(Lt());}
\DoxyCodeLine{07128\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ a\ tuple\ whose\ fields\ (\#2,\ \#0)\ are\ a\ pair\ where\ "{}}}
\DoxyCodeLine{07129\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}the\ first\ <\ the\ second"{}},}
\DoxyCodeLine{07130\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{07131\ \}}
\DoxyCodeLine{07132\ }
\DoxyCodeLine{07133\ TEST(ArgsTest,\ DescirbesNestedArgsCorrectly)\ \{}
\DoxyCodeLine{07134\ \ \ \textcolor{keyword}{const}\ Matcher<const\ std::tuple<int,\ bool,\ char,\ int>\&>\ m\ =}
\DoxyCodeLine{07135\ \ \ \ \ \ \ Args<0,\ 2,\ 3>(Args<2,\ 0>(Lt()));}
\DoxyCodeLine{07136\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ a\ tuple\ whose\ fields\ (\#0,\ \#2,\ \#3)\ are\ a\ tuple\ "{}}}
\DoxyCodeLine{07137\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ fields\ (\#2,\ \#0)\ are\ a\ pair\ where\ the\ first\ <\ the\ second"{}},}
\DoxyCodeLine{07138\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{07139\ \}}
\DoxyCodeLine{07140\ }
\DoxyCodeLine{07141\ TEST(ArgsTest,\ DescribesNegationCorrectly)\ \{}
\DoxyCodeLine{07142\ \ \ \textcolor{keyword}{const}\ Matcher<std::tuple<int,\ char>\ >\ m\ =\ Args<1,\ 0>(Gt());}
\DoxyCodeLine{07143\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}are\ a\ tuple\ whose\ fields\ (\#1,\ \#0)\ aren't\ a\ pair\ "{}}}
\DoxyCodeLine{07144\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}where\ the\ first\ >\ the\ second"{}},}
\DoxyCodeLine{07145\ \ \ \ \ \ \ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{07146\ \}}
\DoxyCodeLine{07147\ }
\DoxyCodeLine{07148\ TEST(ArgsTest,\ ExplainsMatchResultWithoutInnerExplanation)\ \{}
\DoxyCodeLine{07149\ \ \ \textcolor{keyword}{const}\ Matcher<std::tuple<bool,\ int,\ int>\ >\ m\ =\ Args<1,\ 2>(Eq());}
\DoxyCodeLine{07150\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ fields\ (\#1,\ \#2)\ are\ (42,\ 42)"{}},}
\DoxyCodeLine{07151\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(\textcolor{keyword}{false},\ 42,\ 42)));}
\DoxyCodeLine{07152\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ fields\ (\#1,\ \#2)\ are\ (42,\ 43)"{}},}
\DoxyCodeLine{07153\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(\textcolor{keyword}{false},\ 42,\ 43)));}
\DoxyCodeLine{07154\ \}}
\DoxyCodeLine{07155\ }
\DoxyCodeLine{07156\ \textcolor{comment}{//\ For\ testing\ Args<>'s\ explanation.}}
\DoxyCodeLine{07157\ \textcolor{keyword}{class\ }LessThanMatcher\ :\ \textcolor{keyword}{public}\ MatcherInterface<std::tuple<char,\ int>\ >\ \{}
\DoxyCodeLine{07158\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{07159\ \ \ \textcolor{keywordtype}{void}\ DescribeTo(::std::ostream*\ \textcolor{comment}{/*os*/})\textcolor{keyword}{\ const\ override\ }\{\}}
\DoxyCodeLine{07160\ }
\DoxyCodeLine{07161\ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(std::tuple<char,\ int>\ value,}
\DoxyCodeLine{07162\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{07163\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ diff\ =\ std::get<0>(value)\ -\/\ std::get<1>(value);}
\DoxyCodeLine{07164\ \ \ \ \ \textcolor{keywordflow}{if}\ (diff\ >\ 0)\ \{}
\DoxyCodeLine{07165\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}where\ the\ first\ value\ is\ "{}}\ <<\ diff}
\DoxyCodeLine{07166\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}\ more\ than\ the\ second"{}};}
\DoxyCodeLine{07167\ \ \ \ \ \}}
\DoxyCodeLine{07168\ \ \ \ \ \textcolor{keywordflow}{return}\ diff\ <\ 0;}
\DoxyCodeLine{07169\ \ \ \}}
\DoxyCodeLine{07170\ \};}
\DoxyCodeLine{07171\ }
\DoxyCodeLine{07172\ Matcher<std::tuple<char,\ int>\ >\ LessThan()\ \{}
\DoxyCodeLine{07173\ \ \ \textcolor{keywordflow}{return}\ MakeMatcher(\textcolor{keyword}{new}\ LessThanMatcher);}
\DoxyCodeLine{07174\ \}}
\DoxyCodeLine{07175\ }
\DoxyCodeLine{07176\ TEST(ArgsTest,\ ExplainsMatchResultWithInnerExplanation)\ \{}
\DoxyCodeLine{07177\ \ \ \textcolor{keyword}{const}\ Matcher<std::tuple<char,\ int,\ int>\ >\ m\ =\ Args<0,\ 2>(LessThan());}
\DoxyCodeLine{07178\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{07179\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ fields\ (\#0,\ \#2)\ are\ ('a'\ (97,\ 0x61),\ 42),\ "{}}}
\DoxyCodeLine{07180\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}where\ the\ first\ value\ is\ 55\ more\ than\ the\ second"{}},}
\DoxyCodeLine{07181\ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(\textcolor{charliteral}{'a'},\ 42,\ 42)));}
\DoxyCodeLine{07182\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ fields\ (\#0,\ \#2)\ are\ ('\(\backslash\)\(\backslash\)0',\ 43)"{}},}
\DoxyCodeLine{07183\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ std::make\_tuple(\textcolor{charliteral}{'\(\backslash\)0'},\ 42,\ 43)));}
\DoxyCodeLine{07184\ \}}
\DoxyCodeLine{07185\ }
\DoxyCodeLine{07186\ \textcolor{keyword}{class\ }PredicateFormatterFromMatcherTest\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classtesting_1_1_test}{::testing::Test}}\ \{}
\DoxyCodeLine{07187\ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{07188\ \ \ \textcolor{keyword}{enum}\ Behavior\ \{\ kInitialSuccess,\ kAlwaysFail,\ kFlaky\ \};}
\DoxyCodeLine{07189\ }
\DoxyCodeLine{07190\ \ \ \textcolor{comment}{//\ A\ matcher\ that\ can\ return\ different\ results\ when\ used\ multiple\ times\ on\ the}}
\DoxyCodeLine{07191\ \ \ \textcolor{comment}{//\ same\ input.\ No\ real\ matcher\ should\ do\ this;\ but\ this\ lets\ us\ test\ that\ we}}
\DoxyCodeLine{07192\ \ \ \textcolor{comment}{//\ detect\ such\ behavior\ and\ fail\ appropriately.}}
\DoxyCodeLine{07193\ \ \ \textcolor{keyword}{class\ }MockMatcher\ :\ \textcolor{keyword}{public}\ MatcherInterface<Behavior>\ \{}
\DoxyCodeLine{07194\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{07195\ \ \ \ \ \textcolor{keywordtype}{bool}\ MatchAndExplain(Behavior\ behavior,}
\DoxyCodeLine{07196\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ MatchResultListener*\ listener)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{07197\ \ \ \ \ \ \ *listener\ <<\ \textcolor{stringliteral}{"{}[MatchAndExplain]"{}};}
\DoxyCodeLine{07198\ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (behavior)\ \{}
\DoxyCodeLine{07199\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ kInitialSuccess:}
\DoxyCodeLine{07200\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ first\ call\ to\ MatchAndExplain\ should\ use\ a\ "{}not\ interested"{}}}
\DoxyCodeLine{07201\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ listener;\ so\ this\ is\ expected\ to\ return\ |true|.\ There\ should\ be\ no}}
\DoxyCodeLine{07202\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ subsequent\ calls.}}
\DoxyCodeLine{07203\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ !listener-\/>IsInterested();}
\DoxyCodeLine{07204\ }
\DoxyCodeLine{07205\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ kAlwaysFail:}
\DoxyCodeLine{07206\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{07207\ }
\DoxyCodeLine{07208\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ kFlaky:}
\DoxyCodeLine{07209\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ first\ call\ to\ MatchAndExplain\ should\ use\ a\ "{}not\ interested"{}}}
\DoxyCodeLine{07210\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ listener;\ so\ this\ will\ return\ |false|.\ Subsequent\ calls\ should\ have}}
\DoxyCodeLine{07211\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ an\ "{}interested"{}\ listener;\ so\ this\ will\ return\ |true|,\ thus}}
\DoxyCodeLine{07212\ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ simulating\ a\ flaky\ matcher.}}
\DoxyCodeLine{07213\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ listener-\/>IsInterested();}
\DoxyCodeLine{07214\ \ \ \ \ \ \ \}}
\DoxyCodeLine{07215\ }
\DoxyCodeLine{07216\ \ \ \ \ \ \ GTEST\_LOG\_(FATAL)\ <<\ \textcolor{stringliteral}{"{}This\ should\ never\ be\ reached"{}};}
\DoxyCodeLine{07217\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{07218\ \ \ \ \ \}}
\DoxyCodeLine{07219\ }
\DoxyCodeLine{07220\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeTo(ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{\ *os\ <<\ \textcolor{stringliteral}{"{}[DescribeTo]"{}};\ \}}
\DoxyCodeLine{07221\ }
\DoxyCodeLine{07222\ \ \ \ \ \textcolor{keywordtype}{void}\ DescribeNegationTo(ostream*\ os)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{07223\ \ \ \ \ \ \ *os\ <<\ \textcolor{stringliteral}{"{}[DescribeNegationTo]"{}};}
\DoxyCodeLine{07224\ \ \ \ \ \}}
\DoxyCodeLine{07225\ \ \ \};}
\DoxyCodeLine{07226\ }
\DoxyCodeLine{07227\ \ \ AssertionResult\ RunPredicateFormatter(Behavior\ behavior)\ \{}
\DoxyCodeLine{07228\ \ \ \ \ \textcolor{keyword}{auto}\ matcher\ =\ MakeMatcher(\textcolor{keyword}{new}\ MockMatcher);}
\DoxyCodeLine{07229\ \ \ \ \ PredicateFormatterFromMatcher<Matcher<Behavior>>\ predicate\_formatter(}
\DoxyCodeLine{07230\ \ \ \ \ \ \ \ \ matcher);}
\DoxyCodeLine{07231\ \ \ \ \ \textcolor{keywordflow}{return}\ predicate\_formatter(\textcolor{stringliteral}{"{}dummy-\/name"{}},\ behavior);}
\DoxyCodeLine{07232\ \ \ \}}
\DoxyCodeLine{07233\ \};}
\DoxyCodeLine{07234\ }
\DoxyCodeLine{07235\ TEST\_F(PredicateFormatterFromMatcherTest,\ ShortCircuitOnSuccess)\ \{}
\DoxyCodeLine{07236\ \ \ AssertionResult\ result\ =\ RunPredicateFormatter(kInitialSuccess);}
\DoxyCodeLine{07237\ \ \ EXPECT\_TRUE(result);\ \ \textcolor{comment}{//\ Implicit\ cast\ to\ bool.}}
\DoxyCodeLine{07238\ \ \ std::string\ expect;}
\DoxyCodeLine{07239\ \ \ EXPECT\_EQ(expect,\ result.message());}
\DoxyCodeLine{07240\ \}}
\DoxyCodeLine{07241\ }
\DoxyCodeLine{07242\ TEST\_F(PredicateFormatterFromMatcherTest,\ NoShortCircuitOnFailure)\ \{}
\DoxyCodeLine{07243\ \ \ AssertionResult\ result\ =\ RunPredicateFormatter(kAlwaysFail);}
\DoxyCodeLine{07244\ \ \ EXPECT\_FALSE(result);\ \ \textcolor{comment}{//\ Implicit\ cast\ to\ bool.}}
\DoxyCodeLine{07245\ \ \ std::string\ expect\ =}
\DoxyCodeLine{07246\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Value\ of:\ dummy-\/name\(\backslash\)nExpected:\ [DescribeTo]\(\backslash\)n"{}}}
\DoxyCodeLine{07247\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ Actual:\ 1"{}}\ +}
\DoxyCodeLine{07248\ \ \ \ \ \ \ OfType(internal::GetTypeName<Behavior>())\ +\ \textcolor{stringliteral}{"{},\ [MatchAndExplain]"{}};}
\DoxyCodeLine{07249\ \ \ EXPECT\_EQ(expect,\ result.message());}
\DoxyCodeLine{07250\ \}}
\DoxyCodeLine{07251\ }
\DoxyCodeLine{07252\ TEST\_F(PredicateFormatterFromMatcherTest,\ DetectsFlakyShortCircuit)\ \{}
\DoxyCodeLine{07253\ \ \ AssertionResult\ result\ =\ RunPredicateFormatter(kFlaky);}
\DoxyCodeLine{07254\ \ \ EXPECT\_FALSE(result);\ \ \textcolor{comment}{//\ Implicit\ cast\ to\ bool.}}
\DoxyCodeLine{07255\ \ \ std::string\ expect\ =}
\DoxyCodeLine{07256\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Value\ of:\ dummy-\/name\(\backslash\)nExpected:\ [DescribeTo]\(\backslash\)n"{}}}
\DoxyCodeLine{07257\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ The\ matcher\ failed\ on\ the\ initial\ attempt;\ but\ passed\ when\ rerun\ to\ "{}}}
\DoxyCodeLine{07258\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}generate\ the\ explanation.\(\backslash\)n"{}}}
\DoxyCodeLine{07259\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}\ \ Actual:\ 2"{}}\ +}
\DoxyCodeLine{07260\ \ \ \ \ \ \ OfType(internal::GetTypeName<Behavior>())\ +\ \textcolor{stringliteral}{"{},\ [MatchAndExplain]"{}};}
\DoxyCodeLine{07261\ \ \ EXPECT\_EQ(expect,\ result.message());}
\DoxyCodeLine{07262\ \}}
\DoxyCodeLine{07263\ }
\DoxyCodeLine{07264\ \textcolor{comment}{//\ Tests\ for\ ElementsAre().}}
\DoxyCodeLine{07265\ }
\DoxyCodeLine{07266\ TEST(ElementsAreTest,\ CanDescribeExpectingNoElement)\ \{}
\DoxyCodeLine{07267\ \ \ Matcher<const\ vector<int>\&>\ m\ =\ ElementsAre();}
\DoxyCodeLine{07268\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ empty"{}},\ Describe(m));}
\DoxyCodeLine{07269\ \}}
\DoxyCodeLine{07270\ }
\DoxyCodeLine{07271\ TEST(ElementsAreTest,\ CanDescribeExpectingOneElement)\ \{}
\DoxyCodeLine{07272\ \ \ Matcher<vector<int>>\ m\ =\ ElementsAre(Gt(5));}
\DoxyCodeLine{07273\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ 1\ element\ that\ is\ >\ 5"{}},\ Describe(m));}
\DoxyCodeLine{07274\ \}}
\DoxyCodeLine{07275\ }
\DoxyCodeLine{07276\ TEST(ElementsAreTest,\ CanDescribeExpectingManyElements)\ \{}
\DoxyCodeLine{07277\ \ \ Matcher<list<std::string>>\ m\ =\ ElementsAre(StrEq(\textcolor{stringliteral}{"{}one"{}}),\ \textcolor{stringliteral}{"{}two"{}});}
\DoxyCodeLine{07278\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{07279\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}has\ 2\ elements\ where\(\backslash\)n"{}}}
\DoxyCodeLine{07280\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#0\ is\ equal\ to\ \(\backslash\)"{}one\(\backslash\)"{},\(\backslash\)n"{}}}
\DoxyCodeLine{07281\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#1\ is\ equal\ to\ \(\backslash\)"{}two\(\backslash\)"{}"{}},}
\DoxyCodeLine{07282\ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{07283\ \}}
\DoxyCodeLine{07284\ }
\DoxyCodeLine{07285\ TEST(ElementsAreTest,\ CanDescribeNegationOfExpectingNoElement)\ \{}
\DoxyCodeLine{07286\ \ \ Matcher<vector<int>>\ m\ =\ ElementsAre();}
\DoxyCodeLine{07287\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}isn't\ empty"{}},\ DescribeNegation(m));}
\DoxyCodeLine{07288\ \}}
\DoxyCodeLine{07289\ }
\DoxyCodeLine{07290\ TEST(ElementsAreTest,\ CanDescribeNegationOfExpectingOneElment)\ \{}
\DoxyCodeLine{07291\ \ \ Matcher<const\ list<int>\&>\ m\ =\ ElementsAre(Gt(5));}
\DoxyCodeLine{07292\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{07293\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}doesn't\ have\ 1\ element,\ or\(\backslash\)n"{}}}
\DoxyCodeLine{07294\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#0\ isn't\ >\ 5"{}},}
\DoxyCodeLine{07295\ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{07296\ \}}
\DoxyCodeLine{07297\ }
\DoxyCodeLine{07298\ TEST(ElementsAreTest,\ CanDescribeNegationOfExpectingManyElements)\ \{}
\DoxyCodeLine{07299\ \ \ Matcher<const\ list<std::string>\&>\ m\ =\ ElementsAre(\textcolor{stringliteral}{"{}one"{}},\ \textcolor{stringliteral}{"{}two"{}});}
\DoxyCodeLine{07300\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{07301\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}doesn't\ have\ 2\ elements,\ or\(\backslash\)n"{}}}
\DoxyCodeLine{07302\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#0\ isn't\ equal\ to\ \(\backslash\)"{}one\(\backslash\)"{},\ or\(\backslash\)n"{}}}
\DoxyCodeLine{07303\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}element\ \#1\ isn't\ equal\ to\ \(\backslash\)"{}two\(\backslash\)"{}"{}},}
\DoxyCodeLine{07304\ \ \ \ \ \ \ DescribeNegation(m));}
\DoxyCodeLine{07305\ \}}
\DoxyCodeLine{07306\ }
\DoxyCodeLine{07307\ TEST(ElementsAreTest,\ DoesNotExplainTrivialMatch)\ \{}
\DoxyCodeLine{07308\ \ \ Matcher<const\ list<int>\&>\ m\ =\ ElementsAre(1,\ Ne(2));}
\DoxyCodeLine{07309\ }
\DoxyCodeLine{07310\ \ \ list<int>\ test\_list;}
\DoxyCodeLine{07311\ \ \ test\_list.push\_back(1);}
\DoxyCodeLine{07312\ \ \ test\_list.push\_back(3);}
\DoxyCodeLine{07313\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ test\_list));\ \ \textcolor{comment}{//\ No\ need\ to\ explain\ anything.}}
\DoxyCodeLine{07314\ \}}
\DoxyCodeLine{07315\ }
\DoxyCodeLine{07316\ TEST(ElementsAreTest,\ ExplainsNonTrivialMatch)\ \{}
\DoxyCodeLine{07317\ \ \ Matcher<const\ vector<int>\&>\ m\ =}
\DoxyCodeLine{07318\ \ \ \ \ \ \ ElementsAre(GreaterThan(1),\ 0,\ GreaterThan(2));}
\DoxyCodeLine{07319\ }
\DoxyCodeLine{07320\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{10,\ 0,\ 100\};}
\DoxyCodeLine{07321\ \ \ vector<int>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07322\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{07323\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ element\ \#0\ matches,\ which\ is\ 9\ more\ than\ 1,\(\backslash\)n"{}}}
\DoxyCodeLine{07324\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}and\ whose\ element\ \#2\ matches,\ which\ is\ 98\ more\ than\ 2"{}},}
\DoxyCodeLine{07325\ \ \ \ \ \ \ Explain(m,\ test\_vector));}
\DoxyCodeLine{07326\ \}}
\DoxyCodeLine{07327\ }
\DoxyCodeLine{07328\ TEST(ElementsAreTest,\ CanExplainMismatchWrongSize)\ \{}
\DoxyCodeLine{07329\ \ \ Matcher<const\ list<int>\&>\ m\ =\ ElementsAre(1,\ 3);}
\DoxyCodeLine{07330\ }
\DoxyCodeLine{07331\ \ \ list<int>\ test\_list;}
\DoxyCodeLine{07332\ \ \ \textcolor{comment}{//\ No\ need\ to\ explain\ when\ the\ container\ is\ empty.}}
\DoxyCodeLine{07333\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ test\_list));}
\DoxyCodeLine{07334\ }
\DoxyCodeLine{07335\ \ \ test\_list.push\_back(1);}
\DoxyCodeLine{07336\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ has\ 1\ element"{}},\ Explain(m,\ test\_list));}
\DoxyCodeLine{07337\ \}}
\DoxyCodeLine{07338\ }
\DoxyCodeLine{07339\ TEST(ElementsAreTest,\ CanExplainMismatchRightSize)\ \{}
\DoxyCodeLine{07340\ \ \ Matcher<const\ vector<int>\&>\ m\ =\ ElementsAre(1,\ GreaterThan(5));}
\DoxyCodeLine{07341\ }
\DoxyCodeLine{07342\ \ \ vector<int>\ v;}
\DoxyCodeLine{07343\ \ \ v.push\_back(2);}
\DoxyCodeLine{07344\ \ \ v.push\_back(1);}
\DoxyCodeLine{07345\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ element\ \#0\ doesn't\ match"{}},\ Explain(m,\ v));}
\DoxyCodeLine{07346\ }
\DoxyCodeLine{07347\ \ \ v[0]\ =\ 1;}
\DoxyCodeLine{07348\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ element\ \#1\ doesn't\ match,\ which\ is\ 4\ less\ than\ 5"{}},}
\DoxyCodeLine{07349\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ v));}
\DoxyCodeLine{07350\ \}}
\DoxyCodeLine{07351\ }
\DoxyCodeLine{07352\ TEST(ElementsAreTest,\ MatchesOneElementVector)\ \{}
\DoxyCodeLine{07353\ \ \ vector<std::string>\ test\_vector;}
\DoxyCodeLine{07354\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}test\ string"{}});}
\DoxyCodeLine{07355\ }
\DoxyCodeLine{07356\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAre(StrEq(\textcolor{stringliteral}{"{}test\ string"{}})));}
\DoxyCodeLine{07357\ \}}
\DoxyCodeLine{07358\ }
\DoxyCodeLine{07359\ TEST(ElementsAreTest,\ MatchesOneElementList)\ \{}
\DoxyCodeLine{07360\ \ \ list<std::string>\ test\_list;}
\DoxyCodeLine{07361\ \ \ test\_list.push\_back(\textcolor{stringliteral}{"{}test\ string"{}});}
\DoxyCodeLine{07362\ }
\DoxyCodeLine{07363\ \ \ EXPECT\_THAT(test\_list,\ ElementsAre(\textcolor{stringliteral}{"{}test\ string"{}}));}
\DoxyCodeLine{07364\ \}}
\DoxyCodeLine{07365\ }
\DoxyCodeLine{07366\ TEST(ElementsAreTest,\ MatchesThreeElementVector)\ \{}
\DoxyCodeLine{07367\ \ \ vector<std::string>\ test\_vector;}
\DoxyCodeLine{07368\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}one"{}});}
\DoxyCodeLine{07369\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}two"{}});}
\DoxyCodeLine{07370\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}three"{}});}
\DoxyCodeLine{07371\ }
\DoxyCodeLine{07372\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAre(\textcolor{stringliteral}{"{}one"{}},\ StrEq(\textcolor{stringliteral}{"{}two"{}}),\ \_));}
\DoxyCodeLine{07373\ \}}
\DoxyCodeLine{07374\ }
\DoxyCodeLine{07375\ TEST(ElementsAreTest,\ MatchesOneElementEqMatcher)\ \{}
\DoxyCodeLine{07376\ \ \ vector<int>\ test\_vector;}
\DoxyCodeLine{07377\ \ \ test\_vector.push\_back(4);}
\DoxyCodeLine{07378\ }
\DoxyCodeLine{07379\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAre(Eq(4)));}
\DoxyCodeLine{07380\ \}}
\DoxyCodeLine{07381\ }
\DoxyCodeLine{07382\ TEST(ElementsAreTest,\ MatchesOneElementAnyMatcher)\ \{}
\DoxyCodeLine{07383\ \ \ vector<int>\ test\_vector;}
\DoxyCodeLine{07384\ \ \ test\_vector.push\_back(4);}
\DoxyCodeLine{07385\ }
\DoxyCodeLine{07386\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAre(\_));}
\DoxyCodeLine{07387\ \}}
\DoxyCodeLine{07388\ }
\DoxyCodeLine{07389\ TEST(ElementsAreTest,\ MatchesOneElementValue)\ \{}
\DoxyCodeLine{07390\ \ \ vector<int>\ test\_vector;}
\DoxyCodeLine{07391\ \ \ test\_vector.push\_back(4);}
\DoxyCodeLine{07392\ }
\DoxyCodeLine{07393\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAre(4));}
\DoxyCodeLine{07394\ \}}
\DoxyCodeLine{07395\ }
\DoxyCodeLine{07396\ TEST(ElementsAreTest,\ MatchesThreeElementsMixedMatchers)\ \{}
\DoxyCodeLine{07397\ \ \ vector<int>\ test\_vector;}
\DoxyCodeLine{07398\ \ \ test\_vector.push\_back(1);}
\DoxyCodeLine{07399\ \ \ test\_vector.push\_back(2);}
\DoxyCodeLine{07400\ \ \ test\_vector.push\_back(3);}
\DoxyCodeLine{07401\ }
\DoxyCodeLine{07402\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAre(1,\ Eq(2),\ \_));}
\DoxyCodeLine{07403\ \}}
\DoxyCodeLine{07404\ }
\DoxyCodeLine{07405\ TEST(ElementsAreTest,\ MatchesTenElementVector)\ \{}
\DoxyCodeLine{07406\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{0,\ 1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9\};}
\DoxyCodeLine{07407\ \ \ vector<int>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07408\ }
\DoxyCodeLine{07409\ \ \ EXPECT\_THAT(test\_vector,}
\DoxyCodeLine{07410\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ element\ list\ can\ contain\ values\ and/or\ matchers}}
\DoxyCodeLine{07411\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ of\ different\ types.}}
\DoxyCodeLine{07412\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(0,\ Ge(0),\ \_,\ 3,\ 4,\ Ne(2),\ Eq(6),\ 7,\ 8,\ \_));}
\DoxyCodeLine{07413\ \}}
\DoxyCodeLine{07414\ }
\DoxyCodeLine{07415\ TEST(ElementsAreTest,\ DoesNotMatchWrongSize)\ \{}
\DoxyCodeLine{07416\ \ \ vector<std::string>\ test\_vector;}
\DoxyCodeLine{07417\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}test\ string"{}});}
\DoxyCodeLine{07418\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}test\ string"{}});}
\DoxyCodeLine{07419\ }
\DoxyCodeLine{07420\ \ \ Matcher<vector<std::string>>\ m\ =\ ElementsAre(StrEq(\textcolor{stringliteral}{"{}test\ string"{}}));}
\DoxyCodeLine{07421\ \ \ EXPECT\_FALSE(m.Matches(test\_vector));}
\DoxyCodeLine{07422\ \}}
\DoxyCodeLine{07423\ }
\DoxyCodeLine{07424\ TEST(ElementsAreTest,\ DoesNotMatchWrongValue)\ \{}
\DoxyCodeLine{07425\ \ \ vector<std::string>\ test\_vector;}
\DoxyCodeLine{07426\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}other\ string"{}});}
\DoxyCodeLine{07427\ }
\DoxyCodeLine{07428\ \ \ Matcher<vector<std::string>>\ m\ =\ ElementsAre(StrEq(\textcolor{stringliteral}{"{}test\ string"{}}));}
\DoxyCodeLine{07429\ \ \ EXPECT\_FALSE(m.Matches(test\_vector));}
\DoxyCodeLine{07430\ \}}
\DoxyCodeLine{07431\ }
\DoxyCodeLine{07432\ TEST(ElementsAreTest,\ DoesNotMatchWrongOrder)\ \{}
\DoxyCodeLine{07433\ \ \ vector<std::string>\ test\_vector;}
\DoxyCodeLine{07434\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}one"{}});}
\DoxyCodeLine{07435\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}three"{}});}
\DoxyCodeLine{07436\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}two"{}});}
\DoxyCodeLine{07437\ }
\DoxyCodeLine{07438\ \ \ Matcher<vector<std::string>>\ m\ =}
\DoxyCodeLine{07439\ \ \ \ \ \ \ ElementsAre(StrEq(\textcolor{stringliteral}{"{}one"{}}),\ StrEq(\textcolor{stringliteral}{"{}two"{}}),\ StrEq(\textcolor{stringliteral}{"{}three"{}}));}
\DoxyCodeLine{07440\ \ \ EXPECT\_FALSE(m.Matches(test\_vector));}
\DoxyCodeLine{07441\ \}}
\DoxyCodeLine{07442\ }
\DoxyCodeLine{07443\ TEST(ElementsAreTest,\ WorksForNestedContainer)\ \{}
\DoxyCodeLine{07444\ \ \ \textcolor{keyword}{constexpr}\ std::array<const\ char*,\ 2>\ strings\ =\ \{\{\textcolor{stringliteral}{"{}Hi"{}},\ \textcolor{stringliteral}{"{}world"{}}\}\};}
\DoxyCodeLine{07445\ }
\DoxyCodeLine{07446\ \ \ vector<list<char>>\ nested;}
\DoxyCodeLine{07447\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ s\ :\ strings)\ \{}
\DoxyCodeLine{07448\ \ \ \ \ nested.emplace\_back(s,\ s\ +\ strlen(s));}
\DoxyCodeLine{07449\ \ \ \}}
\DoxyCodeLine{07450\ }
\DoxyCodeLine{07451\ \ \ EXPECT\_THAT(nested,\ ElementsAre(ElementsAre(\textcolor{charliteral}{'H'},\ Ne(\textcolor{charliteral}{'e'})),}
\DoxyCodeLine{07452\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(\textcolor{charliteral}{'w'},\ \textcolor{charliteral}{'o'},\ \_,\ \_,\ \textcolor{charliteral}{'d'})));}
\DoxyCodeLine{07453\ \ \ EXPECT\_THAT(nested,\ Not(ElementsAre(ElementsAre(\textcolor{charliteral}{'H'},\ \textcolor{charliteral}{'e'}),}
\DoxyCodeLine{07454\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(\textcolor{charliteral}{'w'},\ \textcolor{charliteral}{'o'},\ \_,\ \_,\ \textcolor{charliteral}{'d'}))));}
\DoxyCodeLine{07455\ \}}
\DoxyCodeLine{07456\ }
\DoxyCodeLine{07457\ TEST(ElementsAreTest,\ WorksWithByRefElementMatchers)\ \{}
\DoxyCodeLine{07458\ \ \ \textcolor{keywordtype}{int}\ a[]\ =\ \{0,\ 1,\ 2\};}
\DoxyCodeLine{07459\ \ \ vector<int>\ v(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07460\ }
\DoxyCodeLine{07461\ \ \ EXPECT\_THAT(v,\ ElementsAre(Ref(v[0]),\ Ref(v[1]),\ Ref(v[2])));}
\DoxyCodeLine{07462\ \ \ EXPECT\_THAT(v,\ Not(ElementsAre(Ref(v[0]),\ Ref(v[1]),\ Ref(a[2]))));}
\DoxyCodeLine{07463\ \}}
\DoxyCodeLine{07464\ }
\DoxyCodeLine{07465\ TEST(ElementsAreTest,\ WorksWithContainerPointerUsingPointee)\ \{}
\DoxyCodeLine{07466\ \ \ \textcolor{keywordtype}{int}\ a[]\ =\ \{0,\ 1,\ 2\};}
\DoxyCodeLine{07467\ \ \ vector<int>\ v(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07468\ }
\DoxyCodeLine{07469\ \ \ EXPECT\_THAT(\&v,\ Pointee(ElementsAre(0,\ 1,\ \_)));}
\DoxyCodeLine{07470\ \ \ EXPECT\_THAT(\&v,\ Not(Pointee(ElementsAre(0,\ \_,\ 3))));}
\DoxyCodeLine{07471\ \}}
\DoxyCodeLine{07472\ }
\DoxyCodeLine{07473\ TEST(ElementsAreTest,\ WorksWithNativeArrayPassedByReference)\ \{}
\DoxyCodeLine{07474\ \ \ \textcolor{keywordtype}{int}\ array[]\ =\ \{0,\ 1,\ 2\};}
\DoxyCodeLine{07475\ \ \ EXPECT\_THAT(array,\ ElementsAre(0,\ 1,\ \_));}
\DoxyCodeLine{07476\ \ \ EXPECT\_THAT(array,\ Not(ElementsAre(1,\ \_,\ \_)));}
\DoxyCodeLine{07477\ \ \ EXPECT\_THAT(array,\ Not(ElementsAre(0,\ \_)));}
\DoxyCodeLine{07478\ \}}
\DoxyCodeLine{07479\ }
\DoxyCodeLine{07480\ \textcolor{keyword}{class\ }NativeArrayPassedAsPointerAndSize\ \{}
\DoxyCodeLine{07481\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{07482\ \ \ NativeArrayPassedAsPointerAndSize()\ \{\}}
\DoxyCodeLine{07483\ }
\DoxyCodeLine{07484\ \ \ MOCK\_METHOD(\textcolor{keywordtype}{void},\ Helper,\ (\textcolor{keywordtype}{int}*\ array,\ \textcolor{keywordtype}{int}\ size));}
\DoxyCodeLine{07485\ }
\DoxyCodeLine{07486\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{07487\ \ \ GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(NativeArrayPassedAsPointerAndSize);}
\DoxyCodeLine{07488\ \};}
\DoxyCodeLine{07489\ }
\DoxyCodeLine{07490\ TEST(ElementsAreTest,\ WorksWithNativeArrayPassedAsPointerAndSize)\ \{}
\DoxyCodeLine{07491\ \ \ \textcolor{keywordtype}{int}\ array[]\ =\ \{0,\ 1\};}
\DoxyCodeLine{07492\ \ \ ::std::tuple<int*,\ size\_t>\ array\_as\_tuple(array,\ 2);}
\DoxyCodeLine{07493\ \ \ EXPECT\_THAT(array\_as\_tuple,\ ElementsAre(0,\ 1));}
\DoxyCodeLine{07494\ \ \ EXPECT\_THAT(array\_as\_tuple,\ Not(ElementsAre(0)));}
\DoxyCodeLine{07495\ }
\DoxyCodeLine{07496\ \ \ NativeArrayPassedAsPointerAndSize\ helper;}
\DoxyCodeLine{07497\ \ \ EXPECT\_CALL(helper,\ Helper(\_,\ \_)).With(ElementsAre(0,\ 1));}
\DoxyCodeLine{07498\ \ \ helper.Helper(array,\ 2);}
\DoxyCodeLine{07499\ \}}
\DoxyCodeLine{07500\ }
\DoxyCodeLine{07501\ TEST(ElementsAreTest,\ WorksWithTwoDimensionalNativeArray)\ \{}
\DoxyCodeLine{07502\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ a2[][3]\ =\ \{\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}lo"{}}\};}
\DoxyCodeLine{07503\ \ \ EXPECT\_THAT(a2,\ ElementsAre(ElementsAre(\textcolor{charliteral}{'h'},\ \textcolor{charliteral}{'i'},\ \textcolor{charliteral}{'\(\backslash\)0'}),}
\DoxyCodeLine{07504\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(\textcolor{charliteral}{'l'},\ \textcolor{charliteral}{'o'},\ \textcolor{charliteral}{'\(\backslash\)0'})));}
\DoxyCodeLine{07505\ \ \ EXPECT\_THAT(a2,\ ElementsAre(StrEq(\textcolor{stringliteral}{"{}hi"{}}),\ StrEq(\textcolor{stringliteral}{"{}lo"{}})));}
\DoxyCodeLine{07506\ \ \ EXPECT\_THAT(a2,\ ElementsAre(Not(ElementsAre(\textcolor{charliteral}{'h'},\ \textcolor{charliteral}{'o'},\ \textcolor{charliteral}{'\(\backslash\)0'})),}
\DoxyCodeLine{07507\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ElementsAre(\textcolor{charliteral}{'l'},\ \textcolor{charliteral}{'o'},\ \textcolor{charliteral}{'\(\backslash\)0'})));}
\DoxyCodeLine{07508\ \}}
\DoxyCodeLine{07509\ }
\DoxyCodeLine{07510\ TEST(ElementsAreTest,\ AcceptsStringLiteral)\ \{}
\DoxyCodeLine{07511\ \ \ std::string\ array[]\ =\ \{\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}one"{}},\ \textcolor{stringliteral}{"{}two"{}}\};}
\DoxyCodeLine{07512\ \ \ EXPECT\_THAT(array,\ ElementsAre(\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}one"{}},\ \textcolor{stringliteral}{"{}two"{}}));}
\DoxyCodeLine{07513\ \ \ EXPECT\_THAT(array,\ Not(ElementsAre(\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}one"{}},\ \textcolor{stringliteral}{"{}too"{}})));}
\DoxyCodeLine{07514\ \}}
\DoxyCodeLine{07515\ }
\DoxyCodeLine{07516\ \textcolor{comment}{//\ Declared\ here\ with\ the\ size\ unknown.\ \ Defined\ AFTER\ the\ following\ test.}}
\DoxyCodeLine{07517\ \textcolor{keyword}{extern}\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ kHi[];}
\DoxyCodeLine{07518\ }
\DoxyCodeLine{07519\ TEST(ElementsAreTest,\ AcceptsArrayWithUnknownSize)\ \{}
\DoxyCodeLine{07520\ \ \ \textcolor{comment}{//\ The\ size\ of\ kHi\ is\ not\ known\ in\ this\ test,\ but\ ElementsAre()\ should}}
\DoxyCodeLine{07521\ \ \ \textcolor{comment}{//\ still\ accept\ it.}}
\DoxyCodeLine{07522\ }
\DoxyCodeLine{07523\ \ \ std::string\ array1[]\ =\ \{\textcolor{stringliteral}{"{}hi"{}}\};}
\DoxyCodeLine{07524\ \ \ EXPECT\_THAT(array1,\ ElementsAre(kHi));}
\DoxyCodeLine{07525\ }
\DoxyCodeLine{07526\ \ \ std::string\ array2[]\ =\ \{\textcolor{stringliteral}{"{}ho"{}}\};}
\DoxyCodeLine{07527\ \ \ EXPECT\_THAT(array2,\ Not(ElementsAre(kHi)));}
\DoxyCodeLine{07528\ \}}
\DoxyCodeLine{07529\ }
\DoxyCodeLine{07530\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ kHi[]\ =\ \textcolor{stringliteral}{"{}hi"{}};}
\DoxyCodeLine{07531\ }
\DoxyCodeLine{07532\ TEST(ElementsAreTest,\ MakesCopyOfArguments)\ \{}
\DoxyCodeLine{07533\ \ \ \textcolor{keywordtype}{int}\ x\ =\ 1;}
\DoxyCodeLine{07534\ \ \ \textcolor{keywordtype}{int}\ y\ =\ 2;}
\DoxyCodeLine{07535\ \ \ \textcolor{comment}{//\ This\ should\ make\ a\ copy\ of\ x\ and\ y.}}
\DoxyCodeLine{07536\ \ \ ::testing::internal::ElementsAreMatcher<std::tuple<int,\ int>>}
\DoxyCodeLine{07537\ \ \ \ \ \ \ polymorphic\_matcher\ =\ ElementsAre(x,\ y);}
\DoxyCodeLine{07538\ \ \ \textcolor{comment}{//\ Changing\ x\ and\ y\ now\ shouldn't\ affect\ the\ meaning\ of\ the\ above\ matcher.}}
\DoxyCodeLine{07539\ \ \ x\ =\ y\ =\ 0;}
\DoxyCodeLine{07540\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ array1[]\ =\ \{1,\ 2\};}
\DoxyCodeLine{07541\ \ \ EXPECT\_THAT(array1,\ polymorphic\_matcher);}
\DoxyCodeLine{07542\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ array2[]\ =\ \{0,\ 0\};}
\DoxyCodeLine{07543\ \ \ EXPECT\_THAT(array2,\ Not(polymorphic\_matcher));}
\DoxyCodeLine{07544\ \}}
\DoxyCodeLine{07545\ }
\DoxyCodeLine{07546\ \textcolor{comment}{//\ Tests\ for\ ElementsAreArray().\ \ Since\ ElementsAreArray()\ shares\ most}}
\DoxyCodeLine{07547\ \textcolor{comment}{//\ of\ the\ implementation\ with\ ElementsAre(),\ we\ don't\ test\ it\ as}}
\DoxyCodeLine{07548\ \textcolor{comment}{//\ thoroughly\ here.}}
\DoxyCodeLine{07549\ }
\DoxyCodeLine{07550\ TEST(ElementsAreArrayTest,\ CanBeCreatedWithValueArray)\ \{}
\DoxyCodeLine{07551\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{07552\ }
\DoxyCodeLine{07553\ \ \ vector<int>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07554\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAreArray(a));}
\DoxyCodeLine{07555\ }
\DoxyCodeLine{07556\ \ \ test\_vector[2]\ =\ 0;}
\DoxyCodeLine{07557\ \ \ EXPECT\_THAT(test\_vector,\ Not(ElementsAreArray(a)));}
\DoxyCodeLine{07558\ \}}
\DoxyCodeLine{07559\ }
\DoxyCodeLine{07560\ TEST(ElementsAreArrayTest,\ CanBeCreatedWithArraySize)\ \{}
\DoxyCodeLine{07561\ \ \ std::array<const\ char*,\ 3>\ a\ =\ \{\{\textcolor{stringliteral}{"{}one"{}},\ \textcolor{stringliteral}{"{}two"{}},\ \textcolor{stringliteral}{"{}three"{}}\}\};}
\DoxyCodeLine{07562\ }
\DoxyCodeLine{07563\ \ \ vector<std::string>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07564\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAreArray(a.data(),\ a.size()));}
\DoxyCodeLine{07565\ }
\DoxyCodeLine{07566\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}**\ p\ =\ a.data();}
\DoxyCodeLine{07567\ \ \ test\_vector[0]\ =\ \textcolor{stringliteral}{"{}1"{}};}
\DoxyCodeLine{07568\ \ \ EXPECT\_THAT(test\_vector,\ Not(ElementsAreArray(p,\ a.size())));}
\DoxyCodeLine{07569\ \}}
\DoxyCodeLine{07570\ }
\DoxyCodeLine{07571\ TEST(ElementsAreArrayTest,\ CanBeCreatedWithoutArraySize)\ \{}
\DoxyCodeLine{07572\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ a[]\ =\ \{\textcolor{stringliteral}{"{}one"{}},\ \textcolor{stringliteral}{"{}two"{}},\ \textcolor{stringliteral}{"{}three"{}}\};}
\DoxyCodeLine{07573\ }
\DoxyCodeLine{07574\ \ \ vector<std::string>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07575\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAreArray(a));}
\DoxyCodeLine{07576\ }
\DoxyCodeLine{07577\ \ \ test\_vector[0]\ =\ \textcolor{stringliteral}{"{}1"{}};}
\DoxyCodeLine{07578\ \ \ EXPECT\_THAT(test\_vector,\ Not(ElementsAreArray(a)));}
\DoxyCodeLine{07579\ \}}
\DoxyCodeLine{07580\ }
\DoxyCodeLine{07581\ TEST(ElementsAreArrayTest,\ CanBeCreatedWithMatcherArray)\ \{}
\DoxyCodeLine{07582\ \ \ \textcolor{keyword}{const}\ Matcher<std::string>\ kMatcherArray[]\ =\ \{StrEq(\textcolor{stringliteral}{"{}one"{}}),\ StrEq(\textcolor{stringliteral}{"{}two"{}}),}
\DoxyCodeLine{07583\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ StrEq(\textcolor{stringliteral}{"{}three"{}})\};}
\DoxyCodeLine{07584\ }
\DoxyCodeLine{07585\ \ \ vector<std::string>\ test\_vector;}
\DoxyCodeLine{07586\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}one"{}});}
\DoxyCodeLine{07587\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}two"{}});}
\DoxyCodeLine{07588\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}three"{}});}
\DoxyCodeLine{07589\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAreArray(kMatcherArray));}
\DoxyCodeLine{07590\ }
\DoxyCodeLine{07591\ \ \ test\_vector.push\_back(\textcolor{stringliteral}{"{}three"{}});}
\DoxyCodeLine{07592\ \ \ EXPECT\_THAT(test\_vector,\ Not(ElementsAreArray(kMatcherArray)));}
\DoxyCodeLine{07593\ \}}
\DoxyCodeLine{07594\ }
\DoxyCodeLine{07595\ TEST(ElementsAreArrayTest,\ CanBeCreatedWithVector)\ \{}
\DoxyCodeLine{07596\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{07597\ \ \ vector<int>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07598\ \ \ \textcolor{keyword}{const}\ vector<int>\ expected(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07599\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAreArray(expected));}
\DoxyCodeLine{07600\ \ \ test\_vector.push\_back(4);}
\DoxyCodeLine{07601\ \ \ EXPECT\_THAT(test\_vector,\ Not(ElementsAreArray(expected)));}
\DoxyCodeLine{07602\ \}}
\DoxyCodeLine{07603\ }
\DoxyCodeLine{07604\ TEST(ElementsAreArrayTest,\ TakesInitializerList)\ \{}
\DoxyCodeLine{07605\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{1,\ 2,\ 3,\ 4,\ 5\};}
\DoxyCodeLine{07606\ \ \ EXPECT\_THAT(a,\ ElementsAreArray(\{1,\ 2,\ 3,\ 4,\ 5\}));}
\DoxyCodeLine{07607\ \ \ EXPECT\_THAT(a,\ Not(ElementsAreArray(\{1,\ 2,\ 3,\ 5,\ 4\})));}
\DoxyCodeLine{07608\ \ \ EXPECT\_THAT(a,\ Not(ElementsAreArray(\{1,\ 2,\ 3,\ 4,\ 6\})));}
\DoxyCodeLine{07609\ \}}
\DoxyCodeLine{07610\ }
\DoxyCodeLine{07611\ TEST(ElementsAreArrayTest,\ TakesInitializerListOfCStrings)\ \{}
\DoxyCodeLine{07612\ \ \ \textcolor{keyword}{const}\ std::string\ a[5]\ =\ \{\textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{stringliteral}{"{}c"{}},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}}\};}
\DoxyCodeLine{07613\ \ \ EXPECT\_THAT(a,\ ElementsAreArray(\{\textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{stringliteral}{"{}c"{}},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}}\}));}
\DoxyCodeLine{07614\ \ \ EXPECT\_THAT(a,\ Not(ElementsAreArray(\{\textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{stringliteral}{"{}c"{}},\ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{stringliteral}{"{}d"{}}\})));}
\DoxyCodeLine{07615\ \ \ EXPECT\_THAT(a,\ Not(ElementsAreArray(\{\textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{stringliteral}{"{}c"{}},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}ef"{}}\})));}
\DoxyCodeLine{07616\ \}}
\DoxyCodeLine{07617\ }
\DoxyCodeLine{07618\ TEST(ElementsAreArrayTest,\ TakesInitializerListOfSameTypedMatchers)\ \{}
\DoxyCodeLine{07619\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{1,\ 2,\ 3,\ 4,\ 5\};}
\DoxyCodeLine{07620\ \ \ EXPECT\_THAT(a,\ ElementsAreArray(\{Eq(1),\ Eq(2),\ Eq(3),\ Eq(4),\ Eq(5)\}));}
\DoxyCodeLine{07621\ \ \ EXPECT\_THAT(a,\ Not(ElementsAreArray(\{Eq(1),\ Eq(2),\ Eq(3),\ Eq(4),\ Eq(6)\})));}
\DoxyCodeLine{07622\ \}}
\DoxyCodeLine{07623\ }
\DoxyCodeLine{07624\ TEST(ElementsAreArrayTest,\ TakesInitializerListOfDifferentTypedMatchers)\ \{}
\DoxyCodeLine{07625\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[5]\ =\ \{1,\ 2,\ 3,\ 4,\ 5\};}
\DoxyCodeLine{07626\ \ \ \textcolor{comment}{//\ The\ compiler\ cannot\ infer\ the\ type\ of\ the\ initializer\ list\ if\ its}}
\DoxyCodeLine{07627\ \ \ \textcolor{comment}{//\ elements\ have\ different\ types.\ \ We\ must\ explicitly\ specify\ the}}
\DoxyCodeLine{07628\ \ \ \textcolor{comment}{//\ unified\ element\ type\ in\ this\ case.}}
\DoxyCodeLine{07629\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{07630\ \ \ \ \ \ \ a,\ ElementsAreArray<Matcher<int>>(\{Eq(1),\ Ne(-\/2),\ Ge(3),\ Le(4),\ Eq(5)\}));}
\DoxyCodeLine{07631\ \ \ EXPECT\_THAT(a,\ Not(ElementsAreArray<Matcher<int>>(}
\DoxyCodeLine{07632\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{Eq(1),\ Ne(-\/2),\ Ge(3),\ Le(4),\ Eq(6)\})));}
\DoxyCodeLine{07633\ \}}
\DoxyCodeLine{07634\ }
\DoxyCodeLine{07635\ TEST(ElementsAreArrayTest,\ CanBeCreatedWithMatcherVector)\ \{}
\DoxyCodeLine{07636\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{07637\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ kMatchers[]\ =\ \{Eq(1),\ Eq(2),\ Eq(3)\};}
\DoxyCodeLine{07638\ \ \ vector<int>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07639\ \ \ \textcolor{keyword}{const}\ vector<Matcher<int>>\ expected(std::begin(kMatchers),}
\DoxyCodeLine{07640\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::end(kMatchers));}
\DoxyCodeLine{07641\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAreArray(expected));}
\DoxyCodeLine{07642\ \ \ test\_vector.push\_back(4);}
\DoxyCodeLine{07643\ \ \ EXPECT\_THAT(test\_vector,\ Not(ElementsAreArray(expected)));}
\DoxyCodeLine{07644\ \}}
\DoxyCodeLine{07645\ }
\DoxyCodeLine{07646\ TEST(ElementsAreArrayTest,\ CanBeCreatedWithIteratorRange)\ \{}
\DoxyCodeLine{07647\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{07648\ \ \ \textcolor{keyword}{const}\ vector<int>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07649\ \ \ \textcolor{keyword}{const}\ vector<int>\ expected(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07650\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAreArray(expected.begin(),\ expected.end()));}
\DoxyCodeLine{07651\ \ \ \textcolor{comment}{//\ Pointers\ are\ iterators,\ too.}}
\DoxyCodeLine{07652\ \ \ EXPECT\_THAT(test\_vector,\ ElementsAreArray(std::begin(a),\ std::end(a)));}
\DoxyCodeLine{07653\ \ \ \textcolor{comment}{//\ The\ empty\ range\ of\ NULL\ pointers\ should\ also\ be\ okay.}}
\DoxyCodeLine{07654\ \ \ \textcolor{keywordtype}{int}*\ \textcolor{keyword}{const}\ null\_int\ =\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{07655\ \ \ EXPECT\_THAT(test\_vector,\ Not(ElementsAreArray(null\_int,\ null\_int)));}
\DoxyCodeLine{07656\ \ \ EXPECT\_THAT((vector<int>()),\ ElementsAreArray(null\_int,\ null\_int));}
\DoxyCodeLine{07657\ \}}
\DoxyCodeLine{07658\ }
\DoxyCodeLine{07659\ \textcolor{comment}{//\ Since\ ElementsAre()\ and\ ElementsAreArray()\ share\ much\ of\ the}}
\DoxyCodeLine{07660\ \textcolor{comment}{//\ implementation,\ we\ only\ do\ a\ sanity\ test\ for\ native\ arrays\ here.}}
\DoxyCodeLine{07661\ TEST(ElementsAreArrayTest,\ WorksWithNativeArray)\ \{}
\DoxyCodeLine{07662\ \ \ ::std::string\ a[]\ =\ \{\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}ho"{}}\};}
\DoxyCodeLine{07663\ \ \ ::std::string\ b[]\ =\ \{\textcolor{stringliteral}{"{}hi"{}},\ \textcolor{stringliteral}{"{}ho"{}}\};}
\DoxyCodeLine{07664\ }
\DoxyCodeLine{07665\ \ \ EXPECT\_THAT(a,\ ElementsAreArray(b));}
\DoxyCodeLine{07666\ \ \ EXPECT\_THAT(a,\ ElementsAreArray(b,\ 2));}
\DoxyCodeLine{07667\ \ \ EXPECT\_THAT(a,\ Not(ElementsAreArray(b,\ 1)));}
\DoxyCodeLine{07668\ \}}
\DoxyCodeLine{07669\ }
\DoxyCodeLine{07670\ TEST(ElementsAreArrayTest,\ SourceLifeSpan)\ \{}
\DoxyCodeLine{07671\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{07672\ \ \ vector<int>\ test\_vector(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07673\ \ \ vector<int>\ expect(std::begin(a),\ std::end(a));}
\DoxyCodeLine{07674\ \ \ ElementsAreArrayMatcher<int>\ matcher\_maker\ =}
\DoxyCodeLine{07675\ \ \ \ \ \ \ ElementsAreArray(expect.begin(),\ expect.end());}
\DoxyCodeLine{07676\ \ \ EXPECT\_THAT(test\_vector,\ matcher\_maker);}
\DoxyCodeLine{07677\ \ \ \textcolor{comment}{//\ Changing\ in\ place\ the\ values\ that\ initialized\ matcher\_maker\ should\ not}}
\DoxyCodeLine{07678\ \ \ \textcolor{comment}{//\ affect\ matcher\_maker\ anymore.\ It\ should\ have\ made\ its\ own\ copy\ of\ them.}}
\DoxyCodeLine{07679\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\&\ i\ :\ expect)\ \{}
\DoxyCodeLine{07680\ \ \ \ \ i\ +=\ 10;}
\DoxyCodeLine{07681\ \ \ \}}
\DoxyCodeLine{07682\ \ \ EXPECT\_THAT(test\_vector,\ matcher\_maker);}
\DoxyCodeLine{07683\ \ \ test\_vector.push\_back(3);}
\DoxyCodeLine{07684\ \ \ EXPECT\_THAT(test\_vector,\ Not(matcher\_maker));}
\DoxyCodeLine{07685\ \}}
\DoxyCodeLine{07686\ }
\DoxyCodeLine{07687\ \textcolor{comment}{//\ Tests\ for\ the\ MATCHER*()\ macro\ family.}}
\DoxyCodeLine{07688\ }
\DoxyCodeLine{07689\ \textcolor{comment}{//\ Tests\ that\ a\ simple\ MATCHER()\ definition\ works.}}
\DoxyCodeLine{07690\ }
\DoxyCodeLine{07691\ MATCHER(IsEven,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ (arg\ \%\ 2)\ ==\ 0;\ \}}
\DoxyCodeLine{07692\ }
\DoxyCodeLine{07693\ TEST(MatcherMacroTest,\ Works)\ \{}
\DoxyCodeLine{07694\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ IsEven();}
\DoxyCodeLine{07695\ \ \ EXPECT\_TRUE(m.Matches(6));}
\DoxyCodeLine{07696\ \ \ EXPECT\_FALSE(m.Matches(7));}
\DoxyCodeLine{07697\ }
\DoxyCodeLine{07698\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ even"{}},\ Describe(m));}
\DoxyCodeLine{07699\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}not\ (is\ even)"{}},\ DescribeNegation(m));}
\DoxyCodeLine{07700\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 6));}
\DoxyCodeLine{07701\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 7));}
\DoxyCodeLine{07702\ \}}
\DoxyCodeLine{07703\ }
\DoxyCodeLine{07704\ \textcolor{comment}{//\ This\ also\ tests\ that\ the\ description\ string\ can\ reference\ 'negation'.}}
\DoxyCodeLine{07705\ MATCHER(IsEven2,\ negation\ ?\ \textcolor{stringliteral}{"{}is\ odd"{}}\ :\ \textcolor{stringliteral}{"{}is\ even"{}})\ \{}
\DoxyCodeLine{07706\ \ \ \textcolor{keywordflow}{if}\ ((arg\ \%\ 2)\ ==\ 0)\ \{}
\DoxyCodeLine{07707\ \ \ \ \ \textcolor{comment}{//\ Verifies\ that\ we\ can\ stream\ to\ result\_listener,\ a\ listener}}
\DoxyCodeLine{07708\ \ \ \ \ \textcolor{comment}{//\ supplied\ by\ the\ MATCHER\ macro\ implicitly.}}
\DoxyCodeLine{07709\ \ \ \ \ *result\_listener\ <<\ \textcolor{stringliteral}{"{}OK"{}};}
\DoxyCodeLine{07710\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{07711\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{07712\ \ \ \ \ *result\_listener\ <<\ \textcolor{stringliteral}{"{}\%\ 2\ ==\ "{}}\ <<\ (arg\ \%\ 2);}
\DoxyCodeLine{07713\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{07714\ \ \ \}}
\DoxyCodeLine{07715\ \}}
\DoxyCodeLine{07716\ }
\DoxyCodeLine{07717\ \textcolor{comment}{//\ This\ also\ tests\ that\ the\ description\ string\ can\ reference\ matcher}}
\DoxyCodeLine{07718\ \textcolor{comment}{//\ parameters.}}
\DoxyCodeLine{07719\ MATCHER\_P2(EqSumOf,\ x,\ y,}
\DoxyCodeLine{07720\ \ \ \ \ \ \ \ \ \ \ \ std::string(negation\ ?\ \textcolor{stringliteral}{"{}doesn't\ equal"{}}\ :\ \textcolor{stringliteral}{"{}equals"{}})\ +\ \textcolor{stringliteral}{"{}\ the\ sum\ of\ "{}}\ +}
\DoxyCodeLine{07721\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PrintToString(x)\ +\ \textcolor{stringliteral}{"{}\ and\ "{}}\ +\ PrintToString(y))\ \{}
\DoxyCodeLine{07722\ \ \ \textcolor{keywordflow}{if}\ (arg\ ==\ (x\ +\ y))\ \{}
\DoxyCodeLine{07723\ \ \ \ \ *result\_listener\ <<\ \textcolor{stringliteral}{"{}OK"{}};}
\DoxyCodeLine{07724\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{07725\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{07726\ \ \ \ \ \textcolor{comment}{//\ Verifies\ that\ we\ can\ stream\ to\ the\ underlying\ stream\ of}}
\DoxyCodeLine{07727\ \ \ \ \ \textcolor{comment}{//\ result\_listener.}}
\DoxyCodeLine{07728\ \ \ \ \ \textcolor{keywordflow}{if}\ (result\_listener-\/>stream()\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{07729\ \ \ \ \ \ \ *result\_listener-\/>stream()\ <<\ \textcolor{stringliteral}{"{}diff\ ==\ "{}}\ <<\ (x\ +\ y\ -\/\ arg);}
\DoxyCodeLine{07730\ \ \ \ \ \}}
\DoxyCodeLine{07731\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{07732\ \ \ \}}
\DoxyCodeLine{07733\ \}}
\DoxyCodeLine{07734\ }
\DoxyCodeLine{07735\ \textcolor{comment}{//\ Tests\ that\ the\ matcher\ description\ can\ reference\ 'negation'\ and\ the}}
\DoxyCodeLine{07736\ \textcolor{comment}{//\ matcher\ parameters.}}
\DoxyCodeLine{07737\ TEST(MatcherMacroTest,\ DescriptionCanReferenceNegationAndParameters)\ \{}
\DoxyCodeLine{07738\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m1\ =\ IsEven2();}
\DoxyCodeLine{07739\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ even"{}},\ Describe(m1));}
\DoxyCodeLine{07740\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ odd"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{07741\ }
\DoxyCodeLine{07742\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m2\ =\ EqSumOf(5,\ 9);}
\DoxyCodeLine{07743\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}equals\ the\ sum\ of\ 5\ and\ 9"{}},\ Describe(m2));}
\DoxyCodeLine{07744\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}doesn't\ equal\ the\ sum\ of\ 5\ and\ 9"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{07745\ \}}
\DoxyCodeLine{07746\ }
\DoxyCodeLine{07747\ \textcolor{comment}{//\ Tests\ explaining\ match\ result\ in\ a\ MATCHER*\ macro.}}
\DoxyCodeLine{07748\ TEST(MatcherMacroTest,\ CanExplainMatchResult)\ \{}
\DoxyCodeLine{07749\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m1\ =\ IsEven2();}
\DoxyCodeLine{07750\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}OK"{}},\ Explain(m1,\ 4));}
\DoxyCodeLine{07751\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}\%\ 2\ ==\ 1"{}},\ Explain(m1,\ 5));}
\DoxyCodeLine{07752\ }
\DoxyCodeLine{07753\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m2\ =\ EqSumOf(1,\ 2);}
\DoxyCodeLine{07754\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}OK"{}},\ Explain(m2,\ 3));}
\DoxyCodeLine{07755\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}diff\ ==\ -\/1"{}},\ Explain(m2,\ 4));}
\DoxyCodeLine{07756\ \}}
\DoxyCodeLine{07757\ }
\DoxyCodeLine{07758\ \textcolor{comment}{//\ Tests\ that\ the\ body\ of\ MATCHER()\ can\ reference\ the\ type\ of\ the}}
\DoxyCodeLine{07759\ \textcolor{comment}{//\ value\ being\ matched.}}
\DoxyCodeLine{07760\ }
\DoxyCodeLine{07761\ MATCHER(IsEmptyString,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07762\ \ \ StaticAssertTypeEq<::std::string,\ arg\_type>();}
\DoxyCodeLine{07763\ \ \ \textcolor{keywordflow}{return}\ arg.empty();}
\DoxyCodeLine{07764\ \}}
\DoxyCodeLine{07765\ }
\DoxyCodeLine{07766\ MATCHER(IsEmptyStringByRef,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07767\ \ \ StaticAssertTypeEq<const\ ::std::string\&,\ arg\_type>();}
\DoxyCodeLine{07768\ \ \ \textcolor{keywordflow}{return}\ arg.empty();}
\DoxyCodeLine{07769\ \}}
\DoxyCodeLine{07770\ }
\DoxyCodeLine{07771\ TEST(MatcherMacroTest,\ CanReferenceArgType)\ \{}
\DoxyCodeLine{07772\ \ \ \textcolor{keyword}{const}\ Matcher<::std::string>\ m1\ =\ IsEmptyString();}
\DoxyCodeLine{07773\ \ \ EXPECT\_TRUE(m1.Matches(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{07774\ }
\DoxyCodeLine{07775\ \ \ \textcolor{keyword}{const}\ Matcher<const\ ::std::string\&>\ m2\ =\ IsEmptyStringByRef();}
\DoxyCodeLine{07776\ \ \ EXPECT\_TRUE(m2.Matches(\textcolor{stringliteral}{"{}"{}}));}
\DoxyCodeLine{07777\ \}}
\DoxyCodeLine{07778\ }
\DoxyCodeLine{07779\ \textcolor{comment}{//\ Tests\ that\ MATCHER()\ can\ be\ used\ in\ a\ namespace.}}
\DoxyCodeLine{07780\ }
\DoxyCodeLine{07781\ \textcolor{keyword}{namespace\ }matcher\_test\ \{}
\DoxyCodeLine{07782\ MATCHER(IsOdd,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ (arg\ \%\ 2)\ !=\ 0;\ \}}
\DoxyCodeLine{07783\ \}\ \ \textcolor{comment}{//\ namespace\ matcher\_test}}
\DoxyCodeLine{07784\ }
\DoxyCodeLine{07785\ TEST(MatcherMacroTest,\ WorksInNamespace)\ \{}
\DoxyCodeLine{07786\ \ \ Matcher<int>\ m\ =\ matcher\_test::IsOdd();}
\DoxyCodeLine{07787\ \ \ EXPECT\_FALSE(m.Matches(4));}
\DoxyCodeLine{07788\ \ \ EXPECT\_TRUE(m.Matches(5));}
\DoxyCodeLine{07789\ \}}
\DoxyCodeLine{07790\ }
\DoxyCodeLine{07791\ \textcolor{comment}{//\ Tests\ that\ Value()\ can\ be\ used\ to\ compose\ matchers.}}
\DoxyCodeLine{07792\ MATCHER(IsPositiveOdd,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07793\ \ \ \textcolor{keywordflow}{return}\ Value(arg,\ matcher\_test::IsOdd())\ \&\&\ arg\ >\ 0;}
\DoxyCodeLine{07794\ \}}
\DoxyCodeLine{07795\ }
\DoxyCodeLine{07796\ TEST(MatcherMacroTest,\ CanBeComposedUsingValue)\ \{}
\DoxyCodeLine{07797\ \ \ EXPECT\_THAT(3,\ IsPositiveOdd());}
\DoxyCodeLine{07798\ \ \ EXPECT\_THAT(4,\ Not(IsPositiveOdd()));}
\DoxyCodeLine{07799\ \ \ EXPECT\_THAT(-\/1,\ Not(IsPositiveOdd()));}
\DoxyCodeLine{07800\ \}}
\DoxyCodeLine{07801\ }
\DoxyCodeLine{07802\ \textcolor{comment}{//\ Tests\ that\ a\ simple\ MATCHER\_P()\ definition\ works.}}
\DoxyCodeLine{07803\ }
\DoxyCodeLine{07804\ MATCHER\_P(IsGreaterThan32And,\ n,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ >\ 32\ \&\&\ arg\ >\ n;\ \}}
\DoxyCodeLine{07805\ }
\DoxyCodeLine{07806\ TEST(MatcherPMacroTest,\ Works)\ \{}
\DoxyCodeLine{07807\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ IsGreaterThan32And(5);}
\DoxyCodeLine{07808\ \ \ EXPECT\_TRUE(m.Matches(36));}
\DoxyCodeLine{07809\ \ \ EXPECT\_FALSE(m.Matches(5));}
\DoxyCodeLine{07810\ }
\DoxyCodeLine{07811\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ greater\ than\ 32\ and\ 5"{}},\ Describe(m));}
\DoxyCodeLine{07812\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}not\ (is\ greater\ than\ 32\ and\ 5)"{}},\ DescribeNegation(m));}
\DoxyCodeLine{07813\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 36));}
\DoxyCodeLine{07814\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 5));}
\DoxyCodeLine{07815\ \}}
\DoxyCodeLine{07816\ }
\DoxyCodeLine{07817\ \textcolor{comment}{//\ Tests\ that\ the\ description\ is\ calculated\ correctly\ from\ the\ matcher\ name.}}
\DoxyCodeLine{07818\ MATCHER\_P(\_is\_Greater\_Than32and\_,\ n,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ >\ 32\ \&\&\ arg\ >\ n;\ \}}
\DoxyCodeLine{07819\ }
\DoxyCodeLine{07820\ TEST(MatcherPMacroTest,\ GeneratesCorrectDescription)\ \{}
\DoxyCodeLine{07821\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m\ =\ \_is\_Greater\_Than32and\_(5);}
\DoxyCodeLine{07822\ }
\DoxyCodeLine{07823\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ greater\ than\ 32\ and\ 5"{}},\ Describe(m));}
\DoxyCodeLine{07824\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}not\ (is\ greater\ than\ 32\ and\ 5)"{}},\ DescribeNegation(m));}
\DoxyCodeLine{07825\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 36));}
\DoxyCodeLine{07826\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 5));}
\DoxyCodeLine{07827\ \}}
\DoxyCodeLine{07828\ }
\DoxyCodeLine{07829\ \textcolor{comment}{//\ Tests\ that\ a\ MATCHER\_P\ matcher\ can\ be\ explicitly\ instantiated\ with}}
\DoxyCodeLine{07830\ \textcolor{comment}{//\ a\ reference\ parameter\ type.}}
\DoxyCodeLine{07831\ }
\DoxyCodeLine{07832\ \textcolor{keyword}{class\ }UncopyableFoo\ \{}
\DoxyCodeLine{07833\ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{07834\ \ \ \textcolor{keyword}{explicit}\ UncopyableFoo(\textcolor{keywordtype}{char}\ value)\ :\ value\_(value)\ \{\ (void)value\_;\ \}}
\DoxyCodeLine{07835\ }
\DoxyCodeLine{07836\ \ \ UncopyableFoo(\textcolor{keyword}{const}\ UncopyableFoo\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{07837\ \ \ \textcolor{keywordtype}{void}\ operator=(\textcolor{keyword}{const}\ UncopyableFoo\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{07838\ }
\DoxyCodeLine{07839\ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{07840\ \ \ \textcolor{keywordtype}{char}\ value\_;}
\DoxyCodeLine{07841\ \};}
\DoxyCodeLine{07842\ }
\DoxyCodeLine{07843\ MATCHER\_P(ReferencesUncopyable,\ variable,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ \&arg\ ==\ \&variable;\ \}}
\DoxyCodeLine{07844\ }
\DoxyCodeLine{07845\ TEST(MatcherPMacroTest,\ WorksWhenExplicitlyInstantiatedWithReference)\ \{}
\DoxyCodeLine{07846\ \ \ UncopyableFoo\ foo1(\textcolor{charliteral}{'1'}),\ foo2(\textcolor{charliteral}{'2'});}
\DoxyCodeLine{07847\ \ \ \textcolor{keyword}{const}\ Matcher<const\ UncopyableFoo\&>\ m\ =}
\DoxyCodeLine{07848\ \ \ \ \ \ \ ReferencesUncopyable<const\ UncopyableFoo\&>(foo1);}
\DoxyCodeLine{07849\ }
\DoxyCodeLine{07850\ \ \ EXPECT\_TRUE(m.Matches(foo1));}
\DoxyCodeLine{07851\ \ \ EXPECT\_FALSE(m.Matches(foo2));}
\DoxyCodeLine{07852\ }
\DoxyCodeLine{07853\ \ \ \textcolor{comment}{//\ We\ don't\ want\ the\ address\ of\ the\ parameter\ printed,\ as\ most}}
\DoxyCodeLine{07854\ \ \ \textcolor{comment}{//\ likely\ it\ will\ just\ annoy\ the\ user.\ \ If\ the\ address\ is}}
\DoxyCodeLine{07855\ \ \ \textcolor{comment}{//\ interesting,\ the\ user\ should\ consider\ passing\ the\ parameter\ by}}
\DoxyCodeLine{07856\ \ \ \textcolor{comment}{//\ pointer\ instead.}}
\DoxyCodeLine{07857\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}references\ uncopyable\ 1-\/byte\ object\ <31>"{}},\ Describe(m));}
\DoxyCodeLine{07858\ \}}
\DoxyCodeLine{07859\ }
\DoxyCodeLine{07860\ \textcolor{comment}{//\ Tests\ that\ the\ body\ of\ MATCHER\_Pn()\ can\ reference\ the\ parameter}}
\DoxyCodeLine{07861\ \textcolor{comment}{//\ types.}}
\DoxyCodeLine{07862\ }
\DoxyCodeLine{07863\ MATCHER\_P3(ParamTypesAreIntLongAndChar,\ foo,\ bar,\ baz,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07864\ \ \ StaticAssertTypeEq<int,\ foo\_type>();}
\DoxyCodeLine{07865\ \ \ StaticAssertTypeEq<long,\ bar\_type>();\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{07866\ \ \ StaticAssertTypeEq<char,\ baz\_type>();}
\DoxyCodeLine{07867\ \ \ \textcolor{keywordflow}{return}\ arg\ ==\ 0;}
\DoxyCodeLine{07868\ \}}
\DoxyCodeLine{07869\ }
\DoxyCodeLine{07870\ TEST(MatcherPnMacroTest,\ CanReferenceParamTypes)\ \{}
\DoxyCodeLine{07871\ \ \ EXPECT\_THAT(0,\ ParamTypesAreIntLongAndChar(10,\ 20L,\ \textcolor{charliteral}{'a'}));}
\DoxyCodeLine{07872\ \}}
\DoxyCodeLine{07873\ }
\DoxyCodeLine{07874\ \textcolor{comment}{//\ Tests\ that\ a\ MATCHER\_Pn\ matcher\ can\ be\ explicitly\ instantiated\ with}}
\DoxyCodeLine{07875\ \textcolor{comment}{//\ reference\ parameter\ types.}}
\DoxyCodeLine{07876\ }
\DoxyCodeLine{07877\ MATCHER\_P2(ReferencesAnyOf,\ variable1,\ variable2,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07878\ \ \ \textcolor{keywordflow}{return}\ \&arg\ ==\ \&variable1\ ||\ \&arg\ ==\ \&variable2;}
\DoxyCodeLine{07879\ \}}
\DoxyCodeLine{07880\ }
\DoxyCodeLine{07881\ TEST(MatcherPnMacroTest,\ WorksWhenExplicitlyInstantiatedWithReferences)\ \{}
\DoxyCodeLine{07882\ \ \ UncopyableFoo\ foo1(\textcolor{charliteral}{'1'}),\ foo2(\textcolor{charliteral}{'2'}),\ foo3(\textcolor{charliteral}{'3'});}
\DoxyCodeLine{07883\ \ \ \textcolor{keyword}{const}\ Matcher<const\ UncopyableFoo\&>\ const\_m\ =}
\DoxyCodeLine{07884\ \ \ \ \ \ \ ReferencesAnyOf<const\ UncopyableFoo\&,\ const\ UncopyableFoo\&>(foo1,\ foo2);}
\DoxyCodeLine{07885\ }
\DoxyCodeLine{07886\ \ \ EXPECT\_TRUE(const\_m.Matches(foo1));}
\DoxyCodeLine{07887\ \ \ EXPECT\_TRUE(const\_m.Matches(foo2));}
\DoxyCodeLine{07888\ \ \ EXPECT\_FALSE(const\_m.Matches(foo3));}
\DoxyCodeLine{07889\ }
\DoxyCodeLine{07890\ \ \ \textcolor{keyword}{const}\ Matcher<UncopyableFoo\&>\ m\ =}
\DoxyCodeLine{07891\ \ \ \ \ \ \ ReferencesAnyOf<UncopyableFoo\&,\ UncopyableFoo\&>(foo1,\ foo2);}
\DoxyCodeLine{07892\ }
\DoxyCodeLine{07893\ \ \ EXPECT\_TRUE(m.Matches(foo1));}
\DoxyCodeLine{07894\ \ \ EXPECT\_TRUE(m.Matches(foo2));}
\DoxyCodeLine{07895\ \ \ EXPECT\_FALSE(m.Matches(foo3));}
\DoxyCodeLine{07896\ \}}
\DoxyCodeLine{07897\ }
\DoxyCodeLine{07898\ TEST(MatcherPnMacroTest,}
\DoxyCodeLine{07899\ \ \ \ \ \ GeneratesCorretDescriptionWhenExplicitlyInstantiatedWithReferences)\ \{}
\DoxyCodeLine{07900\ \ \ UncopyableFoo\ foo1(\textcolor{charliteral}{'1'}),\ foo2(\textcolor{charliteral}{'2'});}
\DoxyCodeLine{07901\ \ \ \textcolor{keyword}{const}\ Matcher<const\ UncopyableFoo\&>\ m\ =}
\DoxyCodeLine{07902\ \ \ \ \ \ \ ReferencesAnyOf<const\ UncopyableFoo\&,\ const\ UncopyableFoo\&>(foo1,\ foo2);}
\DoxyCodeLine{07903\ }
\DoxyCodeLine{07904\ \ \ \textcolor{comment}{//\ We\ don't\ want\ the\ addresses\ of\ the\ parameters\ printed,\ as\ most}}
\DoxyCodeLine{07905\ \ \ \textcolor{comment}{//\ likely\ they\ will\ just\ annoy\ the\ user.\ \ If\ the\ addresses\ are}}
\DoxyCodeLine{07906\ \ \ \textcolor{comment}{//\ interesting,\ the\ user\ should\ consider\ passing\ the\ parameters\ by}}
\DoxyCodeLine{07907\ \ \ \textcolor{comment}{//\ pointers\ instead.}}
\DoxyCodeLine{07908\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}references\ any\ of\ (1-\/byte\ object\ <31>,\ 1-\/byte\ object\ <32>)"{}},}
\DoxyCodeLine{07909\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{07910\ \}}
\DoxyCodeLine{07911\ }
\DoxyCodeLine{07912\ \textcolor{comment}{//\ Tests\ that\ a\ simple\ MATCHER\_P2()\ definition\ works.}}
\DoxyCodeLine{07913\ }
\DoxyCodeLine{07914\ MATCHER\_P2(IsNotInClosedRange,\ low,\ hi,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ <\ low\ ||\ arg\ >\ hi;\ \}}
\DoxyCodeLine{07915\ }
\DoxyCodeLine{07916\ TEST(MatcherPnMacroTest,\ Works)\ \{}
\DoxyCodeLine{07917\ \ \ \textcolor{keyword}{const}\ Matcher<const\ long\&>\ m\ =\ IsNotInClosedRange(10,\ 20);\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{07918\ \ \ EXPECT\_TRUE(m.Matches(36L));}
\DoxyCodeLine{07919\ \ \ EXPECT\_FALSE(m.Matches(15L));}
\DoxyCodeLine{07920\ }
\DoxyCodeLine{07921\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}is\ not\ in\ closed\ range\ (10,\ 20)"{}},\ Describe(m));}
\DoxyCodeLine{07922\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}not\ (is\ not\ in\ closed\ range\ (10,\ 20))"{}},\ DescribeNegation(m));}
\DoxyCodeLine{07923\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 36L));}
\DoxyCodeLine{07924\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ 15L));}
\DoxyCodeLine{07925\ \}}
\DoxyCodeLine{07926\ }
\DoxyCodeLine{07927\ \textcolor{comment}{//\ Tests\ that\ MATCHER*()\ definitions\ can\ be\ overloaded\ on\ the\ number}}
\DoxyCodeLine{07928\ \textcolor{comment}{//\ of\ parameters;\ also\ tests\ MATCHER\_Pn()\ where\ n\ >=\ 3.}}
\DoxyCodeLine{07929\ }
\DoxyCodeLine{07930\ MATCHER(EqualsSumOf,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ ==\ 0;\ \}}
\DoxyCodeLine{07931\ MATCHER\_P(EqualsSumOf,\ a,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ ==\ a;\ \}}
\DoxyCodeLine{07932\ MATCHER\_P2(EqualsSumOf,\ a,\ b,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b;\ \}}
\DoxyCodeLine{07933\ MATCHER\_P3(EqualsSumOf,\ a,\ b,\ c,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b\ +\ c;\ \}}
\DoxyCodeLine{07934\ MATCHER\_P4(EqualsSumOf,\ a,\ b,\ c,\ d,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b\ +\ c\ +\ d;\ \}}
\DoxyCodeLine{07935\ MATCHER\_P5(EqualsSumOf,\ a,\ b,\ c,\ d,\ e,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b\ +\ c\ +\ d\ +\ e;\ \}}
\DoxyCodeLine{07936\ MATCHER\_P6(EqualsSumOf,\ a,\ b,\ c,\ d,\ e,\ f,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07937\ \ \ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b\ +\ c\ +\ d\ +\ e\ +\ f;}
\DoxyCodeLine{07938\ \}}
\DoxyCodeLine{07939\ MATCHER\_P7(EqualsSumOf,\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07940\ \ \ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b\ +\ c\ +\ d\ +\ e\ +\ f\ +\ g;}
\DoxyCodeLine{07941\ \}}
\DoxyCodeLine{07942\ MATCHER\_P8(EqualsSumOf,\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07943\ \ \ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b\ +\ c\ +\ d\ +\ e\ +\ f\ +\ g\ +\ h;}
\DoxyCodeLine{07944\ \}}
\DoxyCodeLine{07945\ MATCHER\_P9(EqualsSumOf,\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07946\ \ \ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b\ +\ c\ +\ d\ +\ e\ +\ f\ +\ g\ +\ h\ +\ i;}
\DoxyCodeLine{07947\ \}}
\DoxyCodeLine{07948\ MATCHER\_P10(EqualsSumOf,\ a,\ b,\ c,\ d,\ e,\ f,\ g,\ h,\ i,\ j,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{07949\ \ \ \textcolor{keywordflow}{return}\ arg\ ==\ a\ +\ b\ +\ c\ +\ d\ +\ e\ +\ f\ +\ g\ +\ h\ +\ i\ +\ j;}
\DoxyCodeLine{07950\ \}}
\DoxyCodeLine{07951\ }
\DoxyCodeLine{07952\ TEST(MatcherPnMacroTest,\ CanBeOverloadedOnNumberOfParameters)\ \{}
\DoxyCodeLine{07953\ \ \ EXPECT\_THAT(0,\ EqualsSumOf());}
\DoxyCodeLine{07954\ \ \ EXPECT\_THAT(1,\ EqualsSumOf(1));}
\DoxyCodeLine{07955\ \ \ EXPECT\_THAT(12,\ EqualsSumOf(10,\ 2));}
\DoxyCodeLine{07956\ \ \ EXPECT\_THAT(123,\ EqualsSumOf(100,\ 20,\ 3));}
\DoxyCodeLine{07957\ \ \ EXPECT\_THAT(1234,\ EqualsSumOf(1000,\ 200,\ 30,\ 4));}
\DoxyCodeLine{07958\ \ \ EXPECT\_THAT(12345,\ EqualsSumOf(10000,\ 2000,\ 300,\ 40,\ 5));}
\DoxyCodeLine{07959\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdef"{}},}
\DoxyCodeLine{07960\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{charliteral}{'f'}));}
\DoxyCodeLine{07961\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdefg"{}},}
\DoxyCodeLine{07962\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'}));}
\DoxyCodeLine{07963\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdefgh"{}},\ EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}},}
\DoxyCodeLine{07964\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'},\ \textcolor{stringliteral}{"{}h"{}}));}
\DoxyCodeLine{07965\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdefghi"{}},\ EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}},}
\DoxyCodeLine{07966\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'},\ \textcolor{stringliteral}{"{}h"{}},\ \textcolor{charliteral}{'i'}));}
\DoxyCodeLine{07967\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdefghij"{}},}
\DoxyCodeLine{07968\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'},\ \textcolor{stringliteral}{"{}h"{}},}
\DoxyCodeLine{07969\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{charliteral}{'i'},\ ::std::string(\textcolor{stringliteral}{"{}j"{}})));}
\DoxyCodeLine{07970\ }
\DoxyCodeLine{07971\ \ \ EXPECT\_THAT(1,\ Not(EqualsSumOf()));}
\DoxyCodeLine{07972\ \ \ EXPECT\_THAT(-\/1,\ Not(EqualsSumOf(1)));}
\DoxyCodeLine{07973\ \ \ EXPECT\_THAT(-\/12,\ Not(EqualsSumOf(10,\ 2)));}
\DoxyCodeLine{07974\ \ \ EXPECT\_THAT(-\/123,\ Not(EqualsSumOf(100,\ 20,\ 3)));}
\DoxyCodeLine{07975\ \ \ EXPECT\_THAT(-\/1234,\ Not(EqualsSumOf(1000,\ 200,\ 30,\ 4)));}
\DoxyCodeLine{07976\ \ \ EXPECT\_THAT(-\/12345,\ Not(EqualsSumOf(10000,\ 2000,\ 300,\ 40,\ 5)));}
\DoxyCodeLine{07977\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdef\ "{}},}
\DoxyCodeLine{07978\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Not(EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{charliteral}{'f'})));}
\DoxyCodeLine{07979\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdefg\ "{}},\ Not(EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},}
\DoxyCodeLine{07980\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'})));}
\DoxyCodeLine{07981\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdefgh\ "{}},\ Not(EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},}
\DoxyCodeLine{07982\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'},\ \textcolor{stringliteral}{"{}h"{}})));}
\DoxyCodeLine{07983\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdefghi\ "{}},\ Not(EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},}
\DoxyCodeLine{07984\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'},\ \textcolor{stringliteral}{"{}h"{}},\ \textcolor{charliteral}{'i'})));}
\DoxyCodeLine{07985\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcdefghij\ "{}},}
\DoxyCodeLine{07986\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Not(EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{charliteral}{'b'},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}},\ \textcolor{stringliteral}{"{}e"{}},\ \textcolor{charliteral}{'f'},\ \textcolor{charliteral}{'g'},}
\DoxyCodeLine{07987\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}h"{}},\ \textcolor{charliteral}{'i'},\ ::std::string(\textcolor{stringliteral}{"{}j"{}}))));}
\DoxyCodeLine{07988\ \}}
\DoxyCodeLine{07989\ }
\DoxyCodeLine{07990\ \textcolor{comment}{//\ Tests\ that\ a\ MATCHER\_Pn()\ definition\ can\ be\ instantiated\ with\ any}}
\DoxyCodeLine{07991\ \textcolor{comment}{//\ compatible\ parameter\ types.}}
\DoxyCodeLine{07992\ TEST(MatcherPnMacroTest,\ WorksForDifferentParameterTypes)\ \{}
\DoxyCodeLine{07993\ \ \ EXPECT\_THAT(123,\ EqualsSumOf(100L,\ 20,\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(3)));}
\DoxyCodeLine{07994\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcd"{}},\ EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}}));}
\DoxyCodeLine{07995\ }
\DoxyCodeLine{07996\ \ \ EXPECT\_THAT(124,\ Not(EqualsSumOf(100L,\ 20,\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(3))));}
\DoxyCodeLine{07997\ \ \ EXPECT\_THAT(\textcolor{stringliteral}{"{}abcde"{}},\ Not(EqualsSumOf(::std::string(\textcolor{stringliteral}{"{}a"{}}),\ \textcolor{stringliteral}{"{}b"{}},\ \textcolor{charliteral}{'c'},\ \textcolor{stringliteral}{"{}d"{}})));}
\DoxyCodeLine{07998\ \}}
\DoxyCodeLine{07999\ }
\DoxyCodeLine{08000\ \textcolor{comment}{//\ Tests\ that\ the\ matcher\ body\ can\ promote\ the\ parameter\ types.}}
\DoxyCodeLine{08001\ }
\DoxyCodeLine{08002\ MATCHER\_P2(EqConcat,\ prefix,\ suffix,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{08003\ \ \ \textcolor{comment}{//\ The\ following\ lines\ promote\ the\ two\ parameters\ to\ desired\ types.}}
\DoxyCodeLine{08004\ \ \ std::string\ prefix\_str(prefix);}
\DoxyCodeLine{08005\ \ \ \textcolor{keywordtype}{char}\ suffix\_char\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(suffix);}
\DoxyCodeLine{08006\ \ \ \textcolor{keywordflow}{return}\ arg\ ==\ prefix\_str\ +\ suffix\_char;}
\DoxyCodeLine{08007\ \}}
\DoxyCodeLine{08008\ }
\DoxyCodeLine{08009\ TEST(MatcherPnMacroTest,\ SimpleTypePromotion)\ \{}
\DoxyCodeLine{08010\ \ \ Matcher<std::string>\ no\_promo\ =\ EqConcat(std::string(\textcolor{stringliteral}{"{}foo"{}}),\ \textcolor{charliteral}{'t'});}
\DoxyCodeLine{08011\ \ \ Matcher<const\ std::string\&>\ promo\ =\ EqConcat(\textcolor{stringliteral}{"{}foo"{}},\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{charliteral}{'t'}));}
\DoxyCodeLine{08012\ \ \ EXPECT\_FALSE(no\_promo.Matches(\textcolor{stringliteral}{"{}fool"{}}));}
\DoxyCodeLine{08013\ \ \ EXPECT\_FALSE(promo.Matches(\textcolor{stringliteral}{"{}fool"{}}));}
\DoxyCodeLine{08014\ \ \ EXPECT\_TRUE(no\_promo.Matches(\textcolor{stringliteral}{"{}foot"{}}));}
\DoxyCodeLine{08015\ \ \ EXPECT\_TRUE(promo.Matches(\textcolor{stringliteral}{"{}foot"{}}));}
\DoxyCodeLine{08016\ \}}
\DoxyCodeLine{08017\ }
\DoxyCodeLine{08018\ \textcolor{comment}{//\ Verifies\ the\ type\ of\ a\ MATCHER*.}}
\DoxyCodeLine{08019\ }
\DoxyCodeLine{08020\ TEST(MatcherPnMacroTest,\ TypesAreCorrect)\ \{}
\DoxyCodeLine{08021\ \ \ \textcolor{comment}{//\ EqualsSumOf()\ must\ be\ assignable\ to\ a\ EqualsSumOfMatcher\ variable.}}
\DoxyCodeLine{08022\ \ \ EqualsSumOfMatcher\ a0\ =\ EqualsSumOf();}
\DoxyCodeLine{08023\ }
\DoxyCodeLine{08024\ \ \ \textcolor{comment}{//\ EqualsSumOf(1)\ must\ be\ assignable\ to\ a\ EqualsSumOfMatcherP\ variable.}}
\DoxyCodeLine{08025\ \ \ EqualsSumOfMatcherP<int>\ a1\ =\ EqualsSumOf(1);}
\DoxyCodeLine{08026\ }
\DoxyCodeLine{08027\ \ \ \textcolor{comment}{//\ EqualsSumOf(p1,\ ...,\ pk)\ must\ be\ assignable\ to\ a\ EqualsSumOfMatcherPk}}
\DoxyCodeLine{08028\ \ \ \textcolor{comment}{//\ variable,\ and\ so\ on.}}
\DoxyCodeLine{08029\ \ \ EqualsSumOfMatcherP2<int,\ char>\ a2\ =\ EqualsSumOf(1,\ \textcolor{charliteral}{'2'});}
\DoxyCodeLine{08030\ \ \ EqualsSumOfMatcherP3<int,\ int,\ char>\ a3\ =\ EqualsSumOf(1,\ 2,\ \textcolor{charliteral}{'3'});}
\DoxyCodeLine{08031\ \ \ EqualsSumOfMatcherP4<int,\ int,\ int,\ char>\ a4\ =\ EqualsSumOf(1,\ 2,\ 3,\ \textcolor{charliteral}{'4'});}
\DoxyCodeLine{08032\ \ \ EqualsSumOfMatcherP5<int,\ int,\ int,\ int,\ char>\ a5\ =}
\DoxyCodeLine{08033\ \ \ \ \ \ \ EqualsSumOf(1,\ 2,\ 3,\ 4,\ \textcolor{charliteral}{'5'});}
\DoxyCodeLine{08034\ \ \ EqualsSumOfMatcherP6<int,\ int,\ int,\ int,\ int,\ char>\ a6\ =}
\DoxyCodeLine{08035\ \ \ \ \ \ \ EqualsSumOf(1,\ 2,\ 3,\ 4,\ 5,\ \textcolor{charliteral}{'6'});}
\DoxyCodeLine{08036\ \ \ EqualsSumOfMatcherP7<int,\ int,\ int,\ int,\ int,\ int,\ char>\ a7\ =}
\DoxyCodeLine{08037\ \ \ \ \ \ \ EqualsSumOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ \textcolor{charliteral}{'7'});}
\DoxyCodeLine{08038\ \ \ EqualsSumOfMatcherP8<int,\ int,\ int,\ int,\ int,\ int,\ int,\ char>\ a8\ =}
\DoxyCodeLine{08039\ \ \ \ \ \ \ EqualsSumOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ \textcolor{charliteral}{'8'});}
\DoxyCodeLine{08040\ \ \ EqualsSumOfMatcherP9<int,\ int,\ int,\ int,\ int,\ int,\ int,\ int,\ char>\ a9\ =}
\DoxyCodeLine{08041\ \ \ \ \ \ \ EqualsSumOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ \textcolor{charliteral}{'9'});}
\DoxyCodeLine{08042\ \ \ EqualsSumOfMatcherP10<int,\ int,\ int,\ int,\ int,\ int,\ int,\ int,\ int,\ char>\ a10\ =}
\DoxyCodeLine{08043\ \ \ \ \ \ \ EqualsSumOf(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ \textcolor{charliteral}{'0'});}
\DoxyCodeLine{08044\ }
\DoxyCodeLine{08045\ \ \ \textcolor{comment}{//\ Avoid\ "{}unused\ variable"{}\ warnings.}}
\DoxyCodeLine{08046\ \ \ (void)a0;}
\DoxyCodeLine{08047\ \ \ (void)a1;}
\DoxyCodeLine{08048\ \ \ (void)a2;}
\DoxyCodeLine{08049\ \ \ (void)a3;}
\DoxyCodeLine{08050\ \ \ (void)a4;}
\DoxyCodeLine{08051\ \ \ (void)a5;}
\DoxyCodeLine{08052\ \ \ (void)a6;}
\DoxyCodeLine{08053\ \ \ (void)a7;}
\DoxyCodeLine{08054\ \ \ (void)a8;}
\DoxyCodeLine{08055\ \ \ (void)a9;}
\DoxyCodeLine{08056\ \ \ (void)a10;}
\DoxyCodeLine{08057\ \}}
\DoxyCodeLine{08058\ }
\DoxyCodeLine{08059\ \textcolor{comment}{//\ Tests\ that\ matcher-\/typed\ parameters\ can\ be\ used\ in\ Value()\ inside\ a}}
\DoxyCodeLine{08060\ \textcolor{comment}{//\ MATCHER\_Pn\ definition.}}
\DoxyCodeLine{08061\ }
\DoxyCodeLine{08062\ \textcolor{comment}{//\ Succeeds\ if\ arg\ matches\ exactly\ 2\ of\ the\ 3\ matchers.}}
\DoxyCodeLine{08063\ MATCHER\_P3(TwoOf,\ m1,\ m2,\ m3,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{08064\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ count\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Value(arg,\ m1))\ +}
\DoxyCodeLine{08065\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Value(arg,\ m2))\ +}
\DoxyCodeLine{08066\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Value(arg,\ m3));}
\DoxyCodeLine{08067\ \ \ \textcolor{keywordflow}{return}\ count\ ==\ 2;}
\DoxyCodeLine{08068\ \}}
\DoxyCodeLine{08069\ }
\DoxyCodeLine{08070\ TEST(MatcherPnMacroTest,\ CanUseMatcherTypedParameterInValue)\ \{}
\DoxyCodeLine{08071\ \ \ EXPECT\_THAT(42,\ TwoOf(Gt(0),\ Lt(50),\ Eq(10)));}
\DoxyCodeLine{08072\ \ \ EXPECT\_THAT(0,\ Not(TwoOf(Gt(-\/1),\ Lt(1),\ Eq(0))));}
\DoxyCodeLine{08073\ \}}
\DoxyCodeLine{08074\ }
\DoxyCodeLine{08075\ \textcolor{comment}{//\ Tests\ Contains().}}
\DoxyCodeLine{08076\ }
\DoxyCodeLine{08077\ TEST(ContainsTest,\ ListMatchesWhenElementIsInContainer)\ \{}
\DoxyCodeLine{08078\ \ \ list<int>\ some\_list;}
\DoxyCodeLine{08079\ \ \ some\_list.push\_back(3);}
\DoxyCodeLine{08080\ \ \ some\_list.push\_back(1);}
\DoxyCodeLine{08081\ \ \ some\_list.push\_back(2);}
\DoxyCodeLine{08082\ \ \ some\_list.push\_back(3);}
\DoxyCodeLine{08083\ \ \ EXPECT\_THAT(some\_list,\ Contains(1));}
\DoxyCodeLine{08084\ \ \ EXPECT\_THAT(some\_list,\ Contains(Gt(2.5)));}
\DoxyCodeLine{08085\ \ \ EXPECT\_THAT(some\_list,\ Contains(Eq(2.0f)));}
\DoxyCodeLine{08086\ }
\DoxyCodeLine{08087\ \ \ list<std::string>\ another\_list;}
\DoxyCodeLine{08088\ \ \ another\_list.push\_back(\textcolor{stringliteral}{"{}fee"{}});}
\DoxyCodeLine{08089\ \ \ another\_list.push\_back(\textcolor{stringliteral}{"{}fie"{}});}
\DoxyCodeLine{08090\ \ \ another\_list.push\_back(\textcolor{stringliteral}{"{}foe"{}});}
\DoxyCodeLine{08091\ \ \ another\_list.push\_back(\textcolor{stringliteral}{"{}fum"{}});}
\DoxyCodeLine{08092\ \ \ EXPECT\_THAT(another\_list,\ Contains(std::string(\textcolor{stringliteral}{"{}fee"{}})));}
\DoxyCodeLine{08093\ \}}
\DoxyCodeLine{08094\ }
\DoxyCodeLine{08095\ TEST(ContainsTest,\ ListDoesNotMatchWhenElementIsNotInContainer)\ \{}
\DoxyCodeLine{08096\ \ \ list<int>\ some\_list;}
\DoxyCodeLine{08097\ \ \ some\_list.push\_back(3);}
\DoxyCodeLine{08098\ \ \ some\_list.push\_back(1);}
\DoxyCodeLine{08099\ \ \ EXPECT\_THAT(some\_list,\ Not(Contains(4)));}
\DoxyCodeLine{08100\ \}}
\DoxyCodeLine{08101\ }
\DoxyCodeLine{08102\ TEST(ContainsTest,\ SetMatchesWhenElementIsInContainer)\ \{}
\DoxyCodeLine{08103\ \ \ set<int>\ some\_set;}
\DoxyCodeLine{08104\ \ \ some\_set.insert(3);}
\DoxyCodeLine{08105\ \ \ some\_set.insert(1);}
\DoxyCodeLine{08106\ \ \ some\_set.insert(2);}
\DoxyCodeLine{08107\ \ \ EXPECT\_THAT(some\_set,\ Contains(Eq(1.0)));}
\DoxyCodeLine{08108\ \ \ EXPECT\_THAT(some\_set,\ Contains(Eq(3.0f)));}
\DoxyCodeLine{08109\ \ \ EXPECT\_THAT(some\_set,\ Contains(2));}
\DoxyCodeLine{08110\ }
\DoxyCodeLine{08111\ \ \ set<std::string>\ another\_set;}
\DoxyCodeLine{08112\ \ \ another\_set.insert(\textcolor{stringliteral}{"{}fee"{}});}
\DoxyCodeLine{08113\ \ \ another\_set.insert(\textcolor{stringliteral}{"{}fie"{}});}
\DoxyCodeLine{08114\ \ \ another\_set.insert(\textcolor{stringliteral}{"{}foe"{}});}
\DoxyCodeLine{08115\ \ \ another\_set.insert(\textcolor{stringliteral}{"{}fum"{}});}
\DoxyCodeLine{08116\ \ \ EXPECT\_THAT(another\_set,\ Contains(Eq(std::string(\textcolor{stringliteral}{"{}fum"{}}))));}
\DoxyCodeLine{08117\ \}}
\DoxyCodeLine{08118\ }
\DoxyCodeLine{08119\ TEST(ContainsTest,\ SetDoesNotMatchWhenElementIsNotInContainer)\ \{}
\DoxyCodeLine{08120\ \ \ set<int>\ some\_set;}
\DoxyCodeLine{08121\ \ \ some\_set.insert(3);}
\DoxyCodeLine{08122\ \ \ some\_set.insert(1);}
\DoxyCodeLine{08123\ \ \ EXPECT\_THAT(some\_set,\ Not(Contains(4)));}
\DoxyCodeLine{08124\ }
\DoxyCodeLine{08125\ \ \ set<std::string>\ c\_string\_set;}
\DoxyCodeLine{08126\ \ \ c\_string\_set.insert(\textcolor{stringliteral}{"{}hello"{}});}
\DoxyCodeLine{08127\ \ \ EXPECT\_THAT(c\_string\_set,\ Not(Contains(std::string(\textcolor{stringliteral}{"{}goodbye"{}}))));}
\DoxyCodeLine{08128\ \}}
\DoxyCodeLine{08129\ }
\DoxyCodeLine{08130\ TEST(ContainsTest,\ ExplainsMatchResultCorrectly)\ \{}
\DoxyCodeLine{08131\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[2]\ =\ \{1,\ 2\};}
\DoxyCodeLine{08132\ \ \ Matcher<\textcolor{keyword}{const}\ int(\&)[2]>\ m\ =\ Contains(2);}
\DoxyCodeLine{08133\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ element\ \#1\ matches"{}},\ Explain(m,\ a));}
\DoxyCodeLine{08134\ }
\DoxyCodeLine{08135\ \ \ m\ =\ Contains(3);}
\DoxyCodeLine{08136\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ a));}
\DoxyCodeLine{08137\ }
\DoxyCodeLine{08138\ \ \ m\ =\ Contains(GreaterThan(0));}
\DoxyCodeLine{08139\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ element\ \#0\ matches,\ which\ is\ 1\ more\ than\ 0"{}},\ Explain(m,\ a));}
\DoxyCodeLine{08140\ }
\DoxyCodeLine{08141\ \ \ m\ =\ Contains(GreaterThan(10));}
\DoxyCodeLine{08142\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m,\ a));}
\DoxyCodeLine{08143\ \}}
\DoxyCodeLine{08144\ }
\DoxyCodeLine{08145\ TEST(ContainsTest,\ DescribesItselfCorrectly)\ \{}
\DoxyCodeLine{08146\ \ \ Matcher<vector<int>>\ m\ =\ Contains(1);}
\DoxyCodeLine{08147\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}contains\ at\ least\ one\ element\ that\ is\ equal\ to\ 1"{}},\ Describe(m));}
\DoxyCodeLine{08148\ }
\DoxyCodeLine{08149\ \ \ Matcher<vector<int>>\ m2\ =\ Not(m);}
\DoxyCodeLine{08150\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}doesn't\ contain\ any\ element\ that\ is\ equal\ to\ 1"{}},\ Describe(m2));}
\DoxyCodeLine{08151\ \}}
\DoxyCodeLine{08152\ }
\DoxyCodeLine{08153\ TEST(ContainsTest,\ MapMatchesWhenElementIsInContainer)\ \{}
\DoxyCodeLine{08154\ \ \ map<std::string,\ int>\ my\_map;}
\DoxyCodeLine{08155\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ bar\ =\ \textcolor{stringliteral}{"{}a\ string"{}};}
\DoxyCodeLine{08156\ \ \ my\_map[bar]\ =\ 2;}
\DoxyCodeLine{08157\ \ \ EXPECT\_THAT(my\_map,\ Contains(pair<const\ char*\ const,\ int>(bar,\ 2)));}
\DoxyCodeLine{08158\ }
\DoxyCodeLine{08159\ \ \ map<std::string,\ int>\ another\_map;}
\DoxyCodeLine{08160\ \ \ another\_map[\textcolor{stringliteral}{"{}fee"{}}]\ =\ 1;}
\DoxyCodeLine{08161\ \ \ another\_map[\textcolor{stringliteral}{"{}fie"{}}]\ =\ 2;}
\DoxyCodeLine{08162\ \ \ another\_map[\textcolor{stringliteral}{"{}foe"{}}]\ =\ 3;}
\DoxyCodeLine{08163\ \ \ another\_map[\textcolor{stringliteral}{"{}fum"{}}]\ =\ 4;}
\DoxyCodeLine{08164\ \ \ EXPECT\_THAT(another\_map,}
\DoxyCodeLine{08165\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Contains(pair<const\ std::string,\ int>(std::string(\textcolor{stringliteral}{"{}fee"{}}),\ 1)));}
\DoxyCodeLine{08166\ \ \ EXPECT\_THAT(another\_map,\ Contains(pair<const\ std::string,\ int>(\textcolor{stringliteral}{"{}fie"{}},\ 2)));}
\DoxyCodeLine{08167\ \}}
\DoxyCodeLine{08168\ }
\DoxyCodeLine{08169\ TEST(ContainsTest,\ MapDoesNotMatchWhenElementIsNotInContainer)\ \{}
\DoxyCodeLine{08170\ \ \ map<int,\ int>\ some\_map;}
\DoxyCodeLine{08171\ \ \ some\_map[1]\ =\ 11;}
\DoxyCodeLine{08172\ \ \ some\_map[2]\ =\ 22;}
\DoxyCodeLine{08173\ \ \ EXPECT\_THAT(some\_map,\ Not(Contains(pair<const\ int,\ int>(2,\ 23))));}
\DoxyCodeLine{08174\ \}}
\DoxyCodeLine{08175\ }
\DoxyCodeLine{08176\ TEST(ContainsTest,\ ArrayMatchesWhenElementIsInContainer)\ \{}
\DoxyCodeLine{08177\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ string\_array[]\ =\ \{\textcolor{stringliteral}{"{}fee"{}},\ \textcolor{stringliteral}{"{}fie"{}},\ \textcolor{stringliteral}{"{}foe"{}},\ \textcolor{stringliteral}{"{}fum"{}}\};}
\DoxyCodeLine{08178\ \ \ EXPECT\_THAT(string\_array,\ Contains(Eq(std::string(\textcolor{stringliteral}{"{}fum"{}}))));}
\DoxyCodeLine{08179\ \}}
\DoxyCodeLine{08180\ }
\DoxyCodeLine{08181\ TEST(ContainsTest,\ ArrayDoesNotMatchWhenElementIsNotInContainer)\ \{}
\DoxyCodeLine{08182\ \ \ \textcolor{keywordtype}{int}\ int\_array[]\ =\ \{1,\ 2,\ 3,\ 4\};}
\DoxyCodeLine{08183\ \ \ EXPECT\_THAT(int\_array,\ Not(Contains(5)));}
\DoxyCodeLine{08184\ \}}
\DoxyCodeLine{08185\ }
\DoxyCodeLine{08186\ TEST(ContainsTest,\ AcceptsMatcher)\ \{}
\DoxyCodeLine{08187\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{08188\ \ \ EXPECT\_THAT(a,\ Contains(Gt(2)));}
\DoxyCodeLine{08189\ \ \ EXPECT\_THAT(a,\ Not(Contains(Gt(4))));}
\DoxyCodeLine{08190\ \}}
\DoxyCodeLine{08191\ }
\DoxyCodeLine{08192\ TEST(ContainsTest,\ WorksForNativeArrayAsTuple)\ \{}
\DoxyCodeLine{08193\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[]\ =\ \{1,\ 2\};}
\DoxyCodeLine{08194\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}*\ \textcolor{keyword}{const}\ pointer\ =\ a;}
\DoxyCodeLine{08195\ \ \ EXPECT\_THAT(std::make\_tuple(pointer,\ 2),\ Contains(1));}
\DoxyCodeLine{08196\ \ \ EXPECT\_THAT(std::make\_tuple(pointer,\ 2),\ Not(Contains(Gt(3))));}
\DoxyCodeLine{08197\ \}}
\DoxyCodeLine{08198\ }
\DoxyCodeLine{08199\ TEST(ContainsTest,\ WorksForTwoDimensionalNativeArray)\ \{}
\DoxyCodeLine{08200\ \ \ \textcolor{keywordtype}{int}\ a[][3]\ =\ \{\{1,\ 2,\ 3\},\ \{4,\ 5,\ 6\}\};}
\DoxyCodeLine{08201\ \ \ EXPECT\_THAT(a,\ Contains(ElementsAre(4,\ 5,\ 6)));}
\DoxyCodeLine{08202\ \ \ EXPECT\_THAT(a,\ Contains(Contains(5)));}
\DoxyCodeLine{08203\ \ \ EXPECT\_THAT(a,\ Not(Contains(ElementsAre(3,\ 4,\ 5))));}
\DoxyCodeLine{08204\ \ \ EXPECT\_THAT(a,\ Contains(Not(Contains(5))));}
\DoxyCodeLine{08205\ \}}
\DoxyCodeLine{08206\ }
\DoxyCodeLine{08207\ \textcolor{comment}{//\ Tests\ Contains().Times().}}
\DoxyCodeLine{08208\ }
\DoxyCodeLine{08209\ TEST(ContainsTimes,\ ListMatchesWhenElementQuantityMatches)\ \{}
\DoxyCodeLine{08210\ \ \ list<int>\ some\_list;}
\DoxyCodeLine{08211\ \ \ some\_list.push\_back(3);}
\DoxyCodeLine{08212\ \ \ some\_list.push\_back(1);}
\DoxyCodeLine{08213\ \ \ some\_list.push\_back(2);}
\DoxyCodeLine{08214\ \ \ some\_list.push\_back(3);}
\DoxyCodeLine{08215\ \ \ EXPECT\_THAT(some\_list,\ Contains(3).Times(2));}
\DoxyCodeLine{08216\ \ \ EXPECT\_THAT(some\_list,\ Contains(2).Times(1));}
\DoxyCodeLine{08217\ \ \ EXPECT\_THAT(some\_list,\ Contains(Ge(2)).Times(3));}
\DoxyCodeLine{08218\ \ \ EXPECT\_THAT(some\_list,\ Contains(Ge(2)).Times(Gt(2)));}
\DoxyCodeLine{08219\ \ \ EXPECT\_THAT(some\_list,\ Contains(4).Times(0));}
\DoxyCodeLine{08220\ \ \ EXPECT\_THAT(some\_list,\ Contains(\_).Times(4));}
\DoxyCodeLine{08221\ \ \ EXPECT\_THAT(some\_list,\ Not(Contains(5).Times(1)));}
\DoxyCodeLine{08222\ \ \ EXPECT\_THAT(some\_list,\ Contains(5).Times(\_));\ \ \textcolor{comment}{//\ Times(\_)\ always\ matches}}
\DoxyCodeLine{08223\ \ \ EXPECT\_THAT(some\_list,\ Not(Contains(3).Times(1)));}
\DoxyCodeLine{08224\ \ \ EXPECT\_THAT(some\_list,\ Contains(3).Times(Not(1)));}
\DoxyCodeLine{08225\ \ \ EXPECT\_THAT(list<int>\{\},\ Not(Contains(\_)));}
\DoxyCodeLine{08226\ \}}
\DoxyCodeLine{08227\ }
\DoxyCodeLine{08228\ TEST(ContainsTimes,\ ExplainsMatchResultCorrectly)\ \{}
\DoxyCodeLine{08229\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ a[2]\ =\ \{1,\ 2\};}
\DoxyCodeLine{08230\ \ \ Matcher<\textcolor{keyword}{const}\ int(\&)[2]>\ m\ =\ Contains(2).Times(3);}
\DoxyCodeLine{08231\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{08232\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ element\ \#1\ matches\ but\ whose\ match\ quantity\ of\ 1\ does\ not\ match"{}},}
\DoxyCodeLine{08233\ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{08234\ }
\DoxyCodeLine{08235\ \ \ m\ =\ Contains(3).Times(0);}
\DoxyCodeLine{08236\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}has\ no\ element\ that\ matches\ and\ whose\ match\ quantity\ of\ 0\ matches"{}},}
\DoxyCodeLine{08237\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{08238\ }
\DoxyCodeLine{08239\ \ \ m\ =\ Contains(3).Times(4);}
\DoxyCodeLine{08240\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{08241\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}has\ no\ element\ that\ matches\ and\ whose\ match\ quantity\ of\ 0\ does\ not\ "{}}}
\DoxyCodeLine{08242\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}match"{}},}
\DoxyCodeLine{08243\ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{08244\ }
\DoxyCodeLine{08245\ \ \ m\ =\ Contains(2).Times(4);}
\DoxyCodeLine{08246\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{08247\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ element\ \#1\ matches\ but\ whose\ match\ quantity\ of\ 1\ does\ not\ "{}}}
\DoxyCodeLine{08248\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}match"{}},}
\DoxyCodeLine{08249\ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{08250\ }
\DoxyCodeLine{08251\ \ \ m\ =\ Contains(GreaterThan(0)).Times(2);}
\DoxyCodeLine{08252\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}whose\ elements\ (0,\ 1)\ match\ and\ whose\ match\ quantity\ of\ 2\ matches"{}},}
\DoxyCodeLine{08253\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{08254\ }
\DoxyCodeLine{08255\ \ \ m\ =\ Contains(GreaterThan(10)).Times(Gt(1));}
\DoxyCodeLine{08256\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{08257\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}has\ no\ element\ that\ matches\ and\ whose\ match\ quantity\ of\ 0\ does\ not\ "{}}}
\DoxyCodeLine{08258\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}match"{}},}
\DoxyCodeLine{08259\ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{08260\ }
\DoxyCodeLine{08261\ \ \ m\ =\ Contains(GreaterThan(0)).Times(GreaterThan<size\_t>(5));}
\DoxyCodeLine{08262\ \ \ EXPECT\_EQ(}
\DoxyCodeLine{08263\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}whose\ elements\ (0,\ 1)\ match\ but\ whose\ match\ quantity\ of\ 2\ does\ not\ "{}}}
\DoxyCodeLine{08264\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}match,\ which\ is\ 3\ less\ than\ 5"{}},}
\DoxyCodeLine{08265\ \ \ \ \ \ \ Explain(m,\ a));}
\DoxyCodeLine{08266\ \}}
\DoxyCodeLine{08267\ }
\DoxyCodeLine{08268\ TEST(ContainsTimes,\ DescribesItselfCorrectly)\ \{}
\DoxyCodeLine{08269\ \ \ Matcher<vector<int>>\ m\ =\ Contains(1).Times(2);}
\DoxyCodeLine{08270\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}quantity\ of\ elements\ that\ match\ is\ equal\ to\ 1\ is\ equal\ to\ 2"{}},}
\DoxyCodeLine{08271\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m));}
\DoxyCodeLine{08272\ }
\DoxyCodeLine{08273\ \ \ Matcher<vector<int>>\ m2\ =\ Not(m);}
\DoxyCodeLine{08274\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}quantity\ of\ elements\ that\ match\ is\ equal\ to\ 1\ isn't\ equal\ to\ 2"{}},}
\DoxyCodeLine{08275\ \ \ \ \ \ \ \ \ \ \ \ \ Describe(m2));}
\DoxyCodeLine{08276\ \}}
\DoxyCodeLine{08277\ }
\DoxyCodeLine{08278\ \textcolor{comment}{//\ Tests\ AllOfArray()}}
\DoxyCodeLine{08279\ }
\DoxyCodeLine{08280\ TEST(AllOfArrayTest,\ BasicForms)\ \{}
\DoxyCodeLine{08281\ \ \ \textcolor{comment}{//\ Iterator}}
\DoxyCodeLine{08282\ \ \ std::vector<int>\ v0\{\};}
\DoxyCodeLine{08283\ \ \ std::vector<int>\ v1\{1\};}
\DoxyCodeLine{08284\ \ \ std::vector<int>\ v2\{2,\ 3\};}
\DoxyCodeLine{08285\ \ \ std::vector<int>\ v3\{4,\ 4,\ 4\};}
\DoxyCodeLine{08286\ \ \ EXPECT\_THAT(0,\ AllOfArray(v0.begin(),\ v0.end()));}
\DoxyCodeLine{08287\ \ \ EXPECT\_THAT(1,\ AllOfArray(v1.begin(),\ v1.end()));}
\DoxyCodeLine{08288\ \ \ EXPECT\_THAT(2,\ Not(AllOfArray(v1.begin(),\ v1.end())));}
\DoxyCodeLine{08289\ \ \ EXPECT\_THAT(3,\ Not(AllOfArray(v2.begin(),\ v2.end())));}
\DoxyCodeLine{08290\ \ \ EXPECT\_THAT(4,\ AllOfArray(v3.begin(),\ v3.end()));}
\DoxyCodeLine{08291\ \ \ \textcolor{comment}{//\ Pointer\ +\ \ size}}
\DoxyCodeLine{08292\ \ \ \textcolor{keywordtype}{int}\ ar[6]\ =\ \{1,\ 2,\ 3,\ 4,\ 4,\ 4\};}
\DoxyCodeLine{08293\ \ \ EXPECT\_THAT(0,\ AllOfArray(ar,\ 0));}
\DoxyCodeLine{08294\ \ \ EXPECT\_THAT(1,\ AllOfArray(ar,\ 1));}
\DoxyCodeLine{08295\ \ \ EXPECT\_THAT(2,\ Not(AllOfArray(ar,\ 1)));}
\DoxyCodeLine{08296\ \ \ EXPECT\_THAT(3,\ Not(AllOfArray(ar\ +\ 1,\ 3)));}
\DoxyCodeLine{08297\ \ \ EXPECT\_THAT(4,\ AllOfArray(ar\ +\ 3,\ 3));}
\DoxyCodeLine{08298\ \ \ \textcolor{comment}{//\ Array}}
\DoxyCodeLine{08299\ \ \ \textcolor{comment}{//\ int\ ar0[0];\ \ Not\ usable}}
\DoxyCodeLine{08300\ \ \ \textcolor{keywordtype}{int}\ ar1[1]\ =\ \{1\};}
\DoxyCodeLine{08301\ \ \ \textcolor{keywordtype}{int}\ ar2[2]\ =\ \{2,\ 3\};}
\DoxyCodeLine{08302\ \ \ \textcolor{keywordtype}{int}\ ar3[3]\ =\ \{4,\ 4,\ 4\};}
\DoxyCodeLine{08303\ \ \ \textcolor{comment}{//\ EXPECT\_THAT(0,\ Not(AllOfArray(ar0)));\ \ //\ Cannot\ work}}
\DoxyCodeLine{08304\ \ \ EXPECT\_THAT(1,\ AllOfArray(ar1));}
\DoxyCodeLine{08305\ \ \ EXPECT\_THAT(2,\ Not(AllOfArray(ar1)));}
\DoxyCodeLine{08306\ \ \ EXPECT\_THAT(3,\ Not(AllOfArray(ar2)));}
\DoxyCodeLine{08307\ \ \ EXPECT\_THAT(4,\ AllOfArray(ar3));}
\DoxyCodeLine{08308\ \ \ \textcolor{comment}{//\ Container}}
\DoxyCodeLine{08309\ \ \ EXPECT\_THAT(0,\ AllOfArray(v0));}
\DoxyCodeLine{08310\ \ \ EXPECT\_THAT(1,\ AllOfArray(v1));}
\DoxyCodeLine{08311\ \ \ EXPECT\_THAT(2,\ Not(AllOfArray(v1)));}
\DoxyCodeLine{08312\ \ \ EXPECT\_THAT(3,\ Not(AllOfArray(v2)));}
\DoxyCodeLine{08313\ \ \ EXPECT\_THAT(4,\ AllOfArray(v3));}
\DoxyCodeLine{08314\ \ \ \textcolor{comment}{//\ Initializer}}
\DoxyCodeLine{08315\ \ \ EXPECT\_THAT(0,\ AllOfArray<int>(\{\}));\ \ \textcolor{comment}{//\ Requires\ template\ arg.}}
\DoxyCodeLine{08316\ \ \ EXPECT\_THAT(1,\ AllOfArray(\{1\}));}
\DoxyCodeLine{08317\ \ \ EXPECT\_THAT(2,\ Not(AllOfArray(\{1\})));}
\DoxyCodeLine{08318\ \ \ EXPECT\_THAT(3,\ Not(AllOfArray(\{2,\ 3\})));}
\DoxyCodeLine{08319\ \ \ EXPECT\_THAT(4,\ AllOfArray(\{4,\ 4,\ 4\}));}
\DoxyCodeLine{08320\ \}}
\DoxyCodeLine{08321\ }
\DoxyCodeLine{08322\ TEST(AllOfArrayTest,\ Matchers)\ \{}
\DoxyCodeLine{08323\ \ \ \textcolor{comment}{//\ vector}}
\DoxyCodeLine{08324\ \ \ std::vector<Matcher<int>>\ matchers\{Ge(1),\ Lt(2)\};}
\DoxyCodeLine{08325\ \ \ EXPECT\_THAT(0,\ Not(AllOfArray(matchers)));}
\DoxyCodeLine{08326\ \ \ EXPECT\_THAT(1,\ AllOfArray(matchers));}
\DoxyCodeLine{08327\ \ \ EXPECT\_THAT(2,\ Not(AllOfArray(matchers)));}
\DoxyCodeLine{08328\ \ \ \textcolor{comment}{//\ initializer\_list}}
\DoxyCodeLine{08329\ \ \ EXPECT\_THAT(0,\ Not(AllOfArray(\{Ge(0),\ Ge(1)\})));}
\DoxyCodeLine{08330\ \ \ EXPECT\_THAT(1,\ AllOfArray(\{Ge(0),\ Ge(1)\}));}
\DoxyCodeLine{08331\ \}}
\DoxyCodeLine{08332\ }
\DoxyCodeLine{08333\ TEST(AnyOfArrayTest,\ BasicForms)\ \{}
\DoxyCodeLine{08334\ \ \ \textcolor{comment}{//\ Iterator}}
\DoxyCodeLine{08335\ \ \ std::vector<int>\ v0\{\};}
\DoxyCodeLine{08336\ \ \ std::vector<int>\ v1\{1\};}
\DoxyCodeLine{08337\ \ \ std::vector<int>\ v2\{2,\ 3\};}
\DoxyCodeLine{08338\ \ \ EXPECT\_THAT(0,\ Not(AnyOfArray(v0.begin(),\ v0.end())));}
\DoxyCodeLine{08339\ \ \ EXPECT\_THAT(1,\ AnyOfArray(v1.begin(),\ v1.end()));}
\DoxyCodeLine{08340\ \ \ EXPECT\_THAT(2,\ Not(AnyOfArray(v1.begin(),\ v1.end())));}
\DoxyCodeLine{08341\ \ \ EXPECT\_THAT(3,\ AnyOfArray(v2.begin(),\ v2.end()));}
\DoxyCodeLine{08342\ \ \ EXPECT\_THAT(4,\ Not(AnyOfArray(v2.begin(),\ v2.end())));}
\DoxyCodeLine{08343\ \ \ \textcolor{comment}{//\ Pointer\ +\ \ size}}
\DoxyCodeLine{08344\ \ \ \textcolor{keywordtype}{int}\ ar[3]\ =\ \{1,\ 2,\ 3\};}
\DoxyCodeLine{08345\ \ \ EXPECT\_THAT(0,\ Not(AnyOfArray(ar,\ 0)));}
\DoxyCodeLine{08346\ \ \ EXPECT\_THAT(1,\ AnyOfArray(ar,\ 1));}
\DoxyCodeLine{08347\ \ \ EXPECT\_THAT(2,\ Not(AnyOfArray(ar,\ 1)));}
\DoxyCodeLine{08348\ \ \ EXPECT\_THAT(3,\ AnyOfArray(ar\ +\ 1,\ 2));}
\DoxyCodeLine{08349\ \ \ EXPECT\_THAT(4,\ Not(AnyOfArray(ar\ +\ 1,\ 2)));}
\DoxyCodeLine{08350\ \ \ \textcolor{comment}{//\ Array}}
\DoxyCodeLine{08351\ \ \ \textcolor{comment}{//\ int\ ar0[0];\ \ Not\ usable}}
\DoxyCodeLine{08352\ \ \ \textcolor{keywordtype}{int}\ ar1[1]\ =\ \{1\};}
\DoxyCodeLine{08353\ \ \ \textcolor{keywordtype}{int}\ ar2[2]\ =\ \{2,\ 3\};}
\DoxyCodeLine{08354\ \ \ \textcolor{comment}{//\ EXPECT\_THAT(0,\ Not(AnyOfArray(ar0)));\ \ //\ Cannot\ work}}
\DoxyCodeLine{08355\ \ \ EXPECT\_THAT(1,\ AnyOfArray(ar1));}
\DoxyCodeLine{08356\ \ \ EXPECT\_THAT(2,\ Not(AnyOfArray(ar1)));}
\DoxyCodeLine{08357\ \ \ EXPECT\_THAT(3,\ AnyOfArray(ar2));}
\DoxyCodeLine{08358\ \ \ EXPECT\_THAT(4,\ Not(AnyOfArray(ar2)));}
\DoxyCodeLine{08359\ \ \ \textcolor{comment}{//\ Container}}
\DoxyCodeLine{08360\ \ \ EXPECT\_THAT(0,\ Not(AnyOfArray(v0)));}
\DoxyCodeLine{08361\ \ \ EXPECT\_THAT(1,\ AnyOfArray(v1));}
\DoxyCodeLine{08362\ \ \ EXPECT\_THAT(2,\ Not(AnyOfArray(v1)));}
\DoxyCodeLine{08363\ \ \ EXPECT\_THAT(3,\ AnyOfArray(v2));}
\DoxyCodeLine{08364\ \ \ EXPECT\_THAT(4,\ Not(AnyOfArray(v2)));}
\DoxyCodeLine{08365\ \ \ \textcolor{comment}{//\ Initializer}}
\DoxyCodeLine{08366\ \ \ EXPECT\_THAT(0,\ Not(AnyOfArray<int>(\{\})));\ \ \textcolor{comment}{//\ Requires\ template\ arg.}}
\DoxyCodeLine{08367\ \ \ EXPECT\_THAT(1,\ AnyOfArray(\{1\}));}
\DoxyCodeLine{08368\ \ \ EXPECT\_THAT(2,\ Not(AnyOfArray(\{1\})));}
\DoxyCodeLine{08369\ \ \ EXPECT\_THAT(3,\ AnyOfArray(\{2,\ 3\}));}
\DoxyCodeLine{08370\ \ \ EXPECT\_THAT(4,\ Not(AnyOfArray(\{2,\ 3\})));}
\DoxyCodeLine{08371\ \}}
\DoxyCodeLine{08372\ }
\DoxyCodeLine{08373\ TEST(AnyOfArrayTest,\ Matchers)\ \{}
\DoxyCodeLine{08374\ \ \ \textcolor{comment}{//\ We\ negate\ test\ AllOfArrayTest.Matchers.}}
\DoxyCodeLine{08375\ \ \ \textcolor{comment}{//\ vector}}
\DoxyCodeLine{08376\ \ \ std::vector<Matcher<int>>\ matchers\{Lt(1),\ Ge(2)\};}
\DoxyCodeLine{08377\ \ \ EXPECT\_THAT(0,\ AnyOfArray(matchers));}
\DoxyCodeLine{08378\ \ \ EXPECT\_THAT(1,\ Not(AnyOfArray(matchers)));}
\DoxyCodeLine{08379\ \ \ EXPECT\_THAT(2,\ AnyOfArray(matchers));}
\DoxyCodeLine{08380\ \ \ \textcolor{comment}{//\ initializer\_list}}
\DoxyCodeLine{08381\ \ \ EXPECT\_THAT(0,\ AnyOfArray(\{Lt(0),\ Lt(1)\}));}
\DoxyCodeLine{08382\ \ \ EXPECT\_THAT(1,\ Not(AllOfArray(\{Lt(0),\ Lt(1)\})));}
\DoxyCodeLine{08383\ \}}
\DoxyCodeLine{08384\ }
\DoxyCodeLine{08385\ TEST(AnyOfArrayTest,\ ExplainsMatchResultCorrectly)\ \{}
\DoxyCodeLine{08386\ \ \ \textcolor{comment}{//\ AnyOfArray\ and\ AllOfArry\ use\ the\ same\ underlying\ template-\/template,}}
\DoxyCodeLine{08387\ \ \ \textcolor{comment}{//\ thus\ it\ is\ sufficient\ to\ test\ one\ here.}}
\DoxyCodeLine{08388\ \ \ \textcolor{keyword}{const}\ std::vector<int>\ v0\{\};}
\DoxyCodeLine{08389\ \ \ \textcolor{keyword}{const}\ std::vector<int>\ v1\{1\};}
\DoxyCodeLine{08390\ \ \ \textcolor{keyword}{const}\ std::vector<int>\ v2\{2,\ 3\};}
\DoxyCodeLine{08391\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m0\ =\ AnyOfArray(v0);}
\DoxyCodeLine{08392\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m1\ =\ AnyOfArray(v1);}
\DoxyCodeLine{08393\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ m2\ =\ AnyOfArray(v2);}
\DoxyCodeLine{08394\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m0,\ 0));}
\DoxyCodeLine{08395\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m1,\ 1));}
\DoxyCodeLine{08396\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m1,\ 2));}
\DoxyCodeLine{08397\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m2,\ 3));}
\DoxyCodeLine{08398\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}"{}},\ Explain(m2,\ 4));}
\DoxyCodeLine{08399\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}()"{}},\ Describe(m0));}
\DoxyCodeLine{08400\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(is\ equal\ to\ 1)"{}},\ Describe(m1));}
\DoxyCodeLine{08401\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(is\ equal\ to\ 2)\ or\ (is\ equal\ to\ 3)"{}},\ Describe(m2));}
\DoxyCodeLine{08402\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}()"{}},\ DescribeNegation(m0));}
\DoxyCodeLine{08403\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(isn't\ equal\ to\ 1)"{}},\ DescribeNegation(m1));}
\DoxyCodeLine{08404\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}(isn't\ equal\ to\ 2)\ and\ (isn't\ equal\ to\ 3)"{}},\ DescribeNegation(m2));}
\DoxyCodeLine{08405\ \ \ \textcolor{comment}{//\ Explain\ with\ matchers}}
\DoxyCodeLine{08406\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ g1\ =\ AnyOfArray(\{GreaterThan(1)\});}
\DoxyCodeLine{08407\ \ \ \textcolor{keyword}{const}\ Matcher<int>\ g2\ =\ AnyOfArray(\{GreaterThan(1),\ GreaterThan(2)\});}
\DoxyCodeLine{08408\ \ \ \textcolor{comment}{//\ Explains\ the\ first\ positive\ match\ and\ all\ prior\ negative\ matches...}}
\DoxyCodeLine{08409\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 1\ less\ than\ 1"{}},\ Explain(g1,\ 0));}
\DoxyCodeLine{08410\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ the\ same\ as\ 1"{}},\ Explain(g1,\ 1));}
\DoxyCodeLine{08411\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 1\ more\ than\ 1"{}},\ Explain(g1,\ 2));}
\DoxyCodeLine{08412\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 1\ less\ than\ 1,\ and\ which\ is\ 2\ less\ than\ 2"{}},}
\DoxyCodeLine{08413\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(g2,\ 0));}
\DoxyCodeLine{08414\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ the\ same\ as\ 1,\ and\ which\ is\ 1\ less\ than\ 2"{}},}
\DoxyCodeLine{08415\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(g2,\ 1));}
\DoxyCodeLine{08416\ \ \ EXPECT\_EQ(\textcolor{stringliteral}{"{}which\ is\ 1\ more\ than\ 1"{}},\ \ \textcolor{comment}{//\ Only\ the\ first}}
\DoxyCodeLine{08417\ \ \ \ \ \ \ \ \ \ \ \ \ Explain(g2,\ 2));}
\DoxyCodeLine{08418\ \}}
\DoxyCodeLine{08419\ }
\DoxyCodeLine{08420\ TEST(AllOfTest,\ HugeMatcher)\ \{}
\DoxyCodeLine{08421\ \ \ \textcolor{comment}{//\ Verify\ that\ using\ AllOf\ with\ many\ arguments\ doesn't\ cause}}
\DoxyCodeLine{08422\ \ \ \textcolor{comment}{//\ the\ compiler\ to\ exceed\ template\ instantiation\ depth\ limit.}}
\DoxyCodeLine{08423\ \ \ EXPECT\_THAT(0,\ testing::AllOf(\_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,}
\DoxyCodeLine{08424\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ testing::AllOf(\_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_)));}
\DoxyCodeLine{08425\ \}}
\DoxyCodeLine{08426\ }
\DoxyCodeLine{08427\ TEST(AnyOfTest,\ HugeMatcher)\ \{}
\DoxyCodeLine{08428\ \ \ \textcolor{comment}{//\ Verify\ that\ using\ AnyOf\ with\ many\ arguments\ doesn't\ cause}}
\DoxyCodeLine{08429\ \ \ \textcolor{comment}{//\ the\ compiler\ to\ exceed\ template\ instantiation\ depth\ limit.}}
\DoxyCodeLine{08430\ \ \ EXPECT\_THAT(0,\ testing::AnyOf(\_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,}
\DoxyCodeLine{08431\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ testing::AnyOf(\_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_,\ \_)));}
\DoxyCodeLine{08432\ \}}
\DoxyCodeLine{08433\ }
\DoxyCodeLine{08434\ \textcolor{keyword}{namespace\ }adl\_test\ \{}
\DoxyCodeLine{08435\ }
\DoxyCodeLine{08436\ \textcolor{comment}{//\ Verifies\ that\ the\ implementation\ of\ ::testing::AllOf\ and\ ::testing::AnyOf}}
\DoxyCodeLine{08437\ \textcolor{comment}{//\ don't\ issue\ unqualified\ recursive\ calls.\ \ If\ they\ do,\ the\ argument\ dependent}}
\DoxyCodeLine{08438\ \textcolor{comment}{//\ name\ lookup\ will\ cause\ AllOf/AnyOf\ in\ the\ 'adl\_test'\ namespace\ to\ be\ found}}
\DoxyCodeLine{08439\ \textcolor{comment}{//\ as\ a\ candidate\ and\ the\ compilation\ will\ break\ due\ to\ an\ ambiguous\ overload.}}
\DoxyCodeLine{08440\ }
\DoxyCodeLine{08441\ \textcolor{comment}{//\ The\ matcher\ must\ be\ in\ the\ same\ namespace\ as\ AllOf/AnyOf\ to\ make\ argument}}
\DoxyCodeLine{08442\ \textcolor{comment}{//\ dependent\ lookup\ find\ those.}}
\DoxyCodeLine{08443\ MATCHER(M,\ \textcolor{stringliteral}{"{}"{}})\ \{}
\DoxyCodeLine{08444\ \ \ (void)arg;}
\DoxyCodeLine{08445\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{08446\ \}}
\DoxyCodeLine{08447\ }
\DoxyCodeLine{08448\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{08449\ \textcolor{keywordtype}{bool}\ AllOf(\textcolor{keyword}{const}\ T1\&\ \textcolor{comment}{/*t1*/},\ \textcolor{keyword}{const}\ T2\&\ \textcolor{comment}{/*t2*/})\ \{}
\DoxyCodeLine{08450\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{08451\ \}}
\DoxyCodeLine{08452\ }
\DoxyCodeLine{08453\ TEST(AllOfTest,\ DoesNotCallAllOfUnqualified)\ \{}
\DoxyCodeLine{08454\ \ \ EXPECT\_THAT(42,}
\DoxyCodeLine{08455\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ testing::AllOf(M(),\ M(),\ M(),\ M(),\ M(),\ M(),\ M(),\ M(),\ M(),\ M()));}
\DoxyCodeLine{08456\ \}}
\DoxyCodeLine{08457\ }
\DoxyCodeLine{08458\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T1,\ \textcolor{keyword}{typename}\ T2>}
\DoxyCodeLine{08459\ \textcolor{keywordtype}{bool}\ AnyOf(\textcolor{keyword}{const}\ T1\&,\ \textcolor{keyword}{const}\ T2\&)\ \{}
\DoxyCodeLine{08460\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{08461\ \}}
\DoxyCodeLine{08462\ }
\DoxyCodeLine{08463\ TEST(AnyOfTest,\ DoesNotCallAnyOfUnqualified)\ \{}
\DoxyCodeLine{08464\ \ \ EXPECT\_THAT(42,}
\DoxyCodeLine{08465\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ testing::AnyOf(M(),\ M(),\ M(),\ M(),\ M(),\ M(),\ M(),\ M(),\ M(),\ M()));}
\DoxyCodeLine{08466\ \}}
\DoxyCodeLine{08467\ }
\DoxyCodeLine{08468\ \}\ \ \textcolor{comment}{//\ namespace\ adl\_test}}
\DoxyCodeLine{08469\ }
\DoxyCodeLine{08470\ TEST(AllOfTest,\ WorksOnMoveOnlyType)\ \{}
\DoxyCodeLine{08471\ \ \ std::unique\_ptr<int>\ p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(3));}
\DoxyCodeLine{08472\ \ \ EXPECT\_THAT(p,\ AllOf(Pointee(Eq(3)),\ Pointee(Gt(0)),\ Pointee(Lt(5))));}
\DoxyCodeLine{08473\ \ \ EXPECT\_THAT(p,\ Not(AllOf(Pointee(Eq(3)),\ Pointee(Gt(0)),\ Pointee(Lt(3)))));}
\DoxyCodeLine{08474\ \}}
\DoxyCodeLine{08475\ }
\DoxyCodeLine{08476\ TEST(AnyOfTest,\ WorksOnMoveOnlyType)\ \{}
\DoxyCodeLine{08477\ \ \ std::unique\_ptr<int>\ p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(3));}
\DoxyCodeLine{08478\ \ \ EXPECT\_THAT(p,\ AnyOf(Pointee(Eq(5)),\ Pointee(Lt(0)),\ Pointee(Lt(5))));}
\DoxyCodeLine{08479\ \ \ EXPECT\_THAT(p,\ Not(AnyOf(Pointee(Eq(5)),\ Pointee(Lt(0)),\ Pointee(Gt(5)))));}
\DoxyCodeLine{08480\ \}}
\DoxyCodeLine{08481\ }
\DoxyCodeLine{08482\ MATCHER(IsNotNull,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ arg\ !=\ \textcolor{keyword}{nullptr};\ \}}
\DoxyCodeLine{08483\ }
\DoxyCodeLine{08484\ \textcolor{comment}{//\ Verifies\ that\ a\ matcher\ defined\ using\ MATCHER()\ can\ work\ on}}
\DoxyCodeLine{08485\ \textcolor{comment}{//\ move-\/only\ types.}}
\DoxyCodeLine{08486\ TEST(MatcherMacroTest,\ WorksOnMoveOnlyType)\ \{}
\DoxyCodeLine{08487\ \ \ std::unique\_ptr<int>\ p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(3));}
\DoxyCodeLine{08488\ \ \ EXPECT\_THAT(p,\ IsNotNull());}
\DoxyCodeLine{08489\ \ \ EXPECT\_THAT(std::unique\_ptr<int>(),\ Not(IsNotNull()));}
\DoxyCodeLine{08490\ \}}
\DoxyCodeLine{08491\ }
\DoxyCodeLine{08492\ MATCHER\_P(UniquePointee,\ pointee,\ \textcolor{stringliteral}{"{}"{}})\ \{\ \textcolor{keywordflow}{return}\ *arg\ ==\ pointee;\ \}}
\DoxyCodeLine{08493\ }
\DoxyCodeLine{08494\ \textcolor{comment}{//\ Verifies\ that\ a\ matcher\ defined\ using\ MATCHER\_P*()\ can\ work\ on}}
\DoxyCodeLine{08495\ \textcolor{comment}{//\ move-\/only\ types.}}
\DoxyCodeLine{08496\ TEST(MatcherPMacroTest,\ WorksOnMoveOnlyType)\ \{}
\DoxyCodeLine{08497\ \ \ std::unique\_ptr<int>\ p(\textcolor{keyword}{new}\ \textcolor{keywordtype}{int}(3));}
\DoxyCodeLine{08498\ \ \ EXPECT\_THAT(p,\ UniquePointee(3));}
\DoxyCodeLine{08499\ \ \ EXPECT\_THAT(p,\ Not(UniquePointee(2)));}
\DoxyCodeLine{08500\ \}}
\DoxyCodeLine{08501\ }
\DoxyCodeLine{08502\ \textcolor{preprocessor}{\#if\ GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{08503\ }
\DoxyCodeLine{08504\ \textcolor{comment}{//\ std::function<void()>\ is\ used\ below\ for\ compatibility\ with\ older\ copies\ of}}
\DoxyCodeLine{08505\ \textcolor{comment}{//\ GCC.\ Normally,\ a\ raw\ lambda\ is\ all\ that\ is\ needed.}}
\DoxyCodeLine{08506\ }
\DoxyCodeLine{08507\ \textcolor{comment}{//\ Test\ that\ examples\ from\ documentation\ compile}}
\DoxyCodeLine{08508\ TEST(ThrowsTest,\ Examples)\ \{}
\DoxyCodeLine{08509\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{08510\ \ \ \ \ \ \ std::function<\textcolor{keywordtype}{void}()>([]()\ \{\ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}message"{}});\ \}),}
\DoxyCodeLine{08511\ \ \ \ \ \ \ Throws<std::runtime\_error>());}
\DoxyCodeLine{08512\ }
\DoxyCodeLine{08513\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{08514\ \ \ \ \ \ \ std::function<\textcolor{keywordtype}{void}()>([]()\ \{\ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}message"{}});\ \}),}
\DoxyCodeLine{08515\ \ \ \ \ \ \ ThrowsMessage<std::runtime\_error>(HasSubstr(\textcolor{stringliteral}{"{}message"{}})));}
\DoxyCodeLine{08516\ \}}
\DoxyCodeLine{08517\ }
\DoxyCodeLine{08518\ TEST(ThrowsTest,\ PrintsExceptionWhat)\ \{}
\DoxyCodeLine{08519\ \ \ EXPECT\_THAT(}
\DoxyCodeLine{08520\ \ \ \ \ \ \ std::function<\textcolor{keywordtype}{void}()>([]()\ \{\ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}ABC123XYZ"{}});\ \}),}
\DoxyCodeLine{08521\ \ \ \ \ \ \ ThrowsMessage<std::runtime\_error>(HasSubstr(\textcolor{stringliteral}{"{}ABC123XYZ"{}})));}
\DoxyCodeLine{08522\ \}}
\DoxyCodeLine{08523\ }
\DoxyCodeLine{08524\ TEST(ThrowsTest,\ DoesNotGenerateDuplicateCatchClauseWarning)\ \{}
\DoxyCodeLine{08525\ \ \ EXPECT\_THAT(std::function<\textcolor{keywordtype}{void}()>([]()\ \{\ \textcolor{keywordflow}{throw}\ std::exception();\ \}),}
\DoxyCodeLine{08526\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Throws<std::exception>());}
\DoxyCodeLine{08527\ \}}
\DoxyCodeLine{08528\ }
\DoxyCodeLine{08529\ TEST(ThrowsTest,\ CallableExecutedExactlyOnce)\ \{}
\DoxyCodeLine{08530\ \ \ \textcolor{keywordtype}{size\_t}\ a\ =\ 0;}
\DoxyCodeLine{08531\ }
\DoxyCodeLine{08532\ \ \ EXPECT\_THAT(std::function<\textcolor{keywordtype}{void}()>([\&a]()\ \{}
\DoxyCodeLine{08533\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a++;}
\DoxyCodeLine{08534\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ 10;}
\DoxyCodeLine{08535\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}),}
\DoxyCodeLine{08536\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Throws<int>());}
\DoxyCodeLine{08537\ \ \ EXPECT\_EQ(a,\ 1u);}
\DoxyCodeLine{08538\ }
\DoxyCodeLine{08539\ \ \ EXPECT\_THAT(std::function<\textcolor{keywordtype}{void}()>([\&a]()\ \{}
\DoxyCodeLine{08540\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a++;}
\DoxyCodeLine{08541\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}message"{}});}
\DoxyCodeLine{08542\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}),}
\DoxyCodeLine{08543\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Throws<std::runtime\_error>());}
\DoxyCodeLine{08544\ \ \ EXPECT\_EQ(a,\ 2u);}
\DoxyCodeLine{08545\ }
\DoxyCodeLine{08546\ \ \ EXPECT\_THAT(std::function<\textcolor{keywordtype}{void}()>([\&a]()\ \{}
\DoxyCodeLine{08547\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a++;}
\DoxyCodeLine{08548\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}message"{}});}
\DoxyCodeLine{08549\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}),}
\DoxyCodeLine{08550\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ThrowsMessage<std::runtime\_error>(HasSubstr(\textcolor{stringliteral}{"{}message"{}})));}
\DoxyCodeLine{08551\ \ \ EXPECT\_EQ(a,\ 3u);}
\DoxyCodeLine{08552\ }
\DoxyCodeLine{08553\ \ \ EXPECT\_THAT(std::function<\textcolor{keywordtype}{void}()>([\&a]()\ \{}
\DoxyCodeLine{08554\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a++;}
\DoxyCodeLine{08555\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}message"{}});}
\DoxyCodeLine{08556\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}),}
\DoxyCodeLine{08557\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Throws<std::runtime\_error>(}
\DoxyCodeLine{08558\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Property(\&std::runtime\_error::what,\ HasSubstr(\textcolor{stringliteral}{"{}message"{}}))));}
\DoxyCodeLine{08559\ \ \ EXPECT\_EQ(a,\ 4u);}
\DoxyCodeLine{08560\ \}}
\DoxyCodeLine{08561\ }
\DoxyCodeLine{08562\ TEST(ThrowsTest,\ Describe)\ \{}
\DoxyCodeLine{08563\ \ \ Matcher<std::function<void()>>\ matcher\ =\ Throws<std::runtime\_error>();}
\DoxyCodeLine{08564\ \ \ std::stringstream\ ss;}
\DoxyCodeLine{08565\ \ \ matcher.DescribeTo(\&ss);}
\DoxyCodeLine{08566\ \ \ \textcolor{keyword}{auto}\ explanation\ =\ ss.str();}
\DoxyCodeLine{08567\ \ \ EXPECT\_THAT(explanation,\ HasSubstr(\textcolor{stringliteral}{"{}std::runtime\_error"{}}));}
\DoxyCodeLine{08568\ \}}
\DoxyCodeLine{08569\ }
\DoxyCodeLine{08570\ TEST(ThrowsTest,\ Success)\ \{}
\DoxyCodeLine{08571\ \ \ Matcher<std::function<void()>>\ matcher\ =\ Throws<std::runtime\_error>();}
\DoxyCodeLine{08572\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{08573\ \ \ EXPECT\_TRUE(matcher.MatchAndExplain(}
\DoxyCodeLine{08574\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error(\textcolor{stringliteral}{"{}error\ message"{}});\ \},\ \&listener));}
\DoxyCodeLine{08575\ \ \ EXPECT\_THAT(listener.str(),\ HasSubstr(\textcolor{stringliteral}{"{}std::runtime\_error"{}}));}
\DoxyCodeLine{08576\ \}}
\DoxyCodeLine{08577\ }
\DoxyCodeLine{08578\ TEST(ThrowsTest,\ FailWrongType)\ \{}
\DoxyCodeLine{08579\ \ \ Matcher<std::function<void()>>\ matcher\ =\ Throws<std::runtime\_error>();}
\DoxyCodeLine{08580\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{08581\ \ \ EXPECT\_FALSE(matcher.MatchAndExplain(}
\DoxyCodeLine{08582\ \ \ \ \ \ \ []()\ \{\ throw\ std::logic\_error(\textcolor{stringliteral}{"{}error\ message"{}});\ \},\ \&listener));}
\DoxyCodeLine{08583\ \ \ EXPECT\_THAT(listener.str(),\ HasSubstr(\textcolor{stringliteral}{"{}std::logic\_error"{}}));}
\DoxyCodeLine{08584\ \ \ EXPECT\_THAT(listener.str(),\ HasSubstr(\textcolor{stringliteral}{"{}\(\backslash\)"{}error\ message\(\backslash\)"{}"{}}));}
\DoxyCodeLine{08585\ \}}
\DoxyCodeLine{08586\ }
\DoxyCodeLine{08587\ TEST(ThrowsTest,\ FailWrongTypeNonStd)\ \{}
\DoxyCodeLine{08588\ \ \ Matcher<std::function<void()>>\ matcher\ =\ Throws<std::runtime\_error>();}
\DoxyCodeLine{08589\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{08590\ \ \ EXPECT\_FALSE(matcher.MatchAndExplain([]()\ \{\ throw\ 10;\ \},\ \&listener));}
\DoxyCodeLine{08591\ \ \ EXPECT\_THAT(listener.str(),}
\DoxyCodeLine{08592\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ HasSubstr(\textcolor{stringliteral}{"{}throws\ an\ exception\ of\ an\ unknown\ type"{}}));}
\DoxyCodeLine{08593\ \}}
\DoxyCodeLine{08594\ }
\DoxyCodeLine{08595\ TEST(ThrowsTest,\ FailNoThrow)\ \{}
\DoxyCodeLine{08596\ \ \ Matcher<std::function<void()>>\ matcher\ =\ Throws<std::runtime\_error>();}
\DoxyCodeLine{08597\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{08598\ \ \ EXPECT\_FALSE(matcher.MatchAndExplain([]()\ \{\ (void)0;\ \},\ \&listener));}
\DoxyCodeLine{08599\ \ \ EXPECT\_THAT(listener.str(),\ HasSubstr(\textcolor{stringliteral}{"{}does\ not\ throw\ any\ exception"{}}));}
\DoxyCodeLine{08600\ \}}
\DoxyCodeLine{08601\ }
\DoxyCodeLine{08602\ \textcolor{keyword}{class\ }ThrowsPredicateTest}
\DoxyCodeLine{08603\ \ \ \ \ :\ \textcolor{keyword}{public}\ TestWithParam<Matcher<std::function<void()>>>\ \{\};}
\DoxyCodeLine{08604\ }
\DoxyCodeLine{08605\ TEST\_P(ThrowsPredicateTest,\ Describe)\ \{}
\DoxyCodeLine{08606\ \ \ Matcher<std::function<void()>>\ matcher\ =\ GetParam();}
\DoxyCodeLine{08607\ \ \ std::stringstream\ ss;}
\DoxyCodeLine{08608\ \ \ matcher.DescribeTo(\&ss);}
\DoxyCodeLine{08609\ \ \ \textcolor{keyword}{auto}\ explanation\ =\ ss.str();}
\DoxyCodeLine{08610\ \ \ EXPECT\_THAT(explanation,\ HasSubstr(\textcolor{stringliteral}{"{}std::runtime\_error"{}}));}
\DoxyCodeLine{08611\ \ \ EXPECT\_THAT(explanation,\ HasSubstr(\textcolor{stringliteral}{"{}error\ message"{}}));}
\DoxyCodeLine{08612\ \}}
\DoxyCodeLine{08613\ }
\DoxyCodeLine{08614\ TEST\_P(ThrowsPredicateTest,\ Success)\ \{}
\DoxyCodeLine{08615\ \ \ Matcher<std::function<void()>>\ matcher\ =\ GetParam();}
\DoxyCodeLine{08616\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{08617\ \ \ EXPECT\_TRUE(matcher.MatchAndExplain(}
\DoxyCodeLine{08618\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error(\textcolor{stringliteral}{"{}error\ message"{}});\ \},\ \&listener));}
\DoxyCodeLine{08619\ \ \ EXPECT\_THAT(listener.str(),\ HasSubstr(\textcolor{stringliteral}{"{}std::runtime\_error"{}}));}
\DoxyCodeLine{08620\ \}}
\DoxyCodeLine{08621\ }
\DoxyCodeLine{08622\ TEST\_P(ThrowsPredicateTest,\ FailWrongType)\ \{}
\DoxyCodeLine{08623\ \ \ Matcher<std::function<void()>>\ matcher\ =\ GetParam();}
\DoxyCodeLine{08624\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{08625\ \ \ EXPECT\_FALSE(matcher.MatchAndExplain(}
\DoxyCodeLine{08626\ \ \ \ \ \ \ []()\ \{\ throw\ std::logic\_error(\textcolor{stringliteral}{"{}error\ message"{}});\ \},\ \&listener));}
\DoxyCodeLine{08627\ \ \ EXPECT\_THAT(listener.str(),\ HasSubstr(\textcolor{stringliteral}{"{}std::logic\_error"{}}));}
\DoxyCodeLine{08628\ \ \ EXPECT\_THAT(listener.str(),\ HasSubstr(\textcolor{stringliteral}{"{}\(\backslash\)"{}error\ message\(\backslash\)"{}"{}}));}
\DoxyCodeLine{08629\ \}}
\DoxyCodeLine{08630\ }
\DoxyCodeLine{08631\ TEST\_P(ThrowsPredicateTest,\ FailWrongTypeNonStd)\ \{}
\DoxyCodeLine{08632\ \ \ Matcher<std::function<void()>>\ matcher\ =\ GetParam();}
\DoxyCodeLine{08633\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{08634\ \ \ EXPECT\_FALSE(matcher.MatchAndExplain([]()\ \{\ throw\ 10;\ \},\ \&listener));}
\DoxyCodeLine{08635\ \ \ EXPECT\_THAT(listener.str(),}
\DoxyCodeLine{08636\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ HasSubstr(\textcolor{stringliteral}{"{}throws\ an\ exception\ of\ an\ unknown\ type"{}}));}
\DoxyCodeLine{08637\ \}}
\DoxyCodeLine{08638\ }
\DoxyCodeLine{08639\ TEST\_P(ThrowsPredicateTest,\ FailNoThrow)\ \{}
\DoxyCodeLine{08640\ \ \ Matcher<std::function<void()>>\ matcher\ =\ GetParam();}
\DoxyCodeLine{08641\ \ \ StringMatchResultListener\ listener;}
\DoxyCodeLine{08642\ \ \ EXPECT\_FALSE(matcher.MatchAndExplain([]()\ \{\},\ \&listener));}
\DoxyCodeLine{08643\ \ \ EXPECT\_THAT(listener.str(),\ HasSubstr(\textcolor{stringliteral}{"{}does\ not\ throw\ any\ exception"{}}));}
\DoxyCodeLine{08644\ \}}
\DoxyCodeLine{08645\ }
\DoxyCodeLine{08646\ INSTANTIATE\_TEST\_SUITE\_P(}
\DoxyCodeLine{08647\ \ \ \ \ AllMessagePredicates,\ ThrowsPredicateTest,}
\DoxyCodeLine{08648\ \ \ \ \ Values(Matcher<std::function<\textcolor{keywordtype}{void}()>>(}
\DoxyCodeLine{08649\ \ \ \ \ \ \ \ \ ThrowsMessage<std::runtime\_error>(HasSubstr(\textcolor{stringliteral}{"{}error\ message"{}})))));}
\DoxyCodeLine{08650\ }
\DoxyCodeLine{08651\ \textcolor{comment}{//\ Tests\ that\ Throws<E1>(Matcher<E2>\{\})\ compiles\ even\ when\ E2\ !=\ const\ E1\&.}}
\DoxyCodeLine{08652\ TEST(ThrowsPredicateCompilesTest,\ ExceptionMatcherAcceptsBroadType)\ \{}
\DoxyCodeLine{08653\ \ \ \{}
\DoxyCodeLine{08654\ \ \ \ \ Matcher<std::function<void()>>\ matcher\ =}
\DoxyCodeLine{08655\ \ \ \ \ \ \ \ \ ThrowsMessage<std::runtime\_error>(HasSubstr(\textcolor{stringliteral}{"{}error\ message"{}}));}
\DoxyCodeLine{08656\ \ \ \ \ EXPECT\_TRUE(}
\DoxyCodeLine{08657\ \ \ \ \ \ \ \ \ matcher.Matches([]()\ \{\ throw\ std::runtime\_error(\textcolor{stringliteral}{"{}error\ message"{}});\ \}));}
\DoxyCodeLine{08658\ \ \ \ \ EXPECT\_FALSE(}
\DoxyCodeLine{08659\ \ \ \ \ \ \ \ \ matcher.Matches([]()\ \{\ throw\ std::runtime\_error(\textcolor{stringliteral}{"{}wrong\ message"{}});\ \}));}
\DoxyCodeLine{08660\ \ \ \}}
\DoxyCodeLine{08661\ }
\DoxyCodeLine{08662\ \ \ \{}
\DoxyCodeLine{08663\ \ \ \ \ Matcher<uint64\_t>\ inner\ =\ Eq(10);}
\DoxyCodeLine{08664\ \ \ \ \ Matcher<std::function<void()>>\ matcher\ =\ Throws<uint32\_t>(inner);}
\DoxyCodeLine{08665\ \ \ \ \ EXPECT\_TRUE(matcher.Matches([]()\ \{\ throw(uint32\_t)\ 10;\ \}));}
\DoxyCodeLine{08666\ \ \ \ \ EXPECT\_FALSE(matcher.Matches([]()\ \{\ throw(uint32\_t)\ 11;\ \}));}
\DoxyCodeLine{08667\ \ \ \}}
\DoxyCodeLine{08668\ \}}
\DoxyCodeLine{08669\ }
\DoxyCodeLine{08670\ \textcolor{comment}{//\ Tests\ that\ ThrowsMessage("{}message"{})\ is\ equivalent}}
\DoxyCodeLine{08671\ \textcolor{comment}{//\ to\ ThrowsMessage(Eq<std::string>("{}message"{})).}}
\DoxyCodeLine{08672\ TEST(ThrowsPredicateCompilesTest,\ MessageMatcherAcceptsNonMatcher)\ \{}
\DoxyCodeLine{08673\ \ \ Matcher<std::function<void()>>\ matcher\ =}
\DoxyCodeLine{08674\ \ \ \ \ \ \ ThrowsMessage<std::runtime\_error>(\textcolor{stringliteral}{"{}error\ message"{}});}
\DoxyCodeLine{08675\ \ \ EXPECT\_TRUE(}
\DoxyCodeLine{08676\ \ \ \ \ \ \ matcher.Matches([]()\ \{\ throw\ std::runtime\_error(\textcolor{stringliteral}{"{}error\ message"{}});\ \}));}
\DoxyCodeLine{08677\ \ \ EXPECT\_FALSE(matcher.Matches(}
\DoxyCodeLine{08678\ \ \ \ \ \ \ []()\ \{\ throw\ std::runtime\_error(\textcolor{stringliteral}{"{}wrong\ error\ message"{}});\ \}));}
\DoxyCodeLine{08679\ \}}
\DoxyCodeLine{08680\ }
\DoxyCodeLine{08681\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ GTEST\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{08682\ }
\DoxyCodeLine{08683\ \}\ \ \textcolor{comment}{//\ namespace}}
\DoxyCodeLine{08684\ \}\ \ \textcolor{comment}{//\ namespace\ gmock\_matchers\_test}}
\DoxyCodeLine{08685\ \}\ \ \textcolor{comment}{//\ namespace\ testing}}
\DoxyCodeLine{08686\ }
\DoxyCodeLine{08687\ \textcolor{preprocessor}{\#ifdef\ \_MSC\_VER}}
\DoxyCodeLine{08688\ \textcolor{preprocessor}{\#\ pragma\ warning(pop)}}
\DoxyCodeLine{08689\ \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
